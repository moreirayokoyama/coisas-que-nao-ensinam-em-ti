{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coisas Que N\u00e3o Ensinam em TI","text":""},{"location":"#coisas-que-nao-ensinam-em-ti","title":"Coisas Que N\u00e3o Ensinam em TI","text":"<p>Note</p> <p>Este curso \u00e9 uma adapta\u00e7\u00e3o para Portugu\u00eas(Brasil) do curso The Missing Semester in Your CS Formation do MIT.</p> <p>Parte deste conte\u00fado \u00e9 deliberadamente extra\u00eddo e traduzido do material do curso original, apesar de haver algumas adapt\u00e7\u00f5es e adequa\u00e7\u00f5es para esta vers\u00e3o, olhando para o contexto do mercado nacional e de algumas considera\u00e7\u00f5es feitas a partir de um contexto fora do ambiente acad\u00eamico (como no caso do MIT).</p>"},{"location":"#apresentacao-do-curso","title":"Apresenta\u00e7\u00e3o do Curso","text":""},{"location":"#conteudo-do-curso","title":"Conte\u00fado do Curso","text":"<ul> <li>Aula 1 - O Shell</li> <li>Aula 2 - Criando Scripts com Bash</li> </ul>"},{"location":"#atribuicoes","title":"Atribui\u00e7\u00f5es","text":"<p>Este curso est\u00e1 sob a licen\u00e7a CC BY-NC-SA (de acordo com o curso original). O curso original no qual este \u00e9 baseado foi elaborado por - Anish Athalye - Jon Gjengset - Jose Javier Gonzalez Ortiz</p> <p>Mais informa\u00e7\u00f5es sobre o curso original podem ser conferidas no Site Oficial.</p>"},{"location":"aulas/01-shell/","title":"Aula 01 - O Shell","text":""},{"location":"aulas/01-shell/#aula-1-o-shell","title":"Aula 1 - O Shell","text":"<p>Nesta primeira aula do nosso curso, apresentaremos o Shell como uma ferramenta prim\u00e1ria de produtividade das pessoas que trabalham em diversas \u00e1reas de TI.</p> <p>Quando navegamos pela internet atrav\u00e9s do uso de um Web Browser, ou usamos algum app ou qualquer aplicativo com uma interface gr\u00e1fica, estamos limitados ao que esta interface suporta. Se existe um bot\u00e3o dispon\u00edvel para uma determinada funcionalidade, a visibilidade deste bot\u00e3o \u00e9 o que determina se podemos nos beneficiar desta dela ou n\u00e3o. Se o bot\u00e3o n\u00e3o est\u00e1 vis\u00edvel, n\u00e3o podemos clicar nele.</p> <p>Uma interface de linha de comando (CLI), como a que temos quando usamos um Shell, torna mais flex\u00edvel o acesso que temos \u00e0s funcionalidades dispon\u00edveis.</p> <p>Saber usar o Shell e navegar por ele potencialmente torna o trabalho cotidiano mais produtivo e, por isto, estamos dando o devido foco em apresent\u00e1-lo neste curso.</p>"},{"location":"aulas/01-shell/#1-o-que-e-o-shell","title":"1. O que \u00e9 o Shell","text":"<p>Quase todas as plataformas com as quais voc\u00ea pode trabalhar atualmente oferecem um Shell, e muitas oferecem diferentes op\u00e7\u00f5es de Shell para voc\u00ea escolher. Apesar de que eles possam variar em seus detalhes, em sua ess\u00eancia s\u00e3o basicamente iguais: eles te permitem executar programas, manipular sua entrada (input) e inspecionar sua sa\u00edda (output) de uma forma semi-estruturada.</p>"},{"location":"aulas/01-shell/#11-shell-vs-terminal","title":"1.1 Shell vs Terminal","text":"<p>Para ter acesso a um Shell, voc\u00ea precisa de um Terminal. Um terminal \u00e9 um programa capaz de receber um comando, encaminhar para o Shell, e exibir seu resultado.</p> <p>O sistema que voc\u00ea usa em seu computador provavelmente possui um terminal dispon\u00edvel. Para os usu\u00e1rios de Windows (a partir do Windows 11), t\u00eam instalado em seu sistema o Windows Terminal. Para usu\u00e1rios de vers\u00f5es anteriores, o Windows Terminal est\u00e1 dispon\u00edvel para download gratuito na Microsoft Store. Outras op\u00e7\u00f5es de terminal para os usu\u00e1rios Windows s\u00e3o o ConEmu e o Cmder.</p> <p>J\u00e1 para os usu\u00e1rios de Linux/MacOS, existem diversas op\u00e7\u00f5es de terminal. Um dos terminais mais famosos para os usu\u00e1rios MacOS \u00e9 o iTerm2. No Linux, entre os terminais mais usados est\u00e3o o Terminator e o Guake.</p> <p>Escolher entre as diferentes op\u00e7\u00f5es de terminais normalmente depende das funcionalidades e conveni\u00eancias que cada op\u00e7\u00e3o oferece. Pain\u00e9is (tiles), Guias(tabs), Teclas de Atalho, Esquemas de Cores, e outras facilidades podem diferenciar as op\u00e7\u00f5es de terminais, mas de uma forma ou de outra, a maioria dos terminais dispon\u00edveis oferecem estas e outras funcionalides com algumas diferen\u00e7as sutis de como elas funcionam.</p>"},{"location":"aulas/01-shell/#12-diferentes-shells","title":"1.2 Diferentes Shells","text":"<p>Al\u00e9m dos diferentes sabores de terminais, existem tamb\u00e9m diferentes op\u00e7\u00f5es de Shells. Cada Shell pode apresentar uma sintaxe diferente de comandos e da forma como voc\u00ea interage atrav\u00e9s do terminal, apesar de haver muitas semelhan\u00e7as entre as principais op\u00e7\u00f5es.</p> <p>Para os usu\u00e1rios Windows, as duas principais op\u00e7\u00f5es de Shell dispon\u00edveis s\u00e3o:</p> <ul> <li>cmd</li> </ul> <p>O cmd \u00e9 o shell nativo do Windows, baseado no Prompt de Comando do antigo MS-DOS (sistema operacional da Microsoft anterior ao Windows). Ele suporta basicamente os comandos b\u00e1sicos do MS-DOS para navegar e manipular o sistema de arquivos.</p> <ul> <li>Windows PowerShell</li> </ul> <p>O PowerShell \u00e9 um Shell moderno criado pela Microsoft, como uma alternativa mais poderosa que o cmd para os usu\u00e1rios Windows.</p> <p>No mundo Linux e MacOS, existem op\u00e7\u00f5es similares de Shell, dentre elas as mais comuns s\u00e3o:</p> <ul> <li>Bash</li> </ul> <p>O Bash (Bourne Again Shell) \u00e9 uma op\u00e7\u00e3o de Shell dispon\u00edvel para Linux e MacOS baseado no Bourne Shell, que \u00e9 um Shell popular para o sistema Unix.</p> <ul> <li>Zsh</li> </ul> <p>O Zsh (z-shell) \u00e9 uma alternativa ao Bash que apresenta funcionalidades comuns, e acrescenta outras funcionalidades baseadas em outras famosas op\u00e7\u00f5es de Shell do sistema Unix (como o ksh e o tcsh), al\u00e9m de trazer funcionalidades \u00fanicas.</p>"},{"location":"aulas/01-shell/#2-bash-bourne-again-shell","title":"2. Bash (Bourne Again SHell)","text":"<p>Bash \u00e9 o shell mais popular atualmente, sendo a op\u00e7\u00e3o pr\u00e9-instalada no Ubuntu, que \u00e9 a distribui\u00e7\u00e3o do Linux mais baixada, al\u00e9m \u00e9 claro de fazer parte de outras distribui\u00e7\u00f5es tamb\u00e9m. Por causa da sua relev\u00e2ncia, toda a discuss\u00e3o relacioana a Shells ao longo deste curso, quando n\u00e3o abordada de uma forma generalista, usar\u00e1 como premissa o uso do bash.</p> <p>Para acompanhar o conte\u00fado deste curso, certifique-se de ter instalado o bash como uma das op\u00e7\u00f5es de Shell dispon\u00edveis no seus sistema. Usu\u00e1rios Linux e MacOS provavelmente j\u00e1 possuir\u00e3o o bash instalado, caso contr\u00e1rio, provavelmente encontrar\u00e3o uma f\u00e1cil instala\u00e7\u00e3o a partir de algum dos gerenciadores de pacote que seus sistemas disponibilizam.</p>"},{"location":"aulas/01-shell/#21-bash-para-usuarios-windows","title":"2.1 Bash para Usu\u00e1rios Windows","text":"<p>Para aqueles que acompanham este curso e s\u00e3o usu\u00e1rios do Microsoft Windows, existem op\u00e7\u00f5es de instala\u00e7\u00e3o do Bash. Vamos apresentar 3 delas para que voc\u00ea escolher a que melhor lhe for mais conveniente.</p> <ul> <li>MinGW64 / Cygwin</li> </ul> <p>Das op\u00e7\u00f5es dispon\u00edveis para se instalar o Bash no Windows, o MinGW64 e o Cygwin se diferenciam por n\u00e3o precisar virtualizar um outro sistema (como Linux). Ambos os projetos podem ser instalados em qualquer vers\u00e3o do Windows e fornecem um conjunto de ferramentas para criar um ambiente compat\u00edvel com um sistema semelhante ao Unix para pessoas que preferem trabalhar usando o Windows.</p> <p>O Bash disponibilizado por estas ferramentas, n\u00e3o \u00e9 totalmente compat\u00edvel com o Bash que voc\u00ea usaria ao criar uma instala\u00e7\u00e3o do Ubuntu, por exemplo, mas pode ser o suficiente para quem prefere n\u00e3o virtualizar (ou n\u00e3o pode).</p> <p>Para instalar o MinGW64, acesse o site: https://www.mingw-w64.org/downloads/</p> <p>Tip</p> <p>Se voc\u00ea instalar o Git para Windows (haver\u00e3o aulas neste curso que usar\u00e3o o Git), ele inclui o MinGW64 para disponibilizar um shell chamado Git Bash.</p> <p>Se voc\u00ea preferir instalar o Cygwin, o endere\u00e7o no site para baixar o instalador \u00e9: https://cygwin.com/install.html</p> <ul> <li>Criar um Memory Stick Inicializ\u00e1vel com uma distribui\u00e7\u00e3o do Linux</li> </ul> <p>\u00c9 poss\u00edvel ter uma distribui\u00e7\u00e3o do Linux dispon\u00edvel para uso sem precisar instal\u00e1-la no seu sistema, usando um Memory Stick (vulgo: Pen Drive) inicializ\u00e1vel.</p> <p>Existem diversos tutoriais na dispon\u00edveis na internet explicando com realizar o processo. Mas, resumidamente, voc\u00ea precisa baixar a imagem do sistema operacional (por exemplo, Ubuntu), e um programa capaz de configurar um Memory Stick com a imagem de forma inicializ\u00e1vel.</p> <p>Info</p> <p>Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows.</p> <ul> <li>Dual Boot com Linux</li> </ul> <p>Voc\u00ea pode criar uma instala\u00e7\u00e3o do Linux lado a lado com a instala\u00e7\u00e3o do Windows e ter a op\u00e7\u00e3o no seu dispositivo de qual dos sistemas voc\u00ea pretende usar no momento da inicializa\u00e7\u00e3o.</p> <p>Info</p> <p>Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows.</p> <p>Warning</p> <p>Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) se tornem exclusivos para o novo sistema, tornando-os indispon\u00edveis para o Windows. Isto requer algum planejamento sobre como estes recursos ser\u00e3o distribu\u00eddos.</p> <ul> <li>Virtualiza\u00e7\u00e3o de Linux</li> </ul> <p>Criar uma M\u00e1quina Virtual (VM) com uma instala\u00e7\u00e3o do Linux \u00e9 uma op\u00e7\u00e3o acess\u00edvel e, certamente, mais conveniente que a op\u00e7\u00e3o com Dual Boot. Uma VM \u00e9, basicamente, um computador virtual, com as mesmas funcionalidades que um dispositivo oferece, por\u00e9m, emulado a partir de um Sistema Hospedeiro (no caso, o Windows).</p> <p>Voc\u00ea pode criar VMs usando softwares gratuitos como o HyperV do Windows ou  VirtualBox da Oracle, e baixar uma imagem da distribui\u00e7\u00e3o Linux desejada (por exemplo, Ubuntu), para criar uma VM. Independente de qual plataforma voc\u00ea pretende usar, voc\u00ea vai precisar ativar o Hypervisor do Windows (que \u00e9 parte integrante da instala\u00e7\u00e3o do HyperV). Para isto, no menu iniciar (pressionando a tecla Windows no teclado), digite \"Ativar ou Desativar Recursos do Windows\", e ao abrir a janela dos Recursos do Windows, procure na lista o \u00edtem \"Hyper-V\" e certifique-se de que ele esteja selecionado. Ativar este recurso, ir\u00e1 exigir que voc\u00ea reinicialize seu computador.</p> <p>Warning</p> <p>Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) sejam compartilhados com a VM, podendo ter um impacto na performance do sistema hospedeiro.</p> <ul> <li>Windows Subsystem for Linux (WSL)</li> </ul> <p>Para usu\u00e1rios de vers\u00f5es mais recentes do Windows (a partir do Windows 10), \u00e9 poss\u00edvel virtualizar uma distribui\u00e7\u00e3o Linux usando um Kernel dispon\u00edvel pelo pr\u00f3prios Windows. Este \u00e9, inclusive, o m\u00e9todo que eu estou usando. \u00c9 um m\u00e9todo melhor do que criar uma VM, pois o WSL suporta uma integra\u00e7\u00e3o transparente entre os sistemas (compartilhando portas e programas).</p> <p>Este m\u00e9todo tamb\u00e9m exige que voc\u00ea ative o HyperV, al\u00e9m de ativar tamb\u00e9m o \"Subsistema do Windows para Linux\", e instalar a distribui\u00e7\u00e3o escolhida (por exemplo, Ubuntu), a partir das op\u00e7\u00f5es dispon\u00edveis na Microsoft Store.</p>"},{"location":"aulas/01-shell/#22-apresentando-o-ambiente-de-shell-com-bash","title":"2.2 Apresentando o ambiente de Shell com Bash","text":"<p>Ao abrir o terminal de sua escolha para acessar um Shell, invariavelmente voc\u00ea ir\u00e1 encontrar algo muito parecido com a imagem a seguir.</p> <p></p> <p>Uma janela vazia (normalmente com fundo escuro), mostrando no topo um texto com algumas informa\u00e7\u00f5es \u00faties e um cursor piscando, esperando que voc\u00ea digite algo.</p> <p>As informa\u00e7\u00f5es exibidas podem variar de um computador para o outro j\u00e1 que elas se baseiam nas configura\u00e7\u00f5es do usu\u00e1rio. No caso do meu shell, exibido acima, as informa\u00e7\u00f5es exibidas s\u00e3o:</p> <p>Info</p> <p><code>dmyoko@CodandoComOTio:~/projects/coisas-que-nao-ensinam-em-ti$</code> - Nome do usu\u00e1rio logado na sess\u00e3o - O <code>@</code> (arroba) separa o nome do usu\u00e1rio do nome do servidor da sess\u00e3o - O nome do servidor da sess\u00e3o - Os dois pontos (<code>:</code>) separam os dados da sess\u00e3o do caminho do diret\u00f3rio atual onde &gt;o shell ir\u00e1 aplicar os comandos     - No Bash, o caractere que separa os segmentos do caminho \u00e9 <code>/</code>, diferente do &gt;Windows que usa <code>\\</code> (barra invertida) - O cifr\u00e3o (<code>$</code>) no final, indica que o shell n\u00e3o est\u00e1 no modo super user.</p> <p>O nome desta linha, contendo estas ou quaisquer outras informa\u00e7\u00f5es de acordo com a configura\u00e7\u00e3o do shell, e o cursor esperando a entrada de um comando, \u00e9 <code>Prompt</code>.</p> <p>A partir daqui, qualquer texto digitado ser\u00e1 interpretado como um comando dado ao shell. Este comando pode servir para executar programas, rodar scripts ou executar comandos nativos do pr\u00f3prio shell.</p> <p>A partir do momento em que algo \u00e9 digitado e enviado para o shell (normalmente atrav\u00e9s do pressionamento da tecla Enter ou Return), o shell executa a linha digitada e o terminal imprime qualquer que seja o resultado (output) da execu\u00e7\u00e3o.</p> <p>Por exmeplo, uma instru\u00e7\u00e3o simples como <code>pwd</code> (que imprime o diret\u00f3rio atual do shell), pode demonstrar este fluxo. Ao inserir esta instru\u00e7\u00e3o e pressionar Enter (ou Return), o diret\u00f3rio \u00e9 exibido na linha abaixo da linha onde o comando foi dado, e na linha seguinte, um novo <code>prompt</code> \u00e9 exibido.</p> <p>O modo como trabalhamos no ambiente de Shell \u00e9 um ciclo: - Um prompt \u00e9 exibido indicando que o shell est\u00e1 pronto para receber comandos atrav\u00e9s do terminal - Um comando \u00e9 digitado no terminal e enviado ao shell - O shell interpreta o comando enviado e o executa - Qualquer resultado direcionado para a sa\u00edda (<code>output</code>) do shell \u00e9 exibido pelo terminal</p> <p>Com isto, podemos agora explorar um pouco alguns comandos que o Bash nos fornece.</p>"},{"location":"aulas/01-shell/#23-navegando-com-o-shell","title":"2.3 Navegando com o Shell","text":"<p>Vamos come\u00e7ar a explorar os comandos do Bash, aprendendo primeiro a navegar pelo sistema de arquivos.</p> <ul> <li>Exibindo o diret\u00f3rio atual: <code>pwd</code></li> </ul> <p>Como vimos agora h\u00e1 poudo, o comando <code>pwd</code> (Print Working Directory), imprime no terminal o caminho do diret\u00f3rio atual onde o Shell ir\u00e1 executar o pr\u00f3ximo comando. Saber qual \u00e9 o diret\u00f3rio atual \u00e9 importante, por que isto pode afetar diretamente o resultado do pr\u00f3ximo comando.</p> <p>Por exemplo, se o pr\u00f3ximo comando resultar na cria\u00e7\u00e3o de um arquivo, o arquivo ser\u00e1 criado no diret\u00f3rio atual, exceto se algum par\u00e2metro espec\u00edfico seja usado para mudar este comportamento (salvo, \u00e9 claro, se o programa executado tiver instru\u00e7\u00f5es espec\u00edficas do caminho do arquivo).</p> <ul> <li>Mudando o diret\u00f3rio atual: <code>cd</code></li> </ul> <p>Para mudar o diret\u00f3rio atual da sess\u00e3o do Shell, o comando usado \u00e9 o <code>cd</code> (Change Directory). Se voc\u00ea digitar apenas <code>cd</code> e pressionar Enter, ele vai mudar o diret\u00f3rio atual para <code>~</code> (falaremos logo a seguir sobre que diret\u00f3rio \u00e9 este). Ele n\u00e3o imprime nenhuma sa\u00edda, e imediatamente um novo prompt \u00e9 apresentado. Para informar o comando <code>cd</code> para que ele mude para um diret\u00f3rio diferente, um <code>argumento</code> precisa ser usado.</p> <p>Note</p> <p>Argumentos: s\u00e3o complementos que damos aos comandos, normalmente digitando-os a seguir do comando propriamente dito. Por exemplo, no comando <code>cd teste</code>, <code>teste</code> \u00e9 o argumento passado para o comando <code>cd</code>. Neste caso, o comando <code>cd</code> vai mudar mudar o diret\u00f3rio atual para o diret\u00f3rio <code>teste</code>.</p> <pre><code>cd teste\n</code></pre> <p>No meu caso, uma mensagem de erro \u00e9 exibida:</p> <pre><code>bash: cd: teste: No such file or directory\n</code></pre> <p>Ela diz que n\u00e3o existe um arquivo ou diret\u00f3rio chamado <code>teste</code>. Note, executando o comando <code>pwd</code> novamente, que o diret\u00f3rio atual permanece o mesmo.</p> <p>Para mudar o diret\u00f3rio atual, precisamos passar como argumento, o endere\u00e7o de um diret\u00f3rio existente. Por exemplo, um diret\u00f3rio que com certeza existe no sistema de arquivos \u00e9 o diret\u00f3rio raiz, que fica no endere\u00e7o <code>/</code>.</p> <pre><code>cd /\n</code></pre> <p>No meu caso, como voc\u00ea pode ver, o meu prompt mudou, agora dizendo que o diret\u00f3rio atual \u00e9 <code>/</code> (o diret\u00f3rio raiz). Se o seu prompt n\u00e3o exibe esta informa\u00e7\u00e3o como o meu, voc\u00ea pode confirmar usando o comando <code>pwd</code>.</p> <p>Outro diret\u00f3rio comum para quem usa o Bash, \u00e9 o diret\u00f3rio Home, representado pelo caractere <code>~</code>. Voc\u00ea pode testar o comando:</p> <pre><code>cd ~\n</code></pre> <p>Como pode ver, no meu prompt, agora ele exibe <code>~</code> como diret\u00f3rio atual, e n\u00e3o mais o diret\u00f3rio raiz (<code>/</code>).</p> <p>Ao contr\u00e1rio do diret\u00f3rio raiz, se voc\u00ea usar o comando <code>pwd</code> agora voc\u00ea vai notar que o diret\u00f3rio Home (<code>~</code>), na verdade, aponta para um diret\u00f3rio espec\u00edfico a partir da raiz. No meu caso, <code>/home/dmyoko</code> (no seu caso, vai apontar para um diret\u00f3rio com o nome do seu usu\u00e1rio dentro do diret\u00f3rio <code>/home</code>).</p> <p>Voc\u00ea pode navegar manualmente por estes diret\u00f3rios, usando o caminho que os leva at\u00e9 eles. Por exemplo:</p> <pre><code>cd /\ncd home\ncd dmyoko\n</code></pre> <p>Uma vez no diret\u00f3rio <code>/</code> (raiz), voc\u00ea tem acesso ao diret\u00f3rio <code>home</code>, e uma vez que voc\u00ea entra no diret\u00f3rio <code>home</code>, voc\u00ea tem acesso ao diret\u00f3rio do seu usu\u00e1rio, no meu caso <code>dmyoko</code>.</p> <p>Voc\u00ea tamb\u00e9m pode navegar direto para o diret\u00f3rio espec\u00edfico, usando o caminho completo absoluto que leva at\u00e9 ele, come\u00e7ando pelo diret\u00f3rio raiz.</p> <pre><code>cd /\ncd /home/dmyoko\n</code></pre> <p>Note</p> <p>Caminho absoluto \u00e9 o caminho completo que leva at\u00e9 um diret\u00f3rio ou arquivo no sistema de arquivos. Ele sempre come\u00e7a pelo diret\u00f3rio <code>/</code> (raiz), e segue toda a hierarquia de segmentos necess\u00e1rios at\u00e9 chegar no diret\u00f3rio ou arquivo desejado.</p> <ul> <li>Listar informa\u00e7\u00f5es sobre o conte\u00fado de um diret\u00f3rio: <code>ls</code></li> </ul> <p>O comando <code>ls</code> \u00e9 \u00fatil quando voc\u00ea deseja entender o conte\u00fado de um determinado diret\u00f3rio. Se voc\u00ea digitar somente <code>ls</code>, o Bash imprimir\u00e1 no terminal o conte\u00fado do diret\u00f3rio atual.</p> <p>Se voc\u00ea quiser listar o conte\u00fado de outro diret\u00f3rio sem necessariamente sair do diret\u00f3rio atual, basta usar como argumento o caminho para o diret\u00f3rio do qual voc\u00ea pretende listar o conte\u00fado desejado.</p> <pre><code>ls /\n</code></pre> <p>O comando acima, lista o conte\u00fado do diret\u00f3rio <code>/</code> (raiz). Voc\u00ea pode tamb\u00e9m listar o conte\u00fado de um dos subdiret\u00f3rios do diret\u00f3rio raiz, informando o endere\u00e7o dele. Por exemplo:</p> <pre><code>ls /bin\nls /lib\nls /sys/devices/cpu\n</code></pre> <p>O comando <code>ls</code> tamb\u00e9m suporta op\u00e7\u00f5es, que podem influenciar no resultado do comando. Por exemplo, a op\u00e7\u00e3o <code>-l</code> exibe o resultado do comando <code>ls</code> no formato de lista, trazendo informa\u00e7\u00f5es adicionais a respeito do conte\u00fado do diret\u00f3rio, que antes n\u00e3o estavam sendo exibidas, como as permiss\u00f5es de acesso ao diret\u00f3rio/arquivo listado, informa\u00e7\u00f5es de quem \u00e9 o usu\u00e1rio dono deste diret\u00f3rio/arquivo e a que grupo ele pertence (usu\u00e1rio <code>dmyoko</code> do grupo <code>dmyoko</code>, por exemplo), o tamanho do arquivo/diret\u00f3rio em bytes, e a data da \u00faltima vez que o arquivo/diret\u00f3rio foi modificado.</p> <pre><code>ls -l\n</code></pre> <p>Outra op\u00e7\u00f5a \u00fatil \u00e9 o <code>-h</code>, que faz com que os tamanhos dos arquivos exibidos sejam impressos num formato humanamente leg\u00edvel (human readable).</p> <pre><code>ls -h # sem efeito, pois os tamanhos n\u00e3o s\u00e3o exibidos\nls -l -h # agora \u00e9 poss\u00edvel ver o efeito.\nls -lh # \u00e9 poss\u00edvel unir todas as op\u00e7\u00f5es em uma \u00fanica cl\u00e1usula\n</code></pre> <p>Existem outras diversas op\u00e7\u00f5es dispon\u00edveis para o comando <code>ls</code>. Para ter acesso a uma lista completa delas, voc\u00ea pode digitar <code>ls --help</code>.</p> <p>Tip</p> <p><code>--help</code> \u00e9 uma op\u00e7\u00e3o dispon\u00edvel na vasta maioria dos comandos que voc\u00ea pode executar no shell. E, invariavelmente, imprime informa\u00e7\u00f5es sobre o que o comando faz e como utiliz\u00e1-lo, inclusive, mostrando poss\u00edveis op\u00e7\u00f5es que afetam a forma como este comando se comporta.</p>"},{"location":"aulas/01-shell/#24-permissoes-de-arquivos-e-diretorios","title":"2.4 Permiss\u00f5es de arquivos e diret\u00f3rios","text":"<p>Eu mencionei que a primeira coluna exibida como resultado do <code>ls -l</code> s\u00e3o as permiss\u00f5es dos arquivos ou diret\u00f3rios listados. Estas permiss\u00f5es indicam quem pode fazer o que com estes artefatos. Para dar uma breve  explica\u00e7\u00e3o, vamos entender como estas informa\u00e7\u00f5es s\u00e3o exibidas:</p> <p>Cada caractere exibido nesta coluna representa um atributo do artefato ao qual ele est\u00e1 ligado. O primeiro caractere, por exemplo, indica que tipo de artefato \u00e9 o item da lista. Um simples <code>-</code> indica que ele \u00e9 apenas um arquivo, e um <code>d</code> indica que ele \u00e9 um diret\u00f3rio. Existem outros tipos, que podemos discutir no futuro.</p> <p>Os demais caracteres s\u00e3o agrupamentos de 3 caracteres, cada caractere simbolizando uma permiss\u00e3o espec\u00edfica: <code>rwx</code>. - <code>r</code>: representa a permiss\u00e3o para leitura - <code>w</code>: representa a permiss\u00e3o para escrita - <code>x</code>: representa a permiss\u00e3o para execu\u00e7\u00e3o</p> <p>Os 3 caracteres est\u00e3o sempre nesta ordem, e podem ser substitu\u00eddos por um <code>-</code>, indicando que a devida opera\u00e7\u00e3o n\u00e3o \u00e9 permitida.</p> <p>Por exemplo: <code>rwx</code>: Todas as opera\u00e7\u00f5es s\u00e3o permitidas <code>rw-</code>: \u00c9 permitido ler e alterar o arquivo, mas n\u00e3o \u00e9 permitido execut\u00e1-lo <code>r--</code>: S\u00f3 se tem acesso para ler o conte\u00fado do arquivo, mas n\u00e3o \u00e9 permitido alter\u00e1-lo.</p> <p>Estas permiss\u00f5es s\u00e3o exibidas na seguinte ordem: - Permiss\u00f5es para o dono do arquivo - Permiss\u00f5es para os demais usu\u00e1rios do grupo dono do arquivo - Permiss\u00f5es para todos os demais usu\u00e1rios</p> <p>Por exemplo (retirado do screenshot acima): <code>drwxr-xr-x  2 root root  4096 Mar 25  2022 X11</code> Esta linha diz que <code>X11</code> \u00e9 um diret\u00f3rio (<code>d</code>), o dono (que \u00e9 o usu\u00e1rio <code>root</code>) possui permiss\u00e3o de leitura, escrita e execu\u00e7\u00e3o, enquanto que os outros membros do grupo <code>root</code> podem apenas ler o conte\u00fado e execut\u00e1-lo, bem como todos os outros usu\u00e1rios.</p> <p>Important</p> <p>Em um diret\u00f3rio, a permiss\u00e3o de execu\u00e7\u00e3o significa que o usu\u00e1rio \u00e9 capaz de navegar por ele (atrav\u00e9s do comando <code>cd</code>). A permiss\u00e3o de leitura significa que o usu\u00e1rio \u00e9 capaz de listar o conte\u00fado (atrav\u00e9s do comando <code>ls</code>) ou procurar por arquivos, etc. E a permiss\u00e3o de escrita significa que o usu\u00e1rio \u00e9 capaz de criar novos artefatos (arquivos, diret\u00f3rios, etc) dentro do diret\u00f3rio.</p>"},{"location":"aulas/01-shell/#25-manipulacao-do-sistema-de-arquivos","title":"2.5 Manipula\u00e7\u00e3o do sistema de arquivos","text":"<p>Agora que sabemos como navegar e obter informa\u00e7\u00f5es sobre o conte\u00fado do sistema de arquivos, vamos aprender como manipular o conte\u00fado dos diret\u00f3rios, criando, modificando e excluindo arquivos e diret\u00f3rios usando comandos do Shell.</p> <ul> <li>Criando diret\u00f3rios: <code>mkdir</code></li> </ul> <p>Para criar novos diret\u00f3rios, usamos o comando <code>mkdir</code> passando como argumento o nome  do diret\u00f3rio que queremos criar.</p> <pre><code>cd ~ #Certifique-se de estar no seu diret\u00f3rio `home`\nmkdir teste\n</code></pre> <p>O diret\u00f3rio <code>teste</code> ser\u00e1 criado no diret\u00f3rio atual, no caso, o diret\u00f3rio <code>home</code>. Voc\u00ea tamb\u00e9m pode criar um diret\u00f3rio em um lugar diferente do diret\u00f3rio atual, usando o endere\u00e7o completo desejado.</p> <pre><code>mkdir /home/dmyoko/teste/tmp\n</code></pre> <p>Warning</p> <p>Espa\u00e7os importam! Tome cuidado com o uso de espa\u00e7os quando estiver executando opera\u00e7\u00f5es no shell. Por exemplo, se voc\u00ea digitar o comando <code>mkdir minhas fotos</code>, ao inv\u00e9s de criar um diret\u00f3rio chamado <code>minhas fotos</code>, ele ir\u00e1 criar dois diret\u00f3rios, um chamado <code>minhas</code> e um segundo chamado <code>fotos</code>. Para usar espa\u00e7os voc\u00ea pode usar caracteres de escape. </p> <p>Para usar caracteres de escape, voc\u00ea usa a <code>\\</code> (barra invertida). Por exemplo: </p><pre><code>mkdir Minhas\\ Fotos # Cria um diret\u00f3rio chamado `Minhas Fotos`\n</code></pre> <p>Voc\u00ea pode, tamb\u00e9m, delimitar o nome usando aspas (<code>\"</code>) ou ap\u00f3strofos (<code>'</code>), como uma forma de indicar o nome sem usar caracteres de escape.</p> <p>O comando <code>mkdir</code> possui uma op\u00e7\u00e3o <code>-p</code> que permite que voc\u00ea crie um caminho completo de diret\u00f3rios:</p> <pre><code>mkdir -p /home/dmyoko/teste/a/b/c\n</code></pre> <p>Note que ele sabe lidar com o fato de que parte do caminho j\u00e1 existe (o diret\u00f3rio <code>/home/dmyoko/teste/</code>), e cria apenas os segmentos que n\u00e3o existem.</p> <p>Uma outra conveni\u00eancia desta op\u00e7\u00e3o \u00e9 que ela n\u00e3o resulta em erro, caso voc\u00ea tente criar um diret\u00f3rio que j\u00e1 existe, mesmo que seja o caminho completo. Isto \u00e9 \u00fatil, principalmente para automa\u00e7\u00f5es.</p> <pre><code>mkdir /home/dmyoko/teste/a/b/c #Resulta em erro\nmkdir -p /home/dmyoko/teste/a/b/c \n</code></pre> <ul> <li>Manipulando hora de acesso e modifica\u00e7\u00e3o de arquivos: <code>touch</code></li> </ul> <p>O comando touch for\u00e7a uma altera\u00e7\u00e3o na data de modifica\u00e7\u00e3o de arquivos.</p> <p>Para entender o que isto significa, vamos rever o resultado do comando <code>ls</code> no screenshot anterior: </p> <p>Observe a coluna imediatamente \u00e0 esquerda do nome do arquivo nesta lista, \u00e9 uma informa\u00e7\u00e3o de Data/Hora. Esta coluna indica a data/hora da \u00faltima modifica\u00e7\u00e3o que este arquivo teve. Ao usar o comando <code>touch</code>, voc\u00ea for\u00e7a uma atualiza\u00e7\u00e3o desta informa\u00e7\u00e3o para a data/hora atual do sistema.</p> <p>Apesar disso parecer algo usado para um prop\u00f3sito muito espec\u00edfico, o comando <code>touch</code> \u00e9 \u00fatil por que, ao ser usado para fazer isto em um arquivo inexistente, ele cria o arquivo. Por exemplo:</p> <pre><code>touch teste.txt\n</code></pre> <p>Se o arquivo teste.txt n\u00e3o existir, ele ser\u00e1 criado. Caso ele exista, somente a data/hora da \u00faltima modifica\u00e7\u00e3o ser\u00e3o afetados. Isto \u00e9 \u00fatil quando trabalhamos com scripts de automa\u00e7\u00e3o, pois garante a exist\u00eancia do arquivo sem incorrer num erro ao tentar cri\u00e1-lo novamente ou substitu\u00ed-lo acidentalmente.</p> <ul> <li>Copiando arquivos com <code>cp</code></li> </ul> <p>O comando <code>cp</code> \u00e9 usado para copiar arquivos. Ele funciona com dois argumentos: - O primeiro argumento \u00e9 o caminho do arquivo de origem, que se deseja copiar - O segudno argumento \u00e9 o caminho do arquivo de destino, para onde se deseja copiar o arquivo de origem</p> <p>Por exemplo:</p> <pre><code>cp teste.txt teste2.txt\ncp /home/dmyoko/teste /home/dmyoko/teste2 #Funciona com diret\u00f3rios\n</code></pre> <ul> <li>Movendo arquivos com <code>mv</code></li> </ul> <p>Por outro lado, se a inten\u00e7\u00e3o \u00e9 apenas mover arquivos entre caminhos, em vez criar uma c\u00f3pia (fazendo com que o arquivo deixe de existir no caminho de origem), o comando <code>mv</code> pode ser usado de forma semelhante ao <code>cp</code>, passando os mesmos argumentos.</p> <pre><code>mv teste2.txt teste3.txt #Funciona como se o arquivo fosse renomeado\nmv teste3.txt /home/dmyoko/teste2\nmv /home/dmyoko/teste2 /home/dmyoko/teste3\n</code></pre> <ul> <li>Removendo arquivos com <code>rm</code></li> </ul> <p>Para remover arquivos, usamos o comando <code>rm</code>. Ao contr\u00e1rio dos comandos anteriores <code>cp</code> e <code>mv</code>, o comando <code>rm</code> n\u00e3o afeta diret\u00f3rios por padr\u00e3o. Sendo usado especificamente para arquivos.</p> <p>Por exemplo: </p><pre><code>rm /home/dmyoko/teste/teste3.txt\n</code></pre> <p>Para remover diret\u00f3rios, existe o usando o comando <code>rmdir</code>, mas ele funciona apenas com diret\u00f3rios vazios. Se houve qualquer arquivo dentro do diret\u00f3rio, ele se recusa a exclu\u00ed-lo. Por exemplo:</p> <pre><code>rmdir /home/dmyoko/teste\n</code></pre> <p>Gera esta mensagem de erro: </p><pre><code>rmdir: failed to remove 'teste': Directory not empty\n</code></pre> <p>Para remover um diret\u00f3rio n\u00e3o vazio (excluindo seu conte\u00fado em consequ\u00eancia), o comando <code>rm</code> disponibiliza op\u00e7\u00f5es que permitem fazer isto. O motivo de exigir o uso destas op\u00e7\u00f5es \u00e9 evitar que se exclua arquivos por acidente, for\u00e7ando o usu\u00e1rio a fazer o uso deliberado delas para se certificar do que est\u00e1 fazendo.</p> <pre><code>rm -r /home/dmyoko/teste\n</code></pre>"},{"location":"aulas/01-shell/#26-caminho-absoluto-caminho-relativo-e-caracteres-coringa","title":"2.6 Caminho Absoluto, Caminho Relativo e Caracteres Coringa","text":"<p>At\u00e9 aqui, temos usado o que chamamos de Caminho Absoluto (Absolute Path) para endere\u00e7ar os arquivos e diret\u00f3rios que usamos. Mas existem atalhos especiais que nos ajudam a facilitar a descri\u00e7\u00e3o de caminhos baseados no diret\u00f3rio atual em que nos localizamos.</p> <p>Uma das op\u00e7\u00f5es dispon\u00edveis no comando <code>ls</code> \u00e9 a op\u00e7\u00e3o <code>-a</code> ou <code>--all</code>, que deixam de ignorar certos arquivos que normalmente n\u00e3o s\u00e3o exibidos. Por padr\u00e3o, os arquivos que come\u00e7am com <code>.</code> (ponto), ficam ocultos normalmente no comando <code>ls</code>. Vamos ver quais arquivos visualizamos ao usar esta op\u00e7\u00e3o:</p> <pre><code>ls -lha\n</code></pre> <p>Dentre os novos arquivos que antes n\u00e3o eram exibidos, existem dois diret\u00f3rios especiais: <code>.</code> e <code>..</code>.</p> <p>Estes diret\u00f3rios s\u00e3o usados para nos referirmos a Caminhos Relativos (Relative Paths). O diret\u00f3rio <code>.</code>, aponta para o diret\u00f3rio atual, onde a sess\u00e3o do bash est\u00e1 localizada (o diret\u00f3rio onde voc\u00ea se encontra e que ser\u00e1 exibido com o comando <code>pwd</code>).</p> <p>J\u00e1 o diret\u00f3rio <code>..</code>, aponta para o diret\u00f3rio pai do diret\u00f3rio atual, imediatamente superior na hierarquia de diret\u00f3rios, o diret\u00f3rio que antecede o diret\u00f3rio atual na sa\u00edda do comando <code>pwd</code>.</p> <p>Ambos estes diret\u00f3rios podem ser usados como atalho para execu\u00e7\u00e3o de comandos, como os comandos que usamos at\u00e9 aqui:</p> <pre><code># Criando alguns elementos para demonstrar caminhos relativos\ncd ~ \nmkdir -p teste/a/b/c\ncd teste/a/b\ntouch c/teste.txt\n\ncp c/teste.txt .. # copia o arquivo dentro do diret\u00f3rio c para ~/teste/a\nmv c/teste.txt . # move o arquivo dentro do diret\u00f3rio c para ~/teste/a/b\nrm ../teste.txt # exclui o arquivo teste.txt do diret\u00f3rio ~/teste/a\ncp teste.txt ../.. #copia o arquivo teste.txt do diret\u00f3rio atual para ~/teste\nls -lha ../.. # lista os arquivos do diret\u00f3rio ~/teste\n</code></pre> <p>Outro atalho \u00fatil para comandos usando o bash (e outros shells tamb\u00e9m costumam suportar), s\u00e3o Caracteres Coringa (Wild Cards), usados para selecionar arquivos que correspondem com a alguns padr\u00f5es em seus nomes. Para demonstrar isto, vamos antes criar alguns arquivos: </p><pre><code>cd ~/teste\ntouch foo foo1 foo2 foo10 bar\n</code></pre> <p>Existem dois caracteres coringas: <code>?</code> e <code>*</code>. - o <code>?</code> serve como uma forma de se referir a qualquer caractere que esteja em uma determinada posi\u00e7\u00e3o no nome do arquivo. Por exemplo: </p><pre><code>ls foo? # Lista todos os arquivos cujo nome come\u00e7am com `foo` e que possuem qualquer outro caractere \u00fanico em seguida\n</code></pre> <p>Note que, como resultado deste comando, os arquivos <code>foo1</code> e <code>foo2</code> foram os \u00fanicos exibidos. Os demais arquivos foram ignorados por n\u00e3o combinarem com o padr\u00e3o, pois <code>foo</code> n\u00e3o possui nenhum caractere na posi\u00e7\u00e3o onde o <code>?</code> se encontra, e <code>foo10</code> possui ainda um caractere a mais (j\u00e1 o arquivo <code>bar</code> n\u00e3o corresponde em absolutamente nada com o padr\u00e3o usado).</p> <ul> <li>o <code>*</code> serve como uma forma de se referir a quaisquer combina\u00e7\u00e3o de zero ou mais caracteres que possam estar em uma determinada posi\u00e7\u00e3o no nome dos arquivos. Por exemplo: <pre><code>ls foo*\n</code></pre></li> </ul> <p>Desta vez, s\u00e3o listados todos os arquivos que come\u00e7am com <code>foo</code>, independente de quantos caracteres a mais eles possuem ou n\u00e3o. O arquivo <code>bar</code>, como antes, \u00e9 ignorado por n\u00e3o corresponder ao padr\u00e3o.</p> <p>Voc\u00ea pode usar os caracteres coringa para designar arquivos e diret\u00f3rios como argumentos para qualquer comando do <code>Bash</code>. Por exemplo: </p><pre><code>rm f?? # apaga somente o arquivo foo\ncp foo* ./a # copia os arquivos foo1, foo2 e foo10 para ./a\nmv foo? ./a/b # move somente os arquivos foo1 e foo2 para ./a/b\ntouch * # Atualiza a data/hora de modifica\u00e7\u00e3o de todos os arquivos para a hora atual do sistema\n</code></pre>"},{"location":"aulas/01-shell/#27-conectando-programas","title":"2.7 Conectando Programas","text":"<p>Uma das capacidades mais incr\u00edveis do <code>Bash</code> \u00e9 a forma como \u00e9 poss\u00edvel manipular a entrada e sa\u00edda dos programas e conect\u00e1-las de diversas formas para redefinir o comportamento padr\u00e3o dos comandos. Me permita explicar melhor antes, como o Shell lida com a entrada e sa\u00edda dos comandos.</p>"},{"location":"aulas/01-shell/#271-streams-de-entrada-e-saida-inputoutput-streams","title":"2.7.1 Streams de Entrada e Sa\u00edda (Input/Output Streams)","text":"<p>No Shell, programas possuem dois streams prim\u00e1rios associados a eles: o stream de entrada (input), e o stream de sa\u00edda (output). Quando o programa tenta ler a entrada, ele l\u00ea do stream de entrada, e quando ele imprime algo, ele imprime no stream de sa\u00edda. Normalmente, os streams de entrada e sa\u00edda de um programa s\u00e3o o seu terminal (quando rodando a partir do shell). Ou seja, seu teclado (\u00e0 medida que voc\u00ea digita no shell) e a janela do terminal na sua tela. Contudo, n\u00f3s podemos tamb\u00e9m religar estes streams de outras formas.</p> <p>Important</p> <p>Streams em computa\u00e7\u00e3o, \u00e9 um termo comum usado para designar um fluxo de dados que n\u00e3o acontece de uma \u00fanica vez, mas que \u00e9 feito de forma cont\u00ednua, ao longo do tempo, em pequenos lotes.</p> <p>Aqui estamos falando de Streams sendo usados para o fluxo cont\u00ednuo de dados de entrada e de sa\u00edda de um comando ou programa executado no shell. Mas o conceito \u00e9 muito comum em diversas outras \u00e1reas da computa\u00e7\u00e3o, como na leitura/escrita de arquivos no disco, ou obtendo/enviando dados atrav\u00e9s da rede/internet.</p> <p>O termo ficou ainda mais popular com a transmiss\u00e3o de conte\u00fado online como chamadas de v\u00eddeo ou transmiss\u00f5es audiovisuais em lives na internet.</p>"},{"location":"aulas/01-shell/#272-religamento-de-streams","title":"2.7.2 Religamento de Streams","text":"<p>A forma mais simples de religar streams no <code>Bash</code> \u00e9 atrav\u00e9s dos operadores <code>&gt;</code> (para religar o stream de sa\u00edda do programa) e <code>&lt;</code> (para religar o stream de entrada do programa). Vamos ver alguns exemplos:</p> <pre><code>ls ~ -lha &gt; ~/teste/ls.txt # Religa o stream de sa\u00edda do comando ls para o arquivo ~/teste/ls.txt\n</code></pre> <p>Note que o comando <code>ls</code> acima n\u00e3o imprimiu a sa\u00edda no terminal como de costume. Por outro lado, voc\u00ea pode conferir um novo arquivo criado no diret\u00f3rio <code>~/teste</code> chamando <code>ls.txt</code>. Voc\u00ea pode usar o comando <code>cat</code> (que imprime o conte\u00fado de um arquivo no terminal) e voc\u00ea ir\u00e1 notar que o seu conte\u00fado \u00e9 a sa\u00edda do comando <code>ls</code> que teria sido impressa no terminal se n\u00e3o a tiv\u00e9ssemos religado.</p> <p>Uma forma de conferir o conte\u00fado do arquivo <code>~/teste/ls.txt</code>, \u00e9 o utilizando como stream de entrada do comando <code>cat</code>, que imprime o stream de entrada no stream de sa\u00edda. Ao religar o stream de entrada do comando <code>cat</code> usando o arquivo <code>~/teste/ls.txt</code> sem religar o stream de sa\u00edda, ele ir\u00e1 imprimir o conte\u00fado no terminal.</p> <pre><code>cat &lt; ~/teste/ls.txt\n</code></pre> <p>O comando <code>cat</code>, quando n\u00e3o especificado nenhum argumento, usa o terminal como stream de entrada (capturando tudo o que o usu\u00e1rio digitar) e as imprime no stream de sa\u00edda (que tamb\u00e9m \u00e9 o pr\u00f3prio terminal, imprimindo exatamente o que \u00e9 digitado), \u00e0 medida que os dados s\u00e3o enviados (normalmente, sempre que uma linha \u00e9 finalizada). O resultado padr\u00e3o do comando <code>cat</code>, \u00e9 ter suas linhas repetidas, uma vindo pela entrada, e logo em seguida sendo impressa na sa\u00edda.</p> <pre><code>cat # demonstrando os dados digitados no stream de entrada, e impressos na sa\u00edda imediatamente depois\n</code></pre> <p>Por exemplo, \u00e9 poss\u00edvel usar o cat como um editor de um novo arquivo, que ser\u00e1 criado usando a religa\u00e7\u00e3o do stream de sa\u00edda, digitando o conte\u00fado a partir do stream de entrada.</p> <pre><code>cat &gt; ~/teste/arquivo.txt # Ao digitar conte\u00fado na entrada, ele ser\u00e1 direcionado para o arquivo.txt\n</code></pre> <p>Note</p> <p>Para encerrar a leitura da entrada, n\u00f3s usamos o comando Ctrl+Z. Isto envia um sinal para o processo que est\u00e1 executando o comando <code>cat</code>, orientando-o a parar.</p> <p>Existem outras formas de enviar sinais aos processos quando estamos executando programas no bash, mas veremos isto no futuro.</p> <p>Um outro operador \u00fatil \u00e9 o operador <code>&gt;&gt;</code>. Ele tem, basicamente o mesmo efeito do operador <code>&gt;</code>, que religa o stream de sa\u00edda, com exce\u00e7\u00e3o de que, se a sa\u00edda \u00e9 redirecionada a um arquivo que j\u00e1 existe, ele concatena a sa\u00edda do programa atual ao conte\u00fado original do arquivo, uma opera\u00e7\u00e3o popularmente conhecida na computa\u00e7\u00e3o como <code>append</code>. Ou seja, o conte\u00fado original do arquivo \u00e9 mantido, e o novo conte\u00fado \u00e9 enviado ao final dele.</p> <pre><code>ls -lha ~ &gt;&gt; ~/teste/arquivo.txt\n</code></pre> <p>Note que o conte\u00fado original do <code>arquivo.txt</code> foi mantido, e o resultado do comando <code>ls</code> foi inserido depois da \u00faltima linha original.</p> <p>Existe um operador que conecta a sa\u00edda de um comando do bash \u00e0 entrada de outro comando, criando uma cadeia de comandos, ou \"esteira\" (pipeline), de etapas pelas quais os dados resultantes de um programa s\u00e3o aplicados ao outro, sendo transformados at\u00e9 produzirem uma sa\u00edda desejada. Este operador \u00e9 o <code>|</code> (pipe).</p> <pre><code>ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt\n</code></pre> <p>Aqui temos uma pipeline que faz a seguinte sequ\u00eancia: - <code>ls -lha ~</code> - lista todos os arquivos da pasta <code>home</code>, em formato de lista, com tamanhos humanamente leg\u00edveis, e inclindo os arquivos ocultos (que come\u00e7am com <code>.</code>) - <code>grep Jul</code> - o comando <code>grep</code> filtra as linhas vindas da entrada de acordo com algum padr\u00e3o (no caso, <code>Jul</code>). Basicamente ele pega o resultado do <code>ls</code> e separa somente os arquivos modificados em Julho - <code>head -5</code>- O comando <code>head</code> toma somente as primeiras linhas da entrada. Por padr\u00e3o, ele toma somente as primeiras 10, mas a op\u00e7\u00e3o <code>-5</code> faz com que ele pegue somente as primeiras 5 e ignore as demais linhas. - <code>tee /&lt;caminho&gt;</code> - O comando <code>tee</code> \u00e9 um comando similar ao comando <code>cat</code>, com a diferen\u00e7a que, al\u00e9m de imprimir no stream de sa\u00edda, ele tamb\u00e9m escreve o arquivo. No caso acima, ele escreve no terminal e no arquivo <code>/home/dmyoko/teste/pipeline.txt</code>.     - Por exemplo, \u00e9 poss\u00edvel criar dois arquivos a partir do comando <code>tee</code>:</p> <pre><code>ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt &gt; /home/dmyoko/teste/pipeline2.txt\n</code></pre> <ul> <li>A linha acima instrui instrui o <code>tee</code> a escrever a entrada no arquivo <code>/home/dmyoko/teste/pipeline.txt</code> e religa o stream de sa\u00edda para o arquivo <code>/home/dmyoko/teste/pipeline2.txt</code> usando o operador <code>&gt;</code>.</li> <li>Imagine talvez, usar o operador <code>&gt;&gt;</code> nesta linha, e qual ser\u00e1 o resultado. Como isso iria diferir ambos os arquivos.</li> </ul> <p>N\u00f3s iremos usar muito o operador de pipe (<code>|</code>) na aula em que iremos tratar de Manipula\u00e7\u00e3o de Dados no Shell.</p>"},{"location":"aulas/01-shell/#28-comandos-uteis","title":"2.8 Comandos \u00dateis","text":"<ul> <li> <p><code>man</code> O comando <code>man</code> exibe um manual de diversos comandos do <code>bash</code>. Usa-se passando como argumento o nome do comando que se deseja consultar: </p><pre><code>man mkdir\n</code></pre> </li> <li> <p><code>find</code> O comando <code>find</code> ajuda a localizar arquivos, procurando n\u00e3o somente no diret\u00f3rio usado como argumento, mas automaticamente buscando em todos os seus subdiret\u00f3rios. Se um diret\u00f3rio n\u00e3o for passado como argumento, o comando <code>find</code> usa o diret\u00f3rio atual por padr\u00e3o. Ele aceita diversas op\u00e7\u00f5es para ajudar a encontrar arquivos de acordo com crit\u00e9rios espec\u00edficos, como o nome do arquivo (op\u00e7\u00e3o <code>-name</code> seguido do nome que se busca, para usar coringas \u00e9 necess\u00e1rio delimitar com ap\u00f3strofos), e muitas outras op\u00e7\u00f5es \u00fateis.</p> </li> </ul> <p>Consulte o manual (<code>man find</code>) para ler sobre todas as op\u00e7\u00f5es dispon\u00edveis.</p> <ul> <li> <p><code>date</code> Imprime a data/hora atual do sistema. Existem diversas op\u00e7\u00f5es de formata\u00e7\u00e3o em que a Data/Hora ser\u00e3o impressas, para saber mais consulte as p\u00e1ginas do Manual (<code>man date</code>)</p> </li> <li> <p><code>diff</code> Imprime as diferen\u00e7as entre o conte\u00fado de dois caminhos, que precisam ser especificados via argumentos. Podendo ser ambos diret\u00f3rios ou arquivos, mas n\u00e3o compara se forem de tipos diferentes.</p> </li> <li> <p><code>history</code> Imprime no terminal o hist\u00f3rico de comandos usados nesta sess\u00e3o do <code>Bash</code>.</p> </li> <li> <p><code>tail</code> O comando <code>tail</code> \u00e9 parecido com o comando <code>head</code>, com a diferen\u00e7a de que, em vez de tomar somente as primeiras x linhas da entrada e ignorar as demais, ele toma somente as \u00faltimas x linhas e ignora as primeiras.</p> </li> <li> <p><code>less</code> O comando <code>less</code> \u00e9 \u00f3timo para ser usado com comandos que resultam em um n\u00famero elevado de linhas. Ele exibe o resultado de forma paginada e interativa, te permitindo controlar a navega\u00e7\u00e3o pelos dados.</p> </li> </ul>"},{"location":"aulas/01-shell/#3-conclusao","title":"3. Conclus\u00e3o","text":"<p>Nesta aula tivemos um contato bastante profundo com o <code>Bash</code> e a abordagem de trabalhar a partir de um <code>Shell</code>. Ainda temos muito o que explorar pra explorarmos o shell e conseguir fazer dele um lugar onde possamos nos sentir mais confort\u00e1veis e produtivos o suficiente para fazer dele nosso lugar de trabalho. Mas nas pr\u00f3ximas aulas, ficaremos cada vez mais pr\u00f3ximos disto.</p> <p>Com esta introdu\u00e7\u00e3o, podemos explorar outras ferramentas, como a constru\u00e7\u00e3o de scripts, manipular dados e aprender as conven\u00e7\u00f5es de como \u00e9 a vida na interface de linha de comando (Command Line Interface ou, simplesmente, CLI).</p> <p>Bem-vindo a esta jornada, e espero que este primeiro passeio tenha despertado o interesse em prosseguir com as pr\u00f3ximas aulas.</p> <p>Pr\u00f3xima Aula: Aula 2 - Criando Scripts com Bash</p>"},{"location":"aulas/02-scripting/","title":"Aula 2 - Criando Scripts com Bash","text":""},{"location":"aulas/02-scripting/#aula-2-criando-scripts-com-bash","title":"Aula 2 - Criando Scripts com Bash","text":"<p>Na aula passada fomos apresentados ao ambiente do Shell e come\u00e7amos a nos familiarizar com a vida no terminal usando Bash. Apesar de termos explorado muitas ferramentas que nos permitem interagir com o sistema de arquivos, o uso do Shell n\u00e3o est\u00e1 relegado somente a manipular arquivos e diret\u00f3rios. \u00c9 poss\u00edvel usar o Shell como um ambiente produtivo para lidar com as mais diversas tarefas e, inclusive, automatiz\u00e1-las.</p> <p>Nesta aula iremos explorar as capacidades de automa\u00e7\u00e3o do Bash e criar scripts que expandem a sua utilidade na execu\u00e7\u00e3o de tarefas rotineiras, que o tornam, basicamente, uma linguagem de programa\u00e7\u00e3o n\u00e3o muito diferente das muitas linguagens dispon\u00edveis.</p>"},{"location":"aulas/02-scripting/#21-imprimindo-valores-hello-world","title":"2.1 - Imprimindo Valores (Hello world)","text":"<p>A opera\u00e7\u00e3o mais b\u00e1sica que as linguagens de programa\u00e7\u00e3o apresentam \u00e9 a capacidade de imprimir um valor para o usu\u00e1rio. O ritual de inicia\u00e7\u00e3o padr\u00e3o para todos os que estudam uma linguagem de programa\u00e7\u00e3o \u00e9 imprimir a mensagem universal \"Hello, world\" (Ol\u00e1 mundo). Usando Bash, o comando que usamos para imprimir mensagens para o usu\u00e1rio \u00e9 o comando <code>echo</code>.</p> <pre><code>echo \"Hello world\"\n</code></pre> <p>Como vimos na aula passada, as aspas (<code>\"</code>) s\u00e3o necess\u00e1rias quando queremos usar espassos nos argumentos dos comandos que usamos no Bash, de outra forma o Bash iria interpretar os espa\u00e7os como separadores de argumentos, possibilitando resultados inesperados. No caso do comando <code>echo</code>, independente de quantos argumentos voc\u00ea usa, o comportamento dele ser\u00e1 o mesmo.</p> <pre><code>echo Hello world\n</code></pre> <p>Mas, \u00e9 de bom tom seguir a conven\u00e7\u00e3o e usar delimitadores (<code>\"</code> ou <code>'</code>) para garantir a consist\u00eancia dos argumentos. Ao longo desta aula, manter esta consist\u00eancia far\u00e1 mais sentido, \u00e0 medida que veremos como argumentos podem ser transformados ou reutilizados.</p>"},{"location":"aulas/02-scripting/#22-expressoes","title":"2.2 - Express\u00f5es","text":"<p>O uso de delimitadores, como o que usamos para definir o argumento \"Hello world\" para o comando <code>echo</code>, \u00e9 um exemplo de uma express\u00e3o. Express\u00f5es s\u00e3o formas de criar valores em uma linguagem de programa\u00e7\u00e3o, e em Bash n\u00e3o \u00e9 diferente. Express\u00f5es de textos s\u00e3o as mais simples que podemos usar, mas existem outros tipos de express\u00f5es, e falaremos um pouco sobre alguns deles.</p> <p>Um tipo de express\u00e3o comum em Bash, \u00e9 o resultado da execu\u00e7\u00e3o de um comando. Para criar express\u00f5es deste tipo, usamos a nota\u00e7\u00e3o <code>$(&lt;comando-bash&gt;)</code>.</p> <pre><code>echo $(ls)\n</code></pre> <p>A linha acima executa o comando <code>ls</code> e usa a sa\u00edda como resultado de uma express\u00e3o que \u00e9 ent\u00e3o passada para o comando <code>echo</code>. O resultado \u00e9 semelhante \u00e0 execu\u00e7\u00e3o do comando <code>ls</code> no shell (a exibi\u00e7\u00e3o da lista de arquivos). A diferen\u00e7a \u00e9 que podemos usar esta express\u00e3o em outras opera\u00e7\u00f5es, n\u00e3o apenas para exib\u00ed-las (usando o comando <code>echo</code>), mas tamb\u00e9m, por exemplo, atribuir este valor a vari\u00e1veis e reutiliz\u00e1-la para outros fins, como veremos em breve.</p> <p>\u00c9 poss\u00edvel, tamb\u00e9m, executar express\u00f5es aritm\u00e9ticas e exibir seu resultado. Para criarmos uma express\u00e3o aritm\u00e9tica, usamos a nota\u00e7\u00e3o <code>$(( &lt;express\u00e3o-aritm\u00e9tica&gt; ))</code>. Desta forma, o shell n\u00e3o tentar\u00e1 interpretar a express\u00e3o como se fosse um comando.</p> <pre><code>echo $((7 + 8))\necho $((7 * 8))\necho $(((7 - 3) / (8 % 3)))\n</code></pre>"},{"location":"aulas/02-scripting/#23-definindo-variaveis","title":"2.3 - Definindo vari\u00e1veis","text":"<p>Como em qualquer linguagem de programa\u00e7\u00e3o, em Bash n\u00f3s podemos definir vari\u00e1veis para guardar valores que precisam ser reutilizados. Para definir vari\u00e1veis em Bash, tudo o que precisamos fazer \u00e9 uma atribui\u00e7\u00e3o de um valor a um nome, usando o operador <code>=</code>. O \u00fanico cuidado que devemos ao fazermos uma atribui\u00e7\u00e3o \u00e9 redobrar nossa aten\u00e7\u00e3o ao fato de que, em Bash, espa\u00e7os contam. Por exemplo:</p> <pre><code>foo=bar # Atribui\u00e7\u00e3o do valor `bar` a uma nova vari\u00e1vel chamada `foo`\nfoo = bar # Erro. O Bash tenta executar um comando chamado `foo` com 2 argumentos (`-` e `bar`).\n</code></pre> <p>Para usarmos as vari\u00e1veis que criamos, n\u00f3s nos referimos a elas usando o sinal <code>$</code> como prefixo. Por exemplo:</p> <pre><code>echo $foo\n</code></pre> <p>Qualquer resultado de uma express\u00e3o pode ser atribu\u00eddo a uma vari\u00e1vel:</p> <pre><code>soma=$((7 + 8))\n</code></pre>"},{"location":"aulas/02-scripting/#231-interpolacao-de-valores","title":"2.3.1 - Interpola\u00e7\u00e3o de Valores","text":"<p>Interpola\u00e7\u00e3o de valores \u00e9 a capacidade que o Bash tem de identificar marcadores em valores de texto para substituir por valores computados durante a execu\u00e7\u00e3o do comando. Por exemplo:</p> <pre><code>echo \"o conte\u00fado da vari\u00e1vel foo \u00e9 $foo\"\n</code></pre> <p>No c\u00f3digo acima, o Bash vai identificar o uso da vari\u00e1vel foo (usada com o <code>$</code>), e vai substituir este marcador pelo valor da vari\u00e1vel.</p> <p>A interpola\u00e7\u00e3o de valores s\u00f3 funciona com textos delimitados por <code>\"</code> (aspas). Se o texto for delimitado por <code>'</code> (ap\u00f3strofos), o bash trata o texto como literal e n\u00e3o faz a interpola\u00e7\u00e3o. Esta distin\u00e7\u00e3o tem suas vantagens, como por exemplo, quando voc\u00ea quer que a interpola\u00e7\u00e3o aconte\u00e7a em um momento diferente do da execu\u00e7\u00e3o do script, delegando a interpola\u00e7\u00e3o para outra etapa da automa\u00e7\u00e3o, ou outro processo que ser\u00e1 executado.</p> <p>Podemos, tamb\u00e9m, interpolar valores resultantes de quaisquer tipos express\u00f5es suportadas pelo Bash.</p> <pre><code>echo \"Interpolando o valor de uma vari\u00e1vel: $foo\"\necho \"Interpolando o resultado de um comando: $(ls -lha ~ | grep Jul)\"\necho \"Interpolando o resultado de uma express\u00e3o aritm\u00e9tica: $((2 + 3 - 4 * 5 / 6 % 7))\"\n</code></pre>"},{"location":"aulas/02-scripting/#232-variaveis-especiais-pre-definidas","title":"2.3.2 - Vari\u00e1veis Especiais pr\u00e9-definidas","text":""},{"location":"aulas/02-scripting/#233-variaveis-de-ambiente","title":"2.3.3 - Vari\u00e1veis de ambiente","text":""},{"location":"aulas/02-scripting/#24-operadores","title":"2.4 - Operadores","text":""},{"location":"aulas/02-scripting/#25-substituicoes-de-comando","title":"2.5 - Substitui\u00e7\u00f5es de Comando","text":""},{"location":"aulas/02-scripting/#26-expansoes-do-shell","title":"2.6 - Expans\u00f5es do Shell","text":""},{"location":"aulas/02-scripting/#27-stream-de-erro","title":"2.7 - Stream de Erro","text":""},{"location":"aulas/02-scripting/#28-shell-script","title":"2.8 - Shell Script","text":""},{"location":"aulas/02-scripting/#281-executando-scripts","title":"2.8.1 - Executando Scripts","text":"<ul> <li>shebang</li> </ul>"},{"location":"aulas/02-scripting/#282-estruturas-de-controle","title":"2.8.2 - Estruturas de controle","text":""},{"location":"aulas/02-scripting/#283-funcoes","title":"2.8.3 - Fun\u00e7\u00f5es","text":""},{"location":"aulas/02-scripting/#29-conclusao","title":"2.9 - Conclus\u00e3o","text":""}]}