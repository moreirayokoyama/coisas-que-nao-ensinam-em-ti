{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Coisas Que N\u00e3o Ensinam em TI","text":""},{"location":"#coisas-que-nao-ensinam-em-ti","title":"Coisas Que N\u00e3o Ensinam em TI","text":"<p>Note</p> <p>Este curso \u00e9 uma adapta\u00e7\u00e3o para Portugu\u00eas(Brasil) do curso The Missing Semester in Your CS Formation do MIT.</p> <p>Parte deste conte\u00fado \u00e9 deliberadamente extra\u00eddo e traduzido do material do curso original, apesar de haver algumas adapt\u00e7\u00f5es e adequa\u00e7\u00f5es para esta vers\u00e3o, olhando para o contexto do mercado nacional e de algumas considera\u00e7\u00f5es feitas a partir de um contexto fora do ambiente acad\u00eamico (como no caso do MIT).</p>"},{"location":"#apresentacao-do-curso","title":"Apresenta\u00e7\u00e3o do Curso","text":""},{"location":"#conteudo-do-curso","title":"Conte\u00fado do Curso","text":"<ul> <li>Aula 1 - O Shell</li> <li>Aula 2 - Criando Scripts com Bash</li> <li>Aula 3 - Explorando o Editor de Textos (Visual Studio Code)</li> <li>Aula 4 - Sistema de Controle de Versionamento de C\u00f3digo: Git (em progresso)</li> </ul>"},{"location":"#em-breve","title":"Em breve","text":"<ul> <li>Depura\u00e7\u00e3o e Profiling de Programas</li> <li>T\u00e9cnicas B\u00e1sicas em Engenharia de Software</li> <li>Seguran\u00e7a e Criptografia</li> <li>... e mais a ser definido</li> </ul>"},{"location":"#atribuicoes","title":"Atribui\u00e7\u00f5es","text":"<p>Este curso est\u00e1 sob a licen\u00e7a CC BY-NC-SA (de acordo com o curso original). O curso original no qual este \u00e9 baseado foi elaborado por - Anish Athalye - Jon Gjengset - Jose Javier Gonzalez Ortiz</p> <p>Mais informa\u00e7\u00f5es sobre o curso original podem ser conferidas no Site Oficial.</p>"},{"location":"aulas/01-shell/","title":"Aula 01 - O Shell","text":""},{"location":"aulas/01-shell/#aula-1-o-shell","title":"Aula 1 - O Shell","text":"<p>Nesta primeira aula do nosso curso, apresentaremos o Shell como uma ferramenta prim\u00e1ria de produtividade das pessoas que trabalham em diversas \u00e1reas de TI.</p> <p>Quando navegamos pela internet atrav\u00e9s do uso de um Web Browser, ou usamos algum app ou qualquer aplicativo com uma interface gr\u00e1fica, estamos limitados ao que esta interface suporta. Se existe um bot\u00e3o dispon\u00edvel para uma determinada funcionalidade, a visibilidade deste bot\u00e3o \u00e9 o que determina se podemos nos beneficiar desta dela ou n\u00e3o. Se o bot\u00e3o n\u00e3o est\u00e1 vis\u00edvel, n\u00e3o podemos clicar nele.</p> <p>Uma interface de linha de comando (CLI), como a que temos quando usamos um Shell, torna mais flex\u00edvel o acesso que temos \u00e0s funcionalidades dispon\u00edveis.</p> <p>Saber usar o Shell e navegar por ele potencialmente torna o trabalho cotidiano mais produtivo e, por isto, estamos dando o devido foco em apresent\u00e1-lo neste curso.</p>"},{"location":"aulas/01-shell/#1-o-que-e-o-shell","title":"1. O que \u00e9 o Shell","text":"<p>Quase todas as plataformas com as quais voc\u00ea pode trabalhar atualmente oferecem um Shell, e muitas oferecem diferentes op\u00e7\u00f5es de Shell para voc\u00ea escolher. Apesar de que eles possam variar em seus detalhes, em sua ess\u00eancia s\u00e3o basicamente iguais: eles te permitem executar programas, manipular sua entrada (input) e inspecionar sua sa\u00edda (output) de uma forma semi-estruturada.</p>"},{"location":"aulas/01-shell/#11-shell-vs-terminal","title":"1.1 Shell vs Terminal","text":"<p>Para ter acesso a um Shell, voc\u00ea precisa de um Terminal. Um terminal \u00e9 um programa capaz de receber um comando, encaminhar para o Shell, e exibir seu resultado.</p> <p>O sistema que voc\u00ea usa em seu computador provavelmente possui um terminal dispon\u00edvel. Para os usu\u00e1rios de Windows (a partir do Windows 11), t\u00eam instalado em seu sistema o Windows Terminal. Para usu\u00e1rios de vers\u00f5es anteriores, o Windows Terminal est\u00e1 dispon\u00edvel para download gratuito na Microsoft Store. Outras op\u00e7\u00f5es de terminal para os usu\u00e1rios Windows s\u00e3o o ConEmu e o Cmder.</p> <p>J\u00e1 para os usu\u00e1rios de Linux/MacOS, existem diversas op\u00e7\u00f5es de terminal. Um dos terminais mais famosos para os usu\u00e1rios MacOS \u00e9 o iTerm2. No Linux, entre os terminais mais usados est\u00e3o o Terminator e o Guake.</p> <p>Escolher entre as diferentes op\u00e7\u00f5es de terminais normalmente depende das funcionalidades e conveni\u00eancias que cada op\u00e7\u00e3o oferece. Pain\u00e9is (tiles), Guias(tabs), Teclas de Atalho, Esquemas de Cores, e outras facilidades podem diferenciar as op\u00e7\u00f5es de terminais, mas de uma forma ou de outra, a maioria dos terminais dispon\u00edveis oferecem estas e outras funcionalides com algumas diferen\u00e7as sutis de como elas funcionam.</p>"},{"location":"aulas/01-shell/#12-diferentes-shells","title":"1.2 Diferentes Shells","text":"<p>Al\u00e9m dos diferentes sabores de terminais, existem tamb\u00e9m diferentes op\u00e7\u00f5es de Shells. Cada Shell pode apresentar uma sintaxe diferente de comandos e da forma como voc\u00ea interage atrav\u00e9s do terminal, apesar de haver muitas semelhan\u00e7as entre as principais op\u00e7\u00f5es.</p> <p>Para os usu\u00e1rios Windows, as duas principais op\u00e7\u00f5es de Shell dispon\u00edveis s\u00e3o:</p> <ul> <li>cmd</li> </ul> <p>O cmd \u00e9 o shell nativo do Windows, baseado no Prompt de Comando do antigo MS-DOS (sistema operacional da Microsoft anterior ao Windows). Ele suporta basicamente os comandos b\u00e1sicos do MS-DOS para navegar e manipular o sistema de arquivos.</p> <ul> <li>Windows PowerShell</li> </ul> <p>O PowerShell \u00e9 um Shell moderno criado pela Microsoft, como uma alternativa mais poderosa que o cmd para os usu\u00e1rios Windows.</p> <p>No mundo Linux e MacOS, existem op\u00e7\u00f5es similares de Shell, dentre elas as mais comuns s\u00e3o:</p> <ul> <li>Bash</li> </ul> <p>O Bash (Bourne Again Shell) \u00e9 uma op\u00e7\u00e3o de Shell dispon\u00edvel para Linux e MacOS baseado no Bourne Shell, que \u00e9 um Shell popular para o sistema Unix.</p> <ul> <li>Zsh</li> </ul> <p>O Zsh (z-shell) \u00e9 uma alternativa ao Bash que apresenta funcionalidades comuns, e acrescenta outras funcionalidades baseadas em outras famosas op\u00e7\u00f5es de Shell do sistema Unix (como o ksh e o tcsh), al\u00e9m de trazer funcionalidades \u00fanicas.</p>"},{"location":"aulas/01-shell/#2-bash-bourne-again-shell","title":"2. Bash (Bourne Again SHell)","text":"<p>Bash \u00e9 o shell mais popular atualmente, sendo a op\u00e7\u00e3o pr\u00e9-instalada no Ubuntu, que \u00e9 a distribui\u00e7\u00e3o do Linux mais baixada, al\u00e9m \u00e9 claro de fazer parte de outras distribui\u00e7\u00f5es tamb\u00e9m. Por causa da sua relev\u00e2ncia, toda a discuss\u00e3o relacioana a Shells ao longo deste curso, quando n\u00e3o abordada de uma forma generalista, usar\u00e1 como premissa o uso do bash.</p> <p>Para acompanhar o conte\u00fado deste curso, certifique-se de ter instalado o bash como uma das op\u00e7\u00f5es de Shell dispon\u00edveis no seus sistema. Usu\u00e1rios Linux e MacOS provavelmente j\u00e1 possuir\u00e3o o bash instalado, caso contr\u00e1rio, provavelmente encontrar\u00e3o uma f\u00e1cil instala\u00e7\u00e3o a partir de algum dos gerenciadores de pacote que seus sistemas disponibilizam.</p>"},{"location":"aulas/01-shell/#21-bash-para-usuarios-windows","title":"2.1 Bash para Usu\u00e1rios Windows","text":"<p>Para aqueles que acompanham este curso e s\u00e3o usu\u00e1rios do Microsoft Windows, existem op\u00e7\u00f5es de instala\u00e7\u00e3o do Bash. Vamos apresentar 3 delas para que voc\u00ea escolher a que melhor lhe for mais conveniente.</p> <ul> <li>MinGW64 / Cygwin</li> </ul> <p>Das op\u00e7\u00f5es dispon\u00edveis para se instalar o Bash no Windows, o MinGW64 e o Cygwin se diferenciam por n\u00e3o precisar virtualizar um outro sistema (como Linux). Ambos os projetos podem ser instalados em qualquer vers\u00e3o do Windows e fornecem um conjunto de ferramentas para criar um ambiente compat\u00edvel com um sistema semelhante ao Unix para pessoas que preferem trabalhar usando o Windows.</p> <p>O Bash disponibilizado por estas ferramentas, n\u00e3o \u00e9 totalmente compat\u00edvel com o Bash que voc\u00ea usaria ao criar uma instala\u00e7\u00e3o do Ubuntu, por exemplo, mas pode ser o suficiente para quem prefere n\u00e3o virtualizar (ou n\u00e3o pode).</p> <p>Para instalar o MinGW64, acesse o site: https://www.mingw-w64.org/downloads/</p> <p>Tip</p> <p>Se voc\u00ea instalar o Git para Windows (haver\u00e3o aulas neste curso que usar\u00e3o o Git), ele inclui o MinGW64 para disponibilizar um shell chamado Git Bash.</p> <p>Se voc\u00ea preferir instalar o Cygwin, o endere\u00e7o no site para baixar o instalador \u00e9: https://cygwin.com/install.html</p> <ul> <li>Criar um Memory Stick Inicializ\u00e1vel com uma distribui\u00e7\u00e3o do Linux</li> </ul> <p>\u00c9 poss\u00edvel ter uma distribui\u00e7\u00e3o do Linux dispon\u00edvel para uso sem precisar instal\u00e1-la no seu sistema, usando um Memory Stick (vulgo: Pen Drive) inicializ\u00e1vel.</p> <p>Existem diversos tutoriais na dispon\u00edveis na internet explicando com realizar o processo. Mas, resumidamente, voc\u00ea precisa baixar a imagem do sistema operacional (por exemplo, Ubuntu), e um programa capaz de configurar um Memory Stick com a imagem de forma inicializ\u00e1vel.</p> <p>Info</p> <p>Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows.</p> <ul> <li>Dual Boot com Linux</li> </ul> <p>Voc\u00ea pode criar uma instala\u00e7\u00e3o do Linux lado a lado com a instala\u00e7\u00e3o do Windows e ter a op\u00e7\u00e3o no seu dispositivo de qual dos sistemas voc\u00ea pretende usar no momento da inicializa\u00e7\u00e3o.</p> <p>Info</p> <p>Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows.</p> <p>Warning</p> <p>Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) se tornem exclusivos para o novo sistema, tornando-os indispon\u00edveis para o Windows. Isto requer algum planejamento sobre como estes recursos ser\u00e3o distribu\u00eddos.</p> <ul> <li>Virtualiza\u00e7\u00e3o de Linux</li> </ul> <p>Criar uma M\u00e1quina Virtual (VM) com uma instala\u00e7\u00e3o do Linux \u00e9 uma op\u00e7\u00e3o acess\u00edvel e, certamente, mais conveniente que a op\u00e7\u00e3o com Dual Boot. Uma VM \u00e9, basicamente, um computador virtual, com as mesmas funcionalidades que um dispositivo oferece, por\u00e9m, emulado a partir de um Sistema Hospedeiro (no caso, o Windows).</p> <p>Voc\u00ea pode criar VMs usando softwares gratuitos como o HyperV do Windows ou  VirtualBox da Oracle, e baixar uma imagem da distribui\u00e7\u00e3o Linux desejada (por exemplo, Ubuntu), para criar uma VM. Independente de qual plataforma voc\u00ea pretende usar, voc\u00ea vai precisar ativar o Hypervisor do Windows (que \u00e9 parte integrante da instala\u00e7\u00e3o do HyperV). Para isto, no menu iniciar (pressionando a tecla Windows no teclado), digite \"Ativar ou Desativar Recursos do Windows\", e ao abrir a janela dos Recursos do Windows, procure na lista o \u00edtem \"Hyper-V\" e certifique-se de que ele esteja selecionado. Ativar este recurso, ir\u00e1 exigir que voc\u00ea reinicialize seu computador.</p> <p>Warning</p> <p>Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) sejam compartilhados com a VM, podendo ter um impacto na performance do sistema hospedeiro.</p> <ul> <li>Windows Subsystem for Linux (WSL)</li> </ul> <p>Para usu\u00e1rios de vers\u00f5es mais recentes do Windows (a partir do Windows 10), \u00e9 poss\u00edvel virtualizar uma distribui\u00e7\u00e3o Linux usando um Kernel dispon\u00edvel pelo pr\u00f3prios Windows. Este \u00e9, inclusive, o m\u00e9todo que eu estou usando. \u00c9 um m\u00e9todo melhor do que criar uma VM, pois o WSL suporta uma integra\u00e7\u00e3o transparente entre os sistemas (compartilhando portas e programas).</p> <p>Este m\u00e9todo tamb\u00e9m exige que voc\u00ea ative o HyperV, al\u00e9m de ativar tamb\u00e9m o \"Subsistema do Windows para Linux\", e instalar a distribui\u00e7\u00e3o escolhida (por exemplo, Ubuntu), a partir das op\u00e7\u00f5es dispon\u00edveis na Microsoft Store.</p>"},{"location":"aulas/01-shell/#22-apresentando-o-ambiente-de-shell-com-bash","title":"2.2 Apresentando o ambiente de Shell com Bash","text":"<p>Ao abrir o terminal de sua escolha para acessar um Shell, invariavelmente voc\u00ea ir\u00e1 encontrar algo muito parecido com a imagem a seguir.</p> <p></p> <p>Uma janela vazia (normalmente com fundo escuro), mostrando no topo um texto com algumas informa\u00e7\u00f5es \u00faties e um cursor piscando, esperando que voc\u00ea digite algo.</p> <p>As informa\u00e7\u00f5es exibidas podem variar de um computador para o outro j\u00e1 que elas se baseiam nas configura\u00e7\u00f5es do usu\u00e1rio. No caso do meu shell, exibido acima, as informa\u00e7\u00f5es exibidas s\u00e3o:</p> <p>Info</p> <p><code>dmyoko@CodandoComOTio:~/projects/coisas-que-nao-ensinam-em-ti$</code> - Nome do usu\u00e1rio logado na sess\u00e3o - O <code>@</code> (arroba) separa o nome do usu\u00e1rio do nome do servidor da sess\u00e3o - O nome do servidor da sess\u00e3o - Os dois pontos (<code>:</code>) separam os dados da sess\u00e3o do caminho do diret\u00f3rio atual onde &gt;o shell ir\u00e1 aplicar os comandos     - No Bash, o caractere que separa os segmentos do caminho \u00e9 <code>/</code>, diferente do &gt;Windows que usa <code>\\</code> (barra invertida) - O cifr\u00e3o (<code>$</code>) no final, indica que o shell n\u00e3o est\u00e1 no modo super user.</p> <p>O nome desta linha, contendo estas ou quaisquer outras informa\u00e7\u00f5es de acordo com a configura\u00e7\u00e3o do shell, e o cursor esperando a entrada de um comando, \u00e9 <code>Prompt</code>.</p> <p>A partir daqui, qualquer texto digitado ser\u00e1 interpretado como um comando dado ao shell. Este comando pode servir para executar programas, rodar scripts ou executar comandos nativos do pr\u00f3prio shell.</p> <p>A partir do momento em que algo \u00e9 digitado e enviado para o shell (normalmente atrav\u00e9s do pressionamento da tecla Enter ou Return), o shell executa a linha digitada e o terminal imprime qualquer que seja o resultado (output) da execu\u00e7\u00e3o.</p> <p>Por exmeplo, uma instru\u00e7\u00e3o simples como <code>pwd</code> (que imprime o diret\u00f3rio atual do shell), pode demonstrar este fluxo. Ao inserir esta instru\u00e7\u00e3o e pressionar Enter (ou Return), o diret\u00f3rio \u00e9 exibido na linha abaixo da linha onde o comando foi dado, e na linha seguinte, um novo <code>prompt</code> \u00e9 exibido.</p> <p>O modo como trabalhamos no ambiente de Shell \u00e9 um ciclo: - Um prompt \u00e9 exibido indicando que o shell est\u00e1 pronto para receber comandos atrav\u00e9s do terminal - Um comando \u00e9 digitado no terminal e enviado ao shell - O shell interpreta o comando enviado e o executa - Qualquer resultado direcionado para a sa\u00edda (<code>output</code>) do shell \u00e9 exibido pelo terminal</p> <p>Com isto, podemos agora explorar um pouco alguns comandos que o Bash nos fornece.</p>"},{"location":"aulas/01-shell/#23-navegando-com-o-shell","title":"2.3 Navegando com o Shell","text":"<p>Vamos come\u00e7ar a explorar os comandos do Bash, aprendendo primeiro a navegar pelo sistema de arquivos.</p> <ul> <li>Exibindo o diret\u00f3rio atual: <code>pwd</code></li> </ul> <p>Como vimos agora h\u00e1 poudo, o comando <code>pwd</code> (Print Working Directory), imprime no terminal o caminho do diret\u00f3rio atual onde o Shell ir\u00e1 executar o pr\u00f3ximo comando. Saber qual \u00e9 o diret\u00f3rio atual \u00e9 importante, por que isto pode afetar diretamente o resultado do pr\u00f3ximo comando.</p> <p>Por exemplo, se o pr\u00f3ximo comando resultar na cria\u00e7\u00e3o de um arquivo, o arquivo ser\u00e1 criado no diret\u00f3rio atual, exceto se algum par\u00e2metro espec\u00edfico seja usado para mudar este comportamento (salvo, \u00e9 claro, se o programa executado tiver instru\u00e7\u00f5es espec\u00edficas do caminho do arquivo).</p> <ul> <li>Mudando o diret\u00f3rio atual: <code>cd</code></li> </ul> <p>Para mudar o diret\u00f3rio atual da sess\u00e3o do Shell, o comando usado \u00e9 o <code>cd</code> (Change Directory). Se voc\u00ea digitar apenas <code>cd</code> e pressionar Enter, ele vai mudar o diret\u00f3rio atual para <code>~</code> (falaremos logo a seguir sobre que diret\u00f3rio \u00e9 este). Ele n\u00e3o imprime nenhuma sa\u00edda, e imediatamente um novo prompt \u00e9 apresentado. Para informar o comando <code>cd</code> para que ele mude para um diret\u00f3rio diferente, um <code>argumento</code> precisa ser usado.</p> <p>Note</p> <p>Argumentos: s\u00e3o complementos que damos aos comandos, normalmente digitando-os a seguir do comando propriamente dito. Por exemplo, no comando <code>cd teste</code>, <code>teste</code> \u00e9 o argumento passado para o comando <code>cd</code>. Neste caso, o comando <code>cd</code> vai mudar mudar o diret\u00f3rio atual para o diret\u00f3rio <code>teste</code>.</p> <pre><code>cd teste\n</code></pre> <p>No meu caso, uma mensagem de erro \u00e9 exibida:</p> <pre><code>bash: cd: teste: No such file or directory\n</code></pre> <p>Ela diz que n\u00e3o existe um arquivo ou diret\u00f3rio chamado <code>teste</code>. Note, executando o comando <code>pwd</code> novamente, que o diret\u00f3rio atual permanece o mesmo.</p> <p>Para mudar o diret\u00f3rio atual, precisamos passar como argumento, o endere\u00e7o de um diret\u00f3rio existente. Por exemplo, um diret\u00f3rio que com certeza existe no sistema de arquivos \u00e9 o diret\u00f3rio raiz, que fica no endere\u00e7o <code>/</code>.</p> <pre><code>cd /\n</code></pre> <p>No meu caso, como voc\u00ea pode ver, o meu prompt mudou, agora dizendo que o diret\u00f3rio atual \u00e9 <code>/</code> (o diret\u00f3rio raiz). Se o seu prompt n\u00e3o exibe esta informa\u00e7\u00e3o como o meu, voc\u00ea pode confirmar usando o comando <code>pwd</code>.</p> <p>Outro diret\u00f3rio comum para quem usa o Bash, \u00e9 o diret\u00f3rio Home, representado pelo caractere <code>~</code>. Voc\u00ea pode testar o comando:</p> <pre><code>cd ~\n</code></pre> <p>Como pode ver, no meu prompt, agora ele exibe <code>~</code> como diret\u00f3rio atual, e n\u00e3o mais o diret\u00f3rio raiz (<code>/</code>).</p> <p>Ao contr\u00e1rio do diret\u00f3rio raiz, se voc\u00ea usar o comando <code>pwd</code> agora voc\u00ea vai notar que o diret\u00f3rio Home (<code>~</code>), na verdade, aponta para um diret\u00f3rio espec\u00edfico a partir da raiz. No meu caso, <code>/home/dmyoko</code> (no seu caso, vai apontar para um diret\u00f3rio com o nome do seu usu\u00e1rio dentro do diret\u00f3rio <code>/home</code>).</p> <p>Voc\u00ea pode navegar manualmente por estes diret\u00f3rios, usando o caminho que os leva at\u00e9 eles. Por exemplo:</p> <pre><code>cd /\ncd home\ncd dmyoko\n</code></pre> <p>Uma vez no diret\u00f3rio <code>/</code> (raiz), voc\u00ea tem acesso ao diret\u00f3rio <code>home</code>, e uma vez que voc\u00ea entra no diret\u00f3rio <code>home</code>, voc\u00ea tem acesso ao diret\u00f3rio do seu usu\u00e1rio, no meu caso <code>dmyoko</code>.</p> <p>Voc\u00ea tamb\u00e9m pode navegar direto para o diret\u00f3rio espec\u00edfico, usando o caminho completo absoluto que leva at\u00e9 ele, come\u00e7ando pelo diret\u00f3rio raiz.</p> <pre><code>cd /\ncd /home/dmyoko\n</code></pre> <p>Note</p> <p>Caminho absoluto \u00e9 o caminho completo que leva at\u00e9 um diret\u00f3rio ou arquivo no sistema de arquivos. Ele sempre come\u00e7a pelo diret\u00f3rio <code>/</code> (raiz), e segue toda a hierarquia de segmentos necess\u00e1rios at\u00e9 chegar no diret\u00f3rio ou arquivo desejado.</p> <ul> <li>Listar informa\u00e7\u00f5es sobre o conte\u00fado de um diret\u00f3rio: <code>ls</code></li> </ul> <p>O comando <code>ls</code> \u00e9 \u00fatil quando voc\u00ea deseja entender o conte\u00fado de um determinado diret\u00f3rio. Se voc\u00ea digitar somente <code>ls</code>, o Bash imprimir\u00e1 no terminal o conte\u00fado do diret\u00f3rio atual.</p> <p>Se voc\u00ea quiser listar o conte\u00fado de outro diret\u00f3rio sem necessariamente sair do diret\u00f3rio atual, basta usar como argumento o caminho para o diret\u00f3rio do qual voc\u00ea pretende listar o conte\u00fado desejado.</p> <pre><code>ls /\n</code></pre> <p>O comando acima, lista o conte\u00fado do diret\u00f3rio <code>/</code> (raiz). Voc\u00ea pode tamb\u00e9m listar o conte\u00fado de um dos subdiret\u00f3rios do diret\u00f3rio raiz, informando o endere\u00e7o dele. Por exemplo:</p> <pre><code>ls /bin\nls /lib\nls /sys/devices/cpu\n</code></pre> <p>O comando <code>ls</code> tamb\u00e9m suporta op\u00e7\u00f5es, que podem influenciar no resultado do comando. Por exemplo, a op\u00e7\u00e3o <code>-l</code> exibe o resultado do comando <code>ls</code> no formato de lista, trazendo informa\u00e7\u00f5es adicionais a respeito do conte\u00fado do diret\u00f3rio, que antes n\u00e3o estavam sendo exibidas, como as permiss\u00f5es de acesso ao diret\u00f3rio/arquivo listado, informa\u00e7\u00f5es de quem \u00e9 o usu\u00e1rio dono deste diret\u00f3rio/arquivo e a que grupo ele pertence (usu\u00e1rio <code>dmyoko</code> do grupo <code>dmyoko</code>, por exemplo), o tamanho do arquivo/diret\u00f3rio em bytes, e a data da \u00faltima vez que o arquivo/diret\u00f3rio foi modificado.</p> <pre><code>ls -l\n</code></pre> <p>Outra op\u00e7\u00f5a \u00fatil \u00e9 o <code>-h</code>, que faz com que os tamanhos dos arquivos exibidos sejam impressos num formato humanamente leg\u00edvel (human readable).</p> <pre><code>ls -h # sem efeito, pois os tamanhos n\u00e3o s\u00e3o exibidos\nls -l -h # agora \u00e9 poss\u00edvel ver o efeito.\nls -lh # \u00e9 poss\u00edvel unir todas as op\u00e7\u00f5es em uma \u00fanica cl\u00e1usula\n</code></pre> <p>Existem outras diversas op\u00e7\u00f5es dispon\u00edveis para o comando <code>ls</code>. Para ter acesso a uma lista completa delas, voc\u00ea pode digitar <code>ls --help</code>.</p> <p>Tip</p> <p><code>--help</code> \u00e9 uma op\u00e7\u00e3o dispon\u00edvel na vasta maioria dos comandos que voc\u00ea pode executar no shell. E, invariavelmente, imprime informa\u00e7\u00f5es sobre o que o comando faz e como utiliz\u00e1-lo, inclusive, mostrando poss\u00edveis op\u00e7\u00f5es que afetam a forma como este comando se comporta.</p>"},{"location":"aulas/01-shell/#24-permissoes-de-arquivos-e-diretorios","title":"2.4 Permiss\u00f5es de arquivos e diret\u00f3rios","text":"<p>Eu mencionei que a primeira coluna exibida como resultado do <code>ls -l</code> s\u00e3o as permiss\u00f5es dos arquivos ou diret\u00f3rios listados. Estas permiss\u00f5es indicam quem pode fazer o que com estes artefatos. Para dar uma breve  explica\u00e7\u00e3o, vamos entender como estas informa\u00e7\u00f5es s\u00e3o exibidas:</p> <p>Cada caractere exibido nesta coluna representa um atributo do artefato ao qual ele est\u00e1 ligado. O primeiro caractere, por exemplo, indica que tipo de artefato \u00e9 o item da lista. Um simples <code>-</code> indica que ele \u00e9 apenas um arquivo, e um <code>d</code> indica que ele \u00e9 um diret\u00f3rio. Existem outros tipos, que podemos discutir no futuro.</p> <p>Os demais caracteres s\u00e3o agrupamentos de 3 caracteres, cada caractere simbolizando uma permiss\u00e3o espec\u00edfica: <code>rwx</code>. - <code>r</code>: representa a permiss\u00e3o para leitura - <code>w</code>: representa a permiss\u00e3o para escrita - <code>x</code>: representa a permiss\u00e3o para execu\u00e7\u00e3o</p> <p>Os 3 caracteres est\u00e3o sempre nesta ordem, e podem ser substitu\u00eddos por um <code>-</code>, indicando que a devida opera\u00e7\u00e3o n\u00e3o \u00e9 permitida.</p> <p>Por exemplo: <code>rwx</code>: Todas as opera\u00e7\u00f5es s\u00e3o permitidas <code>rw-</code>: \u00c9 permitido ler e alterar o arquivo, mas n\u00e3o \u00e9 permitido execut\u00e1-lo <code>r--</code>: S\u00f3 se tem acesso para ler o conte\u00fado do arquivo, mas n\u00e3o \u00e9 permitido alter\u00e1-lo.</p> <p>Estas permiss\u00f5es s\u00e3o exibidas na seguinte ordem: - Permiss\u00f5es para o dono do arquivo - Permiss\u00f5es para os demais usu\u00e1rios do grupo dono do arquivo - Permiss\u00f5es para todos os demais usu\u00e1rios</p> <p>Por exemplo (retirado do screenshot acima): <code>drwxr-xr-x  2 root root  4096 Mar 25  2022 X11</code> Esta linha diz que <code>X11</code> \u00e9 um diret\u00f3rio (<code>d</code>), o dono (que \u00e9 o usu\u00e1rio <code>root</code>) possui permiss\u00e3o de leitura, escrita e execu\u00e7\u00e3o, enquanto que os outros membros do grupo <code>root</code> podem apenas ler o conte\u00fado e execut\u00e1-lo, bem como todos os outros usu\u00e1rios.</p> <p>Important</p> <p>Em um diret\u00f3rio, a permiss\u00e3o de execu\u00e7\u00e3o significa que o usu\u00e1rio \u00e9 capaz de navegar por ele (atrav\u00e9s do comando <code>cd</code>). A permiss\u00e3o de leitura significa que o usu\u00e1rio \u00e9 capaz de listar o conte\u00fado (atrav\u00e9s do comando <code>ls</code>) ou procurar por arquivos, etc. E a permiss\u00e3o de escrita significa que o usu\u00e1rio \u00e9 capaz de criar novos artefatos (arquivos, diret\u00f3rios, etc) dentro do diret\u00f3rio.</p>"},{"location":"aulas/01-shell/#25-manipulacao-do-sistema-de-arquivos","title":"2.5 Manipula\u00e7\u00e3o do sistema de arquivos","text":"<p>Agora que sabemos como navegar e obter informa\u00e7\u00f5es sobre o conte\u00fado do sistema de arquivos, vamos aprender como manipular o conte\u00fado dos diret\u00f3rios, criando, modificando e excluindo arquivos e diret\u00f3rios usando comandos do Shell.</p> <ul> <li>Criando diret\u00f3rios: <code>mkdir</code></li> </ul> <p>Para criar novos diret\u00f3rios, usamos o comando <code>mkdir</code> passando como argumento o nome  do diret\u00f3rio que queremos criar.</p> <pre><code>cd ~ #Certifique-se de estar no seu diret\u00f3rio `home`\nmkdir teste\n</code></pre> <p>O diret\u00f3rio <code>teste</code> ser\u00e1 criado no diret\u00f3rio atual, no caso, o diret\u00f3rio <code>home</code>. Voc\u00ea tamb\u00e9m pode criar um diret\u00f3rio em um lugar diferente do diret\u00f3rio atual, usando o endere\u00e7o completo desejado.</p> <pre><code>mkdir /home/dmyoko/teste/tmp\n</code></pre> <p>Warning</p> <p>Espa\u00e7os importam! Tome cuidado com o uso de espa\u00e7os quando estiver executando opera\u00e7\u00f5es no shell. Por exemplo, se voc\u00ea digitar o comando <code>mkdir minhas fotos</code>, ao inv\u00e9s de criar um diret\u00f3rio chamado <code>minhas fotos</code>, ele ir\u00e1 criar dois diret\u00f3rios, um chamado <code>minhas</code> e um segundo chamado <code>fotos</code>. Para usar espa\u00e7os voc\u00ea pode usar caracteres de escape. </p> <p>Para usar caracteres de escape, voc\u00ea usa a <code>\\</code> (barra invertida). Por exemplo: </p><pre><code>mkdir Minhas\\ Fotos # Cria um diret\u00f3rio chamado `Minhas Fotos`\n</code></pre> <p>Voc\u00ea pode, tamb\u00e9m, delimitar o nome usando aspas (<code>\"</code>) ou ap\u00f3strofos (<code>'</code>), como uma forma de indicar o nome sem usar caracteres de escape.</p> <p>O comando <code>mkdir</code> possui uma op\u00e7\u00e3o <code>-p</code> que permite que voc\u00ea crie um caminho completo de diret\u00f3rios:</p> <pre><code>mkdir -p /home/dmyoko/teste/a/b/c\n</code></pre> <p>Note que ele sabe lidar com o fato de que parte do caminho j\u00e1 existe (o diret\u00f3rio <code>/home/dmyoko/teste/</code>), e cria apenas os segmentos que n\u00e3o existem.</p> <p>Uma outra conveni\u00eancia desta op\u00e7\u00e3o \u00e9 que ela n\u00e3o resulta em erro, caso voc\u00ea tente criar um diret\u00f3rio que j\u00e1 existe, mesmo que seja o caminho completo. Isto \u00e9 \u00fatil, principalmente para automa\u00e7\u00f5es.</p> <pre><code>mkdir /home/dmyoko/teste/a/b/c #Resulta em erro\nmkdir -p /home/dmyoko/teste/a/b/c \n</code></pre> <ul> <li>Manipulando hora de acesso e modifica\u00e7\u00e3o de arquivos: <code>touch</code></li> </ul> <p>O comando touch for\u00e7a uma altera\u00e7\u00e3o na data de modifica\u00e7\u00e3o de arquivos.</p> <p>Para entender o que isto significa, vamos rever o resultado do comando <code>ls</code> no screenshot anterior: </p> <p>Observe a coluna imediatamente \u00e0 esquerda do nome do arquivo nesta lista, \u00e9 uma informa\u00e7\u00e3o de Data/Hora. Esta coluna indica a data/hora da \u00faltima modifica\u00e7\u00e3o que este arquivo teve. Ao usar o comando <code>touch</code>, voc\u00ea for\u00e7a uma atualiza\u00e7\u00e3o desta informa\u00e7\u00e3o para a data/hora atual do sistema.</p> <p>Apesar disso parecer algo usado para um prop\u00f3sito muito espec\u00edfico, o comando <code>touch</code> \u00e9 \u00fatil por que, ao ser usado para fazer isto em um arquivo inexistente, ele cria o arquivo. Por exemplo:</p> <pre><code>touch teste.txt\n</code></pre> <p>Se o arquivo teste.txt n\u00e3o existir, ele ser\u00e1 criado. Caso ele exista, somente a data/hora da \u00faltima modifica\u00e7\u00e3o ser\u00e3o afetados. Isto \u00e9 \u00fatil quando trabalhamos com scripts de automa\u00e7\u00e3o, pois garante a exist\u00eancia do arquivo sem incorrer num erro ao tentar cri\u00e1-lo novamente ou substitu\u00ed-lo acidentalmente.</p> <ul> <li>Copiando arquivos com <code>cp</code></li> </ul> <p>O comando <code>cp</code> \u00e9 usado para copiar arquivos. Ele funciona com dois argumentos: - O primeiro argumento \u00e9 o caminho do arquivo de origem, que se deseja copiar - O segudno argumento \u00e9 o caminho do arquivo de destino, para onde se deseja copiar o arquivo de origem</p> <p>Por exemplo:</p> <pre><code>cp teste.txt teste2.txt\ncp /home/dmyoko/teste /home/dmyoko/teste2 #Funciona com diret\u00f3rios\n</code></pre> <ul> <li>Movendo arquivos com <code>mv</code></li> </ul> <p>Por outro lado, se a inten\u00e7\u00e3o \u00e9 apenas mover arquivos entre caminhos, em vez criar uma c\u00f3pia (fazendo com que o arquivo deixe de existir no caminho de origem), o comando <code>mv</code> pode ser usado de forma semelhante ao <code>cp</code>, passando os mesmos argumentos.</p> <pre><code>mv teste2.txt teste3.txt #Funciona como se o arquivo fosse renomeado\nmv teste3.txt /home/dmyoko/teste2\nmv /home/dmyoko/teste2 /home/dmyoko/teste3\n</code></pre> <ul> <li>Removendo arquivos com <code>rm</code></li> </ul> <p>Para remover arquivos, usamos o comando <code>rm</code>. Ao contr\u00e1rio dos comandos anteriores <code>cp</code> e <code>mv</code>, o comando <code>rm</code> n\u00e3o afeta diret\u00f3rios por padr\u00e3o. Sendo usado especificamente para arquivos.</p> <p>Por exemplo: </p><pre><code>rm /home/dmyoko/teste/teste3.txt\n</code></pre> <p>Para remover diret\u00f3rios, existe o usando o comando <code>rmdir</code>, mas ele funciona apenas com diret\u00f3rios vazios. Se houve qualquer arquivo dentro do diret\u00f3rio, ele se recusa a exclu\u00ed-lo. Por exemplo:</p> <pre><code>rmdir /home/dmyoko/teste\n</code></pre> <p>Gera esta mensagem de erro: </p><pre><code>rmdir: failed to remove 'teste': Directory not empty\n</code></pre> <p>Para remover um diret\u00f3rio n\u00e3o vazio (excluindo seu conte\u00fado em consequ\u00eancia), o comando <code>rm</code> disponibiliza op\u00e7\u00f5es que permitem fazer isto. O motivo de exigir o uso destas op\u00e7\u00f5es \u00e9 evitar que se exclua arquivos por acidente, for\u00e7ando o usu\u00e1rio a fazer o uso deliberado delas para se certificar do que est\u00e1 fazendo.</p> <pre><code>rm -r /home/dmyoko/teste\n</code></pre>"},{"location":"aulas/01-shell/#26-caminho-absoluto-caminho-relativo-e-caracteres-coringa","title":"2.6 Caminho Absoluto, Caminho Relativo e Caracteres Coringa","text":"<p>At\u00e9 aqui, temos usado o que chamamos de Caminho Absoluto (Absolute Path) para endere\u00e7ar os arquivos e diret\u00f3rios que usamos. Mas existem atalhos especiais que nos ajudam a facilitar a descri\u00e7\u00e3o de caminhos baseados no diret\u00f3rio atual em que nos localizamos.</p> <p>Uma das op\u00e7\u00f5es dispon\u00edveis no comando <code>ls</code> \u00e9 a op\u00e7\u00e3o <code>-a</code> ou <code>--all</code>, que deixam de ignorar certos arquivos que normalmente n\u00e3o s\u00e3o exibidos. Por padr\u00e3o, os arquivos que come\u00e7am com <code>.</code> (ponto), ficam ocultos normalmente no comando <code>ls</code>. Vamos ver quais arquivos visualizamos ao usar esta op\u00e7\u00e3o:</p> <pre><code>ls -lha\n</code></pre> <p>Dentre os novos arquivos que antes n\u00e3o eram exibidos, existem dois diret\u00f3rios especiais: <code>.</code> e <code>..</code>.</p> <p>Estes diret\u00f3rios s\u00e3o usados para nos referirmos a Caminhos Relativos (Relative Paths). O diret\u00f3rio <code>.</code>, aponta para o diret\u00f3rio atual, onde a sess\u00e3o do bash est\u00e1 localizada (o diret\u00f3rio onde voc\u00ea se encontra e que ser\u00e1 exibido com o comando <code>pwd</code>).</p> <p>J\u00e1 o diret\u00f3rio <code>..</code>, aponta para o diret\u00f3rio pai do diret\u00f3rio atual, imediatamente superior na hierarquia de diret\u00f3rios, o diret\u00f3rio que antecede o diret\u00f3rio atual na sa\u00edda do comando <code>pwd</code>.</p> <p>Ambos estes diret\u00f3rios podem ser usados como atalho para execu\u00e7\u00e3o de comandos, como os comandos que usamos at\u00e9 aqui:</p> <pre><code># Criando alguns elementos para demonstrar caminhos relativos\ncd ~ \nmkdir -p teste/a/b/c\ncd teste/a/b\ntouch c/teste.txt\n\ncp c/teste.txt .. # copia o arquivo dentro do diret\u00f3rio c para ~/teste/a\nmv c/teste.txt . # move o arquivo dentro do diret\u00f3rio c para ~/teste/a/b\nrm ../teste.txt # exclui o arquivo teste.txt do diret\u00f3rio ~/teste/a\ncp teste.txt ../.. #copia o arquivo teste.txt do diret\u00f3rio atual para ~/teste\nls -lha ../.. # lista os arquivos do diret\u00f3rio ~/teste\n</code></pre> <p>Outro atalho \u00fatil para comandos usando o bash (e outros shells tamb\u00e9m costumam suportar), s\u00e3o Caracteres Coringa (Wild Cards), usados para selecionar arquivos que correspondem com a alguns padr\u00f5es em seus nomes. Para demonstrar isto, vamos antes criar alguns arquivos: </p><pre><code>cd ~/teste\ntouch foo foo1 foo2 foo10 bar\n</code></pre> <p>Existem dois caracteres coringas: <code>?</code> e <code>*</code>. - o <code>?</code> serve como uma forma de se referir a qualquer caractere que esteja em uma determinada posi\u00e7\u00e3o no nome do arquivo. Por exemplo: </p><pre><code>ls foo? # Lista todos os arquivos cujo nome come\u00e7am com `foo` e que possuem qualquer outro caractere \u00fanico em seguida\n</code></pre> <p>Note que, como resultado deste comando, os arquivos <code>foo1</code> e <code>foo2</code> foram os \u00fanicos exibidos. Os demais arquivos foram ignorados por n\u00e3o combinarem com o padr\u00e3o, pois <code>foo</code> n\u00e3o possui nenhum caractere na posi\u00e7\u00e3o onde o <code>?</code> se encontra, e <code>foo10</code> possui ainda um caractere a mais (j\u00e1 o arquivo <code>bar</code> n\u00e3o corresponde em absolutamente nada com o padr\u00e3o usado).</p> <ul> <li>o <code>*</code> serve como uma forma de se referir a quaisquer combina\u00e7\u00e3o de zero ou mais caracteres que possam estar em uma determinada posi\u00e7\u00e3o no nome dos arquivos. Por exemplo: <pre><code>ls foo*\n</code></pre></li> </ul> <p>Desta vez, s\u00e3o listados todos os arquivos que come\u00e7am com <code>foo</code>, independente de quantos caracteres a mais eles possuem ou n\u00e3o. O arquivo <code>bar</code>, como antes, \u00e9 ignorado por n\u00e3o corresponder ao padr\u00e3o.</p> <p>Voc\u00ea pode usar os caracteres coringa para designar arquivos e diret\u00f3rios como argumentos para qualquer comando do <code>Bash</code>. Por exemplo: </p><pre><code>rm f?? # apaga somente o arquivo foo\ncp foo* ./a # copia os arquivos foo1, foo2 e foo10 para ./a\nmv foo? ./a/b # move somente os arquivos foo1 e foo2 para ./a/b\ntouch * # Atualiza a data/hora de modifica\u00e7\u00e3o de todos os arquivos para a hora atual do sistema\n</code></pre>"},{"location":"aulas/01-shell/#27-conectando-programas","title":"2.7 Conectando Programas","text":"<p>Uma das capacidades mais incr\u00edveis do <code>Bash</code> \u00e9 a forma como \u00e9 poss\u00edvel manipular a entrada e sa\u00edda dos programas e conect\u00e1-las de diversas formas para redefinir o comportamento padr\u00e3o dos comandos. Me permita explicar melhor antes, como o Shell lida com a entrada e sa\u00edda dos comandos.</p>"},{"location":"aulas/01-shell/#271-streams-de-entrada-e-saida-inputoutput-streams","title":"2.7.1 Streams de Entrada e Sa\u00edda (Input/Output Streams)","text":"<p>No Shell, programas possuem dois streams prim\u00e1rios associados a eles: o stream de entrada (input), e o stream de sa\u00edda (output). Quando o programa tenta ler a entrada, ele l\u00ea do stream de entrada, e quando ele imprime algo, ele imprime no stream de sa\u00edda. Normalmente, os streams de entrada e sa\u00edda de um programa s\u00e3o o seu terminal (quando rodando a partir do shell). Ou seja, seu teclado (\u00e0 medida que voc\u00ea digita no shell) e a janela do terminal na sua tela. Contudo, n\u00f3s podemos tamb\u00e9m religar estes streams de outras formas.</p> <p>Important</p> <p>Streams em computa\u00e7\u00e3o, \u00e9 um termo comum usado para designar um fluxo de dados que n\u00e3o acontece de uma \u00fanica vez, mas que \u00e9 feito de forma cont\u00ednua, ao longo do tempo, em pequenos lotes.</p> <p>Aqui estamos falando de Streams sendo usados para o fluxo cont\u00ednuo de dados de entrada e de sa\u00edda de um comando ou programa executado no shell. Mas o conceito \u00e9 muito comum em diversas outras \u00e1reas da computa\u00e7\u00e3o, como na leitura/escrita de arquivos no disco, ou obtendo/enviando dados atrav\u00e9s da rede/internet.</p> <p>O termo ficou ainda mais popular com a transmiss\u00e3o de conte\u00fado online como chamadas de v\u00eddeo ou transmiss\u00f5es audiovisuais em lives na internet.</p>"},{"location":"aulas/01-shell/#272-religamento-de-streams","title":"2.7.2 Religamento de Streams","text":"<p>A forma mais simples de religar streams no <code>Bash</code> \u00e9 atrav\u00e9s dos operadores <code>&gt;</code> (para religar o stream de sa\u00edda do programa) e <code>&lt;</code> (para religar o stream de entrada do programa). Vamos ver alguns exemplos:</p> <pre><code>ls ~ -lha &gt; ~/teste/ls.txt # Religa o stream de sa\u00edda do comando ls para o arquivo ~/teste/ls.txt\n</code></pre> <p>Note que o comando <code>ls</code> acima n\u00e3o imprimiu a sa\u00edda no terminal como de costume. Por outro lado, voc\u00ea pode conferir um novo arquivo criado no diret\u00f3rio <code>~/teste</code> chamando <code>ls.txt</code>. Voc\u00ea pode usar o comando <code>cat</code> (que imprime o conte\u00fado de um arquivo no terminal) e voc\u00ea ir\u00e1 notar que o seu conte\u00fado \u00e9 a sa\u00edda do comando <code>ls</code> que teria sido impressa no terminal se n\u00e3o a tiv\u00e9ssemos religado.</p> <p>Uma forma de conferir o conte\u00fado do arquivo <code>~/teste/ls.txt</code>, \u00e9 o utilizando como stream de entrada do comando <code>cat</code>, que imprime o stream de entrada no stream de sa\u00edda. Ao religar o stream de entrada do comando <code>cat</code> usando o arquivo <code>~/teste/ls.txt</code> sem religar o stream de sa\u00edda, ele ir\u00e1 imprimir o conte\u00fado no terminal.</p> <pre><code>cat &lt; ~/teste/ls.txt\n</code></pre> <p>O comando <code>cat</code>, quando n\u00e3o especificado nenhum argumento, usa o terminal como stream de entrada (capturando tudo o que o usu\u00e1rio digitar) e as imprime no stream de sa\u00edda (que tamb\u00e9m \u00e9 o pr\u00f3prio terminal, imprimindo exatamente o que \u00e9 digitado), \u00e0 medida que os dados s\u00e3o enviados (normalmente, sempre que uma linha \u00e9 finalizada). O resultado padr\u00e3o do comando <code>cat</code>, \u00e9 ter suas linhas repetidas, uma vindo pela entrada, e logo em seguida sendo impressa na sa\u00edda.</p> <pre><code>cat # demonstrando os dados digitados no stream de entrada, e impressos na sa\u00edda imediatamente depois\n</code></pre> <p>Por exemplo, \u00e9 poss\u00edvel usar o cat como um editor de um novo arquivo, que ser\u00e1 criado usando a religa\u00e7\u00e3o do stream de sa\u00edda, digitando o conte\u00fado a partir do stream de entrada.</p> <pre><code>cat &gt; ~/teste/arquivo.txt # Ao digitar conte\u00fado na entrada, ele ser\u00e1 direcionado para o arquivo.txt\n</code></pre> <p>Note</p> <p>Para encerrar a leitura da entrada, n\u00f3s usamos o comando Ctrl+C. Isto envia um sinal para o processo que est\u00e1 executando o comando <code>cat</code>, orientando-o a parar.</p> <p>Existem outras formas de enviar sinais aos processos quando estamos executando programas no bash, mas veremos isto no futuro.</p> <p>Um outro operador \u00fatil \u00e9 o operador <code>&gt;&gt;</code>. Ele tem, basicamente o mesmo efeito do operador <code>&gt;</code>, que religa o stream de sa\u00edda, com exce\u00e7\u00e3o de que, se a sa\u00edda \u00e9 redirecionada a um arquivo que j\u00e1 existe, ele concatena a sa\u00edda do programa atual ao conte\u00fado original do arquivo, uma opera\u00e7\u00e3o popularmente conhecida na computa\u00e7\u00e3o como <code>append</code>. Ou seja, o conte\u00fado original do arquivo \u00e9 mantido, e o novo conte\u00fado \u00e9 enviado ao final dele.</p> <pre><code>ls -lha ~ &gt;&gt; ~/teste/arquivo.txt\n</code></pre> <p>Note que o conte\u00fado original do <code>arquivo.txt</code> foi mantido, e o resultado do comando <code>ls</code> foi inserido depois da \u00faltima linha original.</p> <p>Existe um operador que conecta a sa\u00edda de um comando do bash \u00e0 entrada de outro comando, criando uma cadeia de comandos, ou \"esteira\" (pipeline), de etapas pelas quais os dados resultantes de um programa s\u00e3o aplicados ao outro, sendo transformados at\u00e9 produzirem uma sa\u00edda desejada. Este operador \u00e9 o <code>|</code> (pipe).</p> <pre><code>ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt\n</code></pre> <p>Aqui temos uma pipeline que faz a seguinte sequ\u00eancia: - <code>ls -lha ~</code> - lista todos os arquivos da pasta <code>home</code>, em formato de lista, com tamanhos humanamente leg\u00edveis, e inclindo os arquivos ocultos (que come\u00e7am com <code>.</code>) - <code>grep Jul</code> - o comando <code>grep</code> filtra as linhas vindas da entrada de acordo com algum padr\u00e3o (no caso, <code>Jul</code>). Basicamente ele pega o resultado do <code>ls</code> e separa somente os arquivos modificados em Julho - <code>head -5</code>- O comando <code>head</code> toma somente as primeiras linhas da entrada. Por padr\u00e3o, ele toma somente as primeiras 10, mas a op\u00e7\u00e3o <code>-5</code> faz com que ele pegue somente as primeiras 5 e ignore as demais linhas. - <code>tee /&lt;caminho&gt;</code> - O comando <code>tee</code> \u00e9 um comando similar ao comando <code>cat</code>, com a diferen\u00e7a que, al\u00e9m de imprimir no stream de sa\u00edda, ele tamb\u00e9m escreve o arquivo. No caso acima, ele escreve no terminal e no arquivo <code>/home/dmyoko/teste/pipeline.txt</code>.     - Por exemplo, \u00e9 poss\u00edvel criar dois arquivos a partir do comando <code>tee</code>:</p> <pre><code>ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt &gt; /home/dmyoko/teste/pipeline2.txt\n</code></pre> <ul> <li>A linha acima instrui instrui o <code>tee</code> a escrever a entrada no arquivo <code>/home/dmyoko/teste/pipeline.txt</code> e religa o stream de sa\u00edda para o arquivo <code>/home/dmyoko/teste/pipeline2.txt</code> usando o operador <code>&gt;</code>.</li> <li>Imagine talvez, usar o operador <code>&gt;&gt;</code> nesta linha, e qual ser\u00e1 o resultado. Como isso iria diferir ambos os arquivos.</li> </ul> <p>N\u00f3s iremos usar muito o operador de pipe (<code>|</code>) na aula em que iremos tratar de Manipula\u00e7\u00e3o de Dados no Shell.</p>"},{"location":"aulas/01-shell/#28-comandos-uteis","title":"2.8 Comandos \u00dateis","text":"<ul> <li> <p><code>man</code> O comando <code>man</code> exibe um manual de diversos comandos do <code>bash</code>. Usa-se passando como argumento o nome do comando que se deseja consultar: </p><pre><code>man mkdir\n</code></pre> </li> <li> <p><code>find</code> O comando <code>find</code> ajuda a localizar arquivos, procurando n\u00e3o somente no diret\u00f3rio usado como argumento, mas automaticamente buscando em todos os seus subdiret\u00f3rios. Se um diret\u00f3rio n\u00e3o for passado como argumento, o comando <code>find</code> usa o diret\u00f3rio atual por padr\u00e3o. Ele aceita diversas op\u00e7\u00f5es para ajudar a encontrar arquivos de acordo com crit\u00e9rios espec\u00edficos, como o nome do arquivo (op\u00e7\u00e3o <code>-name</code> seguido do nome que se busca, para usar coringas \u00e9 necess\u00e1rio delimitar com ap\u00f3strofos), e muitas outras op\u00e7\u00f5es \u00fateis.</p> </li> </ul> <p>Consulte o manual (<code>man find</code>) para ler sobre todas as op\u00e7\u00f5es dispon\u00edveis.</p> <ul> <li> <p><code>date</code> Imprime a data/hora atual do sistema. Existem diversas op\u00e7\u00f5es de formata\u00e7\u00e3o em que a Data/Hora ser\u00e3o impressas, para saber mais consulte as p\u00e1ginas do Manual (<code>man date</code>)</p> </li> <li> <p><code>diff</code> Imprime as diferen\u00e7as entre o conte\u00fado de dois caminhos, que precisam ser especificados via argumentos. Podendo ser ambos diret\u00f3rios ou arquivos, mas n\u00e3o compara se forem de tipos diferentes.</p> </li> <li> <p><code>history</code> Imprime no terminal o hist\u00f3rico de comandos usados nesta sess\u00e3o do <code>Bash</code>.</p> </li> <li> <p><code>tail</code> O comando <code>tail</code> \u00e9 parecido com o comando <code>head</code>, com a diferen\u00e7a de que, em vez de tomar somente as primeiras x linhas da entrada e ignorar as demais, ele toma somente as \u00faltimas x linhas e ignora as primeiras.</p> </li> <li> <p><code>less</code> O comando <code>less</code> \u00e9 \u00f3timo para ser usado com comandos que resultam em um n\u00famero elevado de linhas. Ele exibe o resultado de forma paginada e interativa, te permitindo controlar a navega\u00e7\u00e3o pelos dados.</p> </li> </ul>"},{"location":"aulas/01-shell/#3-conclusao","title":"3. Conclus\u00e3o","text":"<p>Nesta aula tivemos um contato bastante profundo com o <code>Bash</code> e a abordagem de trabalhar a partir de um <code>Shell</code>. Ainda temos muito o que explorar pra explorarmos o shell e conseguir fazer dele um lugar onde possamos nos sentir mais confort\u00e1veis e produtivos o suficiente para fazer dele nosso lugar de trabalho. Mas nas pr\u00f3ximas aulas, ficaremos cada vez mais pr\u00f3ximos disto.</p> <p>Com esta introdu\u00e7\u00e3o, podemos explorar outras ferramentas, como a constru\u00e7\u00e3o de scripts, manipular dados e aprender as conven\u00e7\u00f5es de como \u00e9 a vida na interface de linha de comando (Command Line Interface ou, simplesmente, CLI).</p> <p>Bem-vindo a esta jornada, e espero que este primeiro passeio tenha despertado o interesse em prosseguir com as pr\u00f3ximas aulas.</p> <p>Pr\u00f3xima Aula: Aula 2 - Criando Scripts com Bash</p>"},{"location":"aulas/02-scripting/","title":"Aula 02 - Introdu\u00e7\u00e3o a Cria\u00e7\u00e3o Scripts com Bash","text":""},{"location":"aulas/02-scripting/#aula-2-introducao-a-criacao-scripts-com-bash","title":"Aula 2 - Introdu\u00e7\u00e3o a Cria\u00e7\u00e3o Scripts com Bash","text":"<p>Na aula passada fomos apresentados ao ambiente do Shell e come\u00e7amos a nos familiarizar com a vida no terminal usando Bash. Apesar de termos explorado muitas ferramentas que nos permitem interagir com o sistema de arquivos, o uso do Shell n\u00e3o est\u00e1 relegado somente a manipular arquivos e diret\u00f3rios. \u00c9 poss\u00edvel usar o Shell como um ambiente produtivo para lidar com as mais diversas tarefas e, inclusive, automatiz\u00e1-las.</p> <p>Nesta aula iremos explorar as capacidades de automa\u00e7\u00e3o do Bash e criar scripts que expandem a sua utilidade na execu\u00e7\u00e3o de tarefas rotineiras, que o tornam, basicamente, uma linguagem de programa\u00e7\u00e3o n\u00e3o muito diferente das muitas linguagens dispon\u00edveis.</p>"},{"location":"aulas/02-scripting/#21-imprimindo-valores-hello-world","title":"2.1 - Imprimindo Valores (Hello world)","text":"<p>A opera\u00e7\u00e3o mais b\u00e1sica que as linguagens de programa\u00e7\u00e3o apresentam \u00e9 a capacidade de imprimir um valor para o usu\u00e1rio. O ritual de inicia\u00e7\u00e3o padr\u00e3o para todos os que estudam uma linguagem de programa\u00e7\u00e3o \u00e9 imprimir a mensagem universal \"Hello, world\" (Ol\u00e1 mundo). Usando Bash, o comando que usamos para imprimir mensagens para o usu\u00e1rio \u00e9 o comando <code>echo</code>.</p> <pre><code>echo \"Hello world\"\n</code></pre> <p>Como vimos na aula passada, as aspas (<code>\"</code>) s\u00e3o necess\u00e1rias quando queremos usar espa\u00e7os nos argumentos dos comandos que usamos no Bash, de outra forma o Bash iria interpretar os espa\u00e7os como separadores de argumentos, possibilitando resultados inesperados. No caso do comando <code>echo</code>, independente de quantos argumentos voc\u00ea usa, o comportamento dele ser\u00e1 o mesmo.</p> <pre><code>echo Hello world\n</code></pre> <p>Mas, \u00e9 de bom tom seguir a conven\u00e7\u00e3o e usar delimitadores (<code>\"</code> ou <code>'</code>) para garantir a consist\u00eancia dos argumentos. Ao longo desta aula, manter esta consist\u00eancia far\u00e1 mais sentido, \u00e0 medida que veremos como argumentos podem ser transformados ou reutilizados.</p>"},{"location":"aulas/02-scripting/#22-expressoes-e-expansoes-do-shell","title":"2.2 - Express\u00f5es e Expans\u00f5es do Shell","text":"<p>O uso de delimitadores, como o que usamos para definir o argumento <code>\"Hello world\"</code> para o comando <code>echo</code>, \u00e9 um exemplo de uma express\u00e3o. Express\u00f5es s\u00e3o formas de criar valores em uma linguagem de programa\u00e7\u00e3o, e em Bash n\u00e3o \u00e9 diferente. Express\u00f5es de textos s\u00e3o as mais simples que podemos usar, mas existem outros tipos de express\u00f5es, e falaremos um pouco sobre alguns deles.</p> <p>Um tipo de express\u00e3o comum em Bash, s\u00e3o express\u00f5es que expandem seu conte\u00fado baseado em algumas opera\u00e7\u00f5es dispon\u00edveis. Existem v\u00e1rios tipos de expans\u00f5es que podemos utilizar quando escrevemos express\u00f5es em Bash. Uma delas \u00e9, por exemplo, expandir o resultado da execu\u00e7\u00e3o de um comando para utiliz\u00e1-lo em uma instru\u00e7\u00e3o. Para criar express\u00f5es deste tipo, usamos a expans\u00e3o <code>$(&lt;comando-bash&gt;)</code>.</p> <pre><code>echo $(ls)\n</code></pre> <p>A linha acima executa o comando <code>ls</code> e usa a sa\u00edda como uma express\u00e3o que \u00e9 ent\u00e3o passada para o comando <code>echo</code>. O resultado \u00e9 semelhante \u00e0 execu\u00e7\u00e3o do comando <code>ls</code> no shell (a exibi\u00e7\u00e3o da lista de arquivos). A diferen\u00e7a \u00e9 que podemos usar esta expans\u00e3o em outras opera\u00e7\u00f5es, n\u00e3o apenas para exib\u00ed-las (usando o comando <code>echo</code>), mas tamb\u00e9m, por exemplo, atribuir este valor a vari\u00e1veis e reutiliz\u00e1-las para outros fins, como veremos em breve.</p> <p>\u00c9 poss\u00edvel, tamb\u00e9m, expandir express\u00f5es aritm\u00e9ticas e exibir seu resultado. Para criarmos uma express\u00e3o aritm\u00e9tica, usamos a expans\u00e3o <code>$(( &lt;express\u00e3o-aritm\u00e9tica&gt; ))</code>. Desta forma, o shell n\u00e3o tentar\u00e1 interpretar a express\u00e3o como se fosse um comando.</p> <pre><code>echo $((7 + 8))\necho $((7 * 8))\necho $(((7 - 3) / (8 % 3)))\n</code></pre>"},{"location":"aulas/02-scripting/#23-definindo-variaveis","title":"2.3 - Definindo vari\u00e1veis","text":"<p>Como em qualquer linguagem de programa\u00e7\u00e3o, em Bash n\u00f3s podemos definir vari\u00e1veis para guardar valores que precisam ser reutilizados. Para definir vari\u00e1veis em Bash, tudo o que precisamos fazer \u00e9 uma atribui\u00e7\u00e3o de um valor a um nome, usando o operador <code>=</code>. O \u00fanico cuidado que devemos ao fazermos uma atribui\u00e7\u00e3o \u00e9 redobrar nossa aten\u00e7\u00e3o ao fato de que, em Bash, espa\u00e7os contam. Por exemplo:</p> <pre><code>foo=bar # Atribui\u00e7\u00e3o do valor `bar` a uma nova vari\u00e1vel chamada `foo`\nfoo = bar # Erro. O Bash tenta executar um comando chamado `foo` com 2 argumentos (`-` e `bar`).\n</code></pre> <p>Para usarmos as vari\u00e1veis que criamos, n\u00f3s nos referimos a elas usando o sinal <code>$</code> como prefixo. Por exemplo:</p> <pre><code>echo $foo\n</code></pre> <p>Qualquer resultado de uma express\u00e3o pode ser atribu\u00eddo a uma vari\u00e1vel:</p> <pre><code>soma=$((7 + 8))\n</code></pre>"},{"location":"aulas/02-scripting/#231-interpolacao-de-valores","title":"2.3.1 - Interpola\u00e7\u00e3o de Valores","text":"<p>Interpola\u00e7\u00e3o de valores \u00e9 a capacidade que o Bash tem de identificar marcadores em valores de texto para substituir por valores computados durante a execu\u00e7\u00e3o do comando. Por exemplo:</p> <pre><code>echo \"o conte\u00fado da vari\u00e1vel foo \u00e9 $foo\"\n</code></pre> <p>No c\u00f3digo acima, o Bash vai identificar o uso da vari\u00e1vel foo (usada com o <code>$</code>), e vai substituir este marcador pelo valor da vari\u00e1vel.</p> <p>A interpola\u00e7\u00e3o de valores s\u00f3 funciona com textos delimitados por <code>\"</code> (aspas). Se o texto for delimitado por <code>'</code> (ap\u00f3strofos), o bash trata o texto como literal e n\u00e3o faz a interpola\u00e7\u00e3o. Esta distin\u00e7\u00e3o tem suas vantagens, como por exemplo, quando voc\u00ea quer que a interpola\u00e7\u00e3o aconte\u00e7a em um momento diferente do da execu\u00e7\u00e3o do script, delegando a interpola\u00e7\u00e3o para outra etapa da automa\u00e7\u00e3o, ou outro processo que ser\u00e1 executado.</p> <p>Podemos, tamb\u00e9m, interpolar valores resultantes de quaisquer tipos express\u00f5es suportadas pelo Bash.</p> <pre><code>echo \"Interpolando o valor de uma vari\u00e1vel: $foo\"\necho \"Interpolando o resultado de um comando: $(ls -lha ~ | grep Jul)\"\necho \"Interpolando o resultado de uma express\u00e3o aritm\u00e9tica: $((2 + 3 - 4 * 5 / 6 % 7))\"\n</code></pre>"},{"location":"aulas/02-scripting/#232-variaveis-de-ambiente","title":"2.3.2 - Vari\u00e1veis de ambiente","text":"<p>Vari\u00e1veis de ambiente s\u00e3o valores que s\u00e3o carregados na sess\u00e3o do shell e que ficam dispon\u00edveis para os programas e comandos que usamos ao longo desta sess\u00e3o. Elas funcionam como qualquer outra vari\u00e1vel definida no shell, com a diferen\u00e7a de que elas j\u00e1 est\u00e3o criadas e dispon\u00edveis para serem usadas.</p> <p>Uma forma de listar as vari\u00e1veis de ambiente carregadas na sess\u00e3o do shell \u00e9 atrav\u00e9s do comando <code>export</code>.</p> <pre><code>export # Lista as vari\u00e1veis de ambiente da sess\u00e3o atual\n</code></pre> <p>Qualquer uma dessas vari\u00e1veis podem ser usadas a partir de comandos no shell da mesma forma como as vari\u00e1veis que definimos at\u00e9 aqui.</p> <pre><code>echo $HOME\necho $HOSTTYPE\necho \"O diret\u00f3rio atual da sess\u00e3o \u00e9 $PWD, o diret\u00f3rio anterior \u00e9 $OLDPWD\"\n</code></pre> <p>Dentre as vari\u00e1veis de ambiente, uma vari\u00e1vel muito importante que afeta a forma como usamos o shell \u00e9 a vari\u00e1vel $PATH. Esta vari\u00e1vel orienta o shell sobre em quais diret\u00f3rios ele precisa buscar os programas que usamos. Por exemplo, quando usamos o programa <code>echo</code>, ou <code>grep</code>, ou outros programas que temos usado at\u00e9 aqui, o shell precisa saber como localiz\u00e1-los e, para isto, usa a vari\u00e1vel <code>$PATH</code>.</p> <pre><code>echo $PATH\n</code></pre> <p>Uma forma de saber onde est\u00e1 um dado programa que usamos \u00e9 atrav\u00e9s do comando <code>which</code>.</p> <pre><code>which echo # imprime o endere\u00e7o do programa echo\n</code></pre> <p>Com certeza, voc\u00ea ir\u00e1 encontrar o diret\u00f3rio exibido no caminho do comando <code>echo</code> como parte da vari\u00e1vel <code>$PATH</code>, do contr\u00e1rio n\u00e3o seria poss\u00edvel us\u00e1-lo.</p> <p>Para definir vari\u00e1veis de ambiente na sess\u00e3o do shell, tamb\u00e9m usamos o comando <code>export</code>, por\u00e9m atribuindo o valor \u00e0 vari\u00e1vel que desejamos criar:</p> <pre><code>export foo=bar\nx=y\nexport\n</code></pre> <p>Note que agora, entre as vari\u00e1veis listadas, encontra-se a vari\u00e1vel <code>foo</code> e seu valor. Por outro lado, a vari\u00e1vel <code>x</code> n\u00e3o faz parte do ambiente, ela est\u00e1 carregada no shell, mas n\u00e3o \u00e9 tratada como parte do ambiente.</p>"},{"location":"aulas/02-scripting/#233-o-ambiente","title":"2.3.3 O Ambiente","text":"<p>O ambiente \u00e9 uma lista de pares de <code>nome=valor</code> carregados na sess\u00e3o do shell e que s\u00e3o fornecidos para os programas executados a partir daquela sess\u00e3o. Isso \u00e9 uma forma \u00fatil de fazer com que programas e scripts que executamos possam receber valores sem a necessidade de inform\u00e1-los atrav\u00e9s de argumentos.</p> <p>Veremos com mais detalhes como o ambiente funciona na aula sobre o ambiente de linha de comando, quando discutiremos a execu\u00e7\u00e3o de programas a partir do ambiente de linha de comando.</p>"},{"location":"aulas/02-scripting/#234-sessoes","title":"2.3.4 Sess\u00f5es","text":"<p>Como acabamos de descrever, as vari\u00e1veis de ambiente ficam dispon\u00edveis na sess\u00e3o do Shell. A sess\u00e3o do shell dura enquanto o shell estiver aberto. Se voc\u00ea sair do Bash, voc\u00ea encerra a sess\u00e3o, e o ambiente daquela sess\u00e3o deixa de existir.</p> <p>Fa\u00e7a este teste, encerre o shell no terminal atual (fechando o terminal) e abra novamente o terminal. Uma nova sess\u00e3o ser\u00e1 criada e, se voc\u00ea executar o comando <code>export</code>, notar\u00e1 que a vari\u00e1vel <code>foo</code> que acabamos de criar n\u00e3o est\u00e1 mais dispon\u00edvel.</p> <p>As vari\u00e1veis que voc\u00ea v\u00ea listadas atrav\u00e9s do comando <code>export</code> quando inicia uma nova sess\u00e3o do shell s\u00e3o atribu\u00eddas ao ambiente durante a inicializa\u00e7\u00e3o da sess\u00e3o. Isto acontece gra\u00e7as a alguns scripts que s\u00e3o invocados no momento em que a sess\u00e3o \u00e9 iniciada.</p> <p>Por exemplo, o script <code>~/.bashrc</code> possui a defini\u00e7\u00e3o de diversas vari\u00e1veis de ambiente. Outro arquivo \u00fatil \u00e9 o <code>~/.profile</code> ou o <code>~/.profile_bash</code> (podem n\u00e3o existir no seu sistema, mas tamb\u00e9m s\u00e3o formas de definir o ambiente da sess\u00e3o).</p> <pre><code>cat ~/.bashrc\ncat ~/.profile\ncat ~/.profile_bash\n</code></pre> <p>\u00c9 interessante saber como o ambiente \u00e9 criado na inicializa\u00e7\u00e3o da sess\u00e3o (atrav\u00e9s de arquivos como estes), para entendermos que todo o ambiente \u00e9 facilmente configur\u00e1vel no shell, e que as coisas n\u00e3o acontecem como m\u00e1gica.</p>"},{"location":"aulas/02-scripting/#24-composicao-de-comandos-e-operacoes-logicas","title":"2.4 - Composi\u00e7\u00e3o de Comandos e Opera\u00e7\u00f5es L\u00f3gicas","text":"<p>Bash suporta uma forma de criar uma composi\u00e7\u00e3o de comandos em uma \u00fanica instru\u00e7\u00e3o usando o separador <code>;</code>. Por exemplo:</p> <pre><code>echo \"Ol\u00e1 mundo\"; date ; echo \"Bom trabalho.\"\n</code></pre> <p>Outra forma de compor comandos em uma \u00fanica instru\u00e7\u00e3o \u00e9 usando o operador <code>&amp;</code>. A diferen\u00e7a entre compor comandos com <code>;</code> e <code>&amp;</code>, \u00e9 que com <code>;</code> ele sempre executa o comando seguido por <code>;</code> de forma s\u00edncrona, esperando o fim da sua execu\u00e7\u00e3o antes de executar o pr\u00f3ximo, enquanto que com <code>&amp;</code>, o bash executa cada comando seguido por <code>&amp;</code> em um novo processo ass\u00edncrono, e inicia a execu\u00e7\u00e3o do pr\u00f3ximo sem aguardar a sua finaliza\u00e7\u00e3o.</p> <p>Instru\u00e7\u00f5es como esta acima executam cada comando na ordem em que eles s\u00e3o escritos, mas sem conect\u00e1-los de forma alguma (como vimos na aula anterior na se\u00e7\u00e3o Conectando Programas).</p> <p>Usar este tipo de composi\u00e7\u00e3o executa todos os comandos independente do resultado de qualquer um deles. Se houver um erro em algum comando desta cadeia, isso n\u00e3o far\u00e1 com que o bash deixe de executar os demais comandos.</p> <p>Existem cen\u00e1rios onde a execu\u00e7\u00e3o de alguns comandos da composi\u00e7\u00e3o pode gerar resultados que afetem o funcionamento dos demais comandos. Para estes cen\u00e1rios, usamos opera\u00e7\u00f5es l\u00f3gicas.</p> <p>Bash, como qualquer outra linguagem de programa\u00e7\u00e3o suporta certos tipos de opera\u00e7\u00f5es l\u00f3gicas. Opera\u00e7\u00f5es l\u00f3gicas s\u00e3o opera\u00e7\u00f5es que geram resultados bin\u00e1rios (verdadeiro ou falso), e que podem ser usadas para criar uma composi\u00e7\u00e3o de comandos baseada no resultado dos comandos usados.</p> <p>Os operadores l\u00f3gicos que usaremos aqui s\u00e3o o <code>||</code> (operador OU) e o <code>&amp;&amp;</code> (operador E). E os valores l\u00f3gicos em Bash s\u00e3o <code>true</code> (representa o valor verdadeiro) e <code>false</code> (que representa o valor falso).</p> <p>Vamos ver alguns exemplos b\u00e1sicos de express\u00f5es l\u00f3gicas: </p><pre><code>echo true\necho false\n\necho true || true\necho true || false\necho false || true\necho false || false\n\necho true &amp;&amp; true\necho true &amp;&amp; false\necho false &amp;&amp; true\necho false &amp;&amp; false\n</code></pre> <p>Os operadores l\u00f3gicos possuem a capacidade de garantir certos resultados baseados no valor dos operandos: O operador <code>||</code> (OU) resulta em <code>true</code> (verdadeiro) quando qualquer um dos operandos, ou ambos, s\u00e3o verdadeiros, e s\u00f3 resulta em <code>false</code>(falso) quando ambos os operandos s\u00e3o falsos. Por outro lado, o operador <code>&amp;&amp;</code> (E), s\u00f3 resulta em true quando ambos os operandos s\u00e3o verdadeiros, mas resulta em false quando qualquer um deles, ou ambos, s\u00e3o false.</p> <p>Ambos os operadores tamb\u00e9m possuem a propriedade de descartar o segundo operando de acordo com certos crit\u00e9rios sobre o primeiro. Por exemplo, por que o operador <code>||</code> resulta em <code>true</code> caso qualquer operando seja verdadeiro, se o primeiro operando (\u00e0 esquerda do operador) resultar em <code>true</code>, o operador descarta qualquer que seja o valor do segundo operando (\u00e0 direita do operador) e resulta imediatamente em <code>true</code>.</p> <p>J\u00e1 o operador <code>&amp;&amp;</code>, que resulta <code>false</code> caso qualquer um dos operandos seja falso, descarta o segundo operando quando o primeiro j\u00e1 resultou em <code>false</code>, antecipando o resultado da opera\u00e7\u00e3o.</p> <p>Estas propriedades s\u00e3o \u00fateis, principalmente quando consideramos que um comando executado sem resultar em erros \u00e9 considerado como resultando em <code>true</code>, mas caso resulte em qualquer erro tem sua execu\u00e7\u00e3o resultando como valor <code>false</code>. Por exemplo:</p> <pre><code>true || echo \"Este comando N\u00c3O SER\u00c1 executado\"\nfalse || echo \"Este comando SER\u00c1 executado\"\ntrue &amp;&amp; echo \"Este comando SER\u00c1 executado\"\nfalse &amp;&amp; echo \"Este comando N\u00c3O SER\u00c1 executado\"\n</code></pre> <p>Isto torna poss\u00edvel criarmos uma composi\u00e7\u00e3o mais sofisticada de comandos, fazendo com que o resultado de alguns comandos influenciem a execu\u00e7\u00e3o ou n\u00e3o dos demais.</p> <pre><code>echo \"Ol\u00e1 mundo\" || echo \"Este comando N\u00c3O SER\u00c1 executado\"\nmv xpto.txt ~ || echo \"Houve algum problema no comando anterior\"\necho \"Esta linha ser\u00e1 exibida\" &amp;&amp; echo \"Esta tamb\u00e9m\"\nmv xpto.txt ~ || (echo \"Houve algum problema no comando anterior, criando o arquivo vazio\" &amp;&amp; touch ~/xpto.txt)\n</code></pre> <p>Desta forma podemos decidir se queremos apenas que os comandos sejam executados de forma independente (usando o separador <code>;</code>), ou se queremos usar o resultado dos comandos intermedi\u00e1rios na composi\u00e7\u00e3o para definirmos se os comandos posteriores ser\u00e3o ou n\u00e3o executados.</p>"},{"location":"aulas/02-scripting/#25-expansoes-de-chave","title":"2.5 - Expans\u00f5es de Chave","text":"<p>Expans\u00f5es de Chave s\u00e3o um tipo espec\u00edfico de expans\u00e3o do shell, como os que vimos anteriormente (<code>$()</code> e <code>$(())</code>), que usa express\u00f5es cercadas por chaves (<code>{}</code>) para expandir para um conjunto de valores. Por exemplo:</p> <p></p><pre><code>echo a{b,c,d}e\n</code></pre>  A linha acima vai expandir a express\u00e3o <code>a{b,c,d}e</code> para <code>abe ace ade</code>. Note algumas coisas:  - Cada elemento dentro das chaves foi usado para materializar um elemento no resultado final  - O resultado foi a expans\u00e3o dos elementos separados por espa\u00e7o, na ordem em que eles est\u00e3o dentro das chaves <p>\u00c9 poss\u00edvel combinar mais de uma expans\u00e3o de chaves na mesma express\u00e3o: </p><pre><code>echo ab{c,d}{e,f}gh\n</code></pre> <p>N\u00e3o precisamos nos limitar a apenas conjuntos de elementos formados por uma \u00fanica letra, mas podemos usar valores de tamanhos variados.</p> <pre><code>echo ab{cde,fghi}j \n</code></pre> <p>O exemplo acima mostra uma expans\u00e3o com apenas dois elementos, cada um com um tamanho diferente.</p> <p>Tamb\u00e9m podemos expandir os elementos dentro das chaves para o intervalo de uma sequ\u00eancia ncremental usando a expans\u00e3o <code>..</code>. Por exemplo: </p><pre><code>echo {1..9}\necho {a..z} # podemos usar letras no lugar de n\u00fameros\necho a{1..5}{b..f}g\n</code></pre> <p>Podemos tamb\u00e9m controlar a forma como estas sequ\u00eancias s\u00e3o incrementadas: </p><pre><code>echo {1..9..2} # Incrementa de dois em dois\necho {1..9..3} # ou de tr\u00eas em tr\u00eas\necho {a..z..3} # tamb\u00e9m funciona com letras\n</code></pre> <p>O fato de expans\u00f5es deste tipo serem formadas com os elementos separados por espa\u00e7o as tornam \u00fateis quando usamos estas expans\u00f5es com comandos que recebem m\u00faltiplos argumentos e que podem ser usados de forma mais produtiva. Por exemplo:</p> <pre><code>mkdir {foo,bar} # cria dois diret\u00f3rios\ntouch {foo,bar}/{a..h}.{txt,sh} # cria nos dois diret\u00f3rios um conjunto arquivos .txt\nmkdir baz\ncp foo/{a..h..2}.txt baz\ncp bar/{a..h..2}.sh baz\n</code></pre>"},{"location":"aulas/02-scripting/#26-stream-de-erro","title":"2.6 - Stream de Erro","text":"<p>Na aula passada n\u00f3s falamos um pouco sobre os streams que os programas recebem: o stream de entrada e o stream de sa\u00edda. Existe um terceiro stream que n\u00e3o mencionamos, que \u00e9 o stream de erro. Ele designa ao programa que est\u00e1 sendo executado para onde as mensagens de erro ser\u00e3o enviadas.</p> <p>Por padr\u00e3o, o stream erro \u00e9 o pr\u00f3prio terminal, como tamb\u00e9m \u00e9 o padr\u00e3o para o stream de sa\u00edda.</p> <pre><code>mv zaz ~\n</code></pre> <p>Considerando que n\u00e3o exista um arquivo ou diret\u00f3rio chamado <code>zaz</code>, o comando acima ir\u00e1 gerar uma mensagem de erro e imprimir no terminal. Esta mensagem de erro foi escrita no stream de erro. Para observar isto, podemos religar o stream de sa\u00edda a um arquivo e observar o comportamento do comando:</p> <pre><code>mv zaz ~ &gt; zaz.out\ncat zaz.out\n</code></pre> <p>Observer que, apesar de termos religado o stream de sa\u00edda para o arquivo <code>zaz.out</code>, a mensagem de erro continua sendo exibida e o arquivo gerado est\u00e1 vazio. Isto demonstra como a mensagem gerada n\u00e3o foi produzida no stream de sa\u00edda. Mas, como podemos religar o stream de erro a um arquivo? Podemos fazer isto atrav\u00e9s do operador <code>2&gt;</code>:</p> <pre><code>mv zaz ~ &gt; zaz.out 2&gt; zaz.err\ncat zaz.out\n</code></pre> <p>Desta vez a mensagem de erro n\u00e3o foi impressa no terminal, e o arquivo <code>zaz.err</code> foi criado, e ele cont\u00e9m a mensagem de erro que antes v\u00edamos impressa nos comandos anteriores. Desta forma podemos separar tanto o conte\u00fado escrito no stream de sa\u00edda quanto o conte\u00fado escrito no stream de erro do terminal.</p>"},{"location":"aulas/02-scripting/#27-shell-script","title":"2.7 - Shell Script","text":"<p>A capacidade de usar comandos de forma produtiva no Bash nos habilita a elevar esta produtividade atrav\u00e9s de scripts.</p> <p>Scripts s\u00e3o arquivos contendo comandos que ser\u00e3o executados pelo shell em sequ\u00eancia, podendo servir como uma ferramenta de automa\u00e7\u00e3o, ou at\u00e9 mesmo programa\u00e7\u00e3o.</p> <p>O uso de scripts usando Bash para automa\u00e7\u00e3o \u00e9 t\u00e3o comum que existem profissionais em posi\u00e7\u00f5es que se apoiam em Shell Script, como principal atividade no seu dia-a-dia.</p> <p>Para criar um script, tudo o que precisamos fazer \u00e9 criar um arquivo texto contendo a lista de comandos que queremos executar (convencionalmente, usando a extens\u00e3o <code>.sh</code>) e o executamos religando o stream de entrada do comando <code>bash</code> ao arquivo do script.</p> <p>Important</p> <p>O comando <code>bash</code> \u00e9, na realidade, o execut\u00e1vel do shell que temos usado at\u00e9 agora. Ao invocarmos o comando <code>bash</code> passando o nosso script como argumento, n\u00e3o estamos fazendo nada diferente do que seria abrir o shell e executarmos os comandos manualmente. A \u00fanica diren\u00e7a \u00e9 que estamos fazendo de forma automatizada.</p> <p>Vamos ver como isto funciona.</p>"},{"location":"aulas/02-scripting/#271-criando-e-executando-scripts","title":"2.7.1 - Criando e Executando Scripts","text":"<p>Vamos criar o nosso primeiro Script executando o famoso rito de inicia\u00e7\u00e3o que discutimos no in\u00edcio desta aula, <code>Ol\u00e1, mundo</code>.</p> <pre><code>cat &gt; ola.sh\necho \"Ol\u00e1, mundo\"\n</code></pre> <p>Para executar nosso script, usamos o comando <code>sh</code>. </p><pre><code>bash &lt; ./ola.sh\n</code></pre> <p>O comando <code>sh</code> l\u00ea o conte\u00fado do arquivo <code>ol\u00e1.sh</code> e o interpreta, executando seus comandos. Podemos, incrementar este script com mais comandos:</p> <pre><code>cat &gt;&gt; ola.sh\ndate\necho \"Bom trabalho\"\nbash &lt; ./ola.sh\n</code></pre> <p>Note como, desta vez, ele executou todos os comandos do nosso script.</p> <p>Na verdade, o comando <code>bash</code> \u00e9 capaz de receber um arquivo de script como argumento e interpret\u00e1-lo sem que precisemos religar seu stream de entrada.</p> <pre><code>bash ./ola.sh\n</code></pre> <p>Outra forma de executarmos um script, \u00e9 transformando-o em um execut\u00e1vel. Para isto, precisamos forncecer privil\u00e9gios de execu\u00e7\u00e3o para o usu\u00e1rio que pretende fazer este uso. Fazemos isto atrav\u00e9s do comando <code>chmod</code></p> <p></p><pre><code>stat ./ola.sh\n</code></pre> <p>Note</p> <p>O comando <code>stat</code> imprime o status do arquivo no sistema. Informa\u00e7\u00f5es \u00fateis, como tamanho, permiss\u00f5es, data de cria\u00e7\u00e3o, data da \u00faltima modifica\u00e7\u00e3o, quem \u00e9 o owner e outras.</p> <p>Note, a sess\u00e3o de acesso (access), que ele n\u00e3o possui permiss\u00f5es de execu\u00e7\u00e3o para nenhum usu\u00e1rio (<code>-rw-r--r--</code>). Para conceder permiss\u00e3o de execu\u00e7\u00e3o para o arquivo <code>ola.sh</code>, n\u00f3s usamos o comando <code>chmod</code>. A permiss\u00e3o para execu\u00e7\u00e3o \u00e9 representada pelo caractere <code>x</code>.</p> <pre><code>chmod +x ola.sh\n</code></pre> <p>Agora, podemos conferir as permiss\u00f5es novamente atrav\u00e9s do comando <code>stat</code>.</p> <p></p><pre><code>stat ola.sh\n</code></pre> <p>Finalmente, com a devida permiss\u00e3o, somos capazes de executar o script.</p> <pre><code>./ola.sh\n</code></pre> <p>Note</p> <p>O motivo de precisarmos usar o endere\u00e7o do nosso escript para execut\u00e1-lo (<code>./</code>) \u00e9 que, no bash (bem como em diversos shells compat\u00edveis com o Unix), o shell somente procura por execut\u00e1veis que est\u00e3o nos diret\u00f3rios presentes n vari\u00e1vel $PATH. O shell n\u00e3o procura por execut\u00e1veis no diret\u00f3rio atual, como faz, por exemplo, o shell <code>cmd</code> do Windows. </p> <p>Portanto, no Bash (e em outros shells compat\u00edveis com unix, como o dash ou o zsh), devemos apontar onde est\u00e1 o execut\u00e1vel que pretendemos rodar, mesmo que ele esteja no diret\u00f3rio atual do shell, passando o caminho completo ou relativo do mesmo.</p> <p>Mas, antes de prosseguirmos, vamos seguir a conven\u00e7\u00e3o de orientar ao shell sobre qual interpretador dever\u00e1 usar ao executar nosso script, usando a nota\u00e7\u00e3o chamada de shebang. O shebang \u00e9 a sequ\u00eancia dos caracteres <code>#!</code>, usada para sistemas compat\u00edveis com Unix (como o linux) para apontar ao shell qual \u00e9 o interpretador do execut\u00e1vel. No nosso caso, at\u00e9 aqui, estamos usando o pr\u00f3prio bash como interpretador (<code>/bin/bash</code>), e ser\u00e1 ele mesmo que usaremos no nosso shebang, mas este processo \u00e9 importante, pois outros interpretadores est\u00e3o dispon\u00edveis.</p> <p>Ent\u00e3o, precisamos colocar o <code>shebang</code> na primeira linha do arquivo e, para isto, precisamos edit\u00e1-lo, e faremos isto usando o editor <code>vi</code>. Voc\u00ea pode usar outro editor de sua prefer\u00eancia. Falaremos de <code>Vim</code> e do <code>vscode</code> em aulas futuras. Para usu\u00e1rios Windows que n\u00e3o possuem interesse em usar o <code>vi</code>, \u00e9 poss\u00edvel usar o Bloco de Notas. Basta executar o <code>notepad.exe</code>, passando como argumento o nome do arquivo.</p> <pre><code>vi ola.sh\n</code></pre> <p>O <code>vi</code> \u00e9 um editor de textos modal b\u00e1sico, dispon\u00edvel no bash. Modal significa que ele funciona em diferentes modos. No momento em que o abrimos, ele est\u00e1 no modo de comando (command mode). Para edit\u00e1-lo, precisamos alternar para o modo de digita\u00e7\u00e3o (type mode).</p> <p>Existem diferentes formas para alternarmos para o modo de digita\u00e7\u00e3o, mas a que iremos usar aqui aplica um comando antes: O comando shift+O cria uma linha acima da linha onde estamos posicionados (que \u00e9 a primeira linha), e posiciona o cursor na nova linha em branco, mudando para o modo de digita\u00e7\u00e3o.</p> <p> Agora podemos digitar a nossa linha do shebang: </p><pre><code>#!/bin/bash\n</code></pre> <p>Para concluir a edi\u00e7\u00e3o, precisamos antes voltar para o modo de comando, usando a tecla ESC. De volta ao modo de comando, usamos o <code>:w</code> para salvar o arquivo (pressionando ENTER/RETURN logo em seguida). Para sair do editor vi, usamos o comando <code>:q</code> e pressionamos ENTER/RETURN.</p> <p>Isto n\u00e3o afeta em nada o funcionamento do nosso script atual. Mas \u00e0 medida que voc\u00ea aprende a viver no shell, voc\u00ea poder\u00e1 criar outros tipos de script. Como, por exemplo, scripts em Python, que voc\u00ea poder\u00e1 transformar em execut\u00e1veis e usar um shebang adequado para que o shell saiba como execut\u00e1-los.</p> <p>O exemplo a seguir pode n\u00e3o funcionar no seu sistema se voc\u00ea n\u00e3o possuir o interpretador do Python instalado.</p> <pre><code>which python\ncat &gt; ola.py\n#!/usr/bin/python\nprint(\"Ol\u00e1, mundo\")\n^C\nchmod +x ola.py\n./ola.py\n</code></pre> <p>Agora que vimos como podemos executar nossos scripts, vamos aprender como fazer melhor uso deles.</p>"},{"location":"aulas/02-scripting/#272-recebendo-argumentos-em-scripts","title":"2.7.2 - Recebendo argumentos em Scripts","text":"<p>Ao longo destas aulas temos usado diversos comandos que recebem argumentos como forma de ter algum controle sobre o seu comportamento, e n\u00e3o \u00e9 diferente com os scripts que podemos construir. O Bash nos permite receber argumentos em nossos scripts atrav\u00e9s de par\u00e2metros numerados.</p> <p>Para ler estes par\u00e2metros, podemos usar vari\u00e1veis especiais usando a nota\u00e7\u00e3o com o sinal <code>$</code> e o n\u00famero dos par\u00e2metros de 1 a 9. Por exemplo:</p> <p>Warning</p> <p>N\u00e3o se esque\u00e7a de dar permiss\u00e3o de execu\u00e7\u00e3o para os arquivos de script antes de test\u00e1-los</p> <pre><code>cat &gt; params.sh\necho \"In\u00edcio da execu\u00e7\u00e3o\"\necho $1\necho \"Fim da execu\u00e7\u00e3o\"\n</code></pre> <p>Uma varia\u00e7\u00e3o do famoso \"Ol\u00e1, mundo\", mas que consegue saudar uma pessoa: </p><pre><code>cat &gt; saudar.sh\necho \"Ol\u00e1, \" $1\n</code></pre> <p>Um script de exemplo pra fazer um c\u00e1lculo aritm\u00e9tico: </p><pre><code>cat &gt; soma.sh\necho $(($1 + $2))\n</code></pre> <p>Existem, tamb\u00e9m, outros par\u00e2metros especiais para tornar o script mais din\u00e2mico: - <code>$@</code>: lista todos os par\u00e2metros, n\u00e3o limitados a 9. - <code>$#</code>: retorna o n\u00famero de argumentos usados na execu\u00e7\u00e3o do script - <code>$0</code>: retorna o nome do script que est\u00e1 sendo executado - <code>$$</code>: retorna o n\u00famero do processo que executa o script - <code>$?</code>: retorna o c\u00f3digo de sa\u00edda do programa anterior</p> <pre><code>cat &gt; fancy.sh\necho \"Iniciando a execu\u00e7\u00e3o de $0 no processo $$\"\necho \"Usando $# par\u00e2metros: $@\"\nls -lha\necho \"Resultado do comando: $?\"\n</code></pre>"},{"location":"aulas/02-scripting/#28-conclusao","title":"2.8 - Conclus\u00e3o","text":"<p>Nesta aula aprendemos o b\u00e1sico a respeito da cria\u00e7\u00e3o de scripts usando o Bash. T\u00e9cnicas mais complexas e sofisticadas ser\u00e3o apresentadas na aula de Scripts Avan\u00e7ados, que veremos no futuro. Por ora, podemos mudar o nosso foco para o uso de Editores de Texto como ferramentas produtivas para profissionais de TI.</p> <p>Nos vemos na pr\u00f3xima aula.</p>"},{"location":"aulas/03-text-editors/","title":"Aula 03 - Explorando o Editor de Textos (Visual Studio Code)","text":""},{"location":"aulas/03-text-editors/#aula-3-explorando-o-editor-de-textos-visual-studio-code","title":"Aula 3 - Explorando o Editor de Textos (Visual Studio Code)","text":"<p>Escrever um texto (como um documento, ou uma disserta\u00e7\u00e3o) e escrever c\u00f3digo s\u00e3o atividades distintas. Quando se trabalha com c\u00f3digo, voc\u00ea passa mais tempo navegando por ele, entre os diversos arquivos, lendo, interpretando e, claro, escrevendo c\u00f3digo tamb\u00e9m. N\u00e3o \u00e9 \u00e0 toa que existem ferramentas diferentes para este fim do que aquelas usadas para redigir um texto, como um processador de textos (por exemplo, o Microsoft Word do pacote Office). Processadores de Texto precisam suportar diversas op\u00e7\u00f5es de formata\u00e7\u00e3o (formata\u00e7\u00e3o de fonte, par\u00e1grafo, p\u00e1gina, etc) que acabam sendo t\u00e3o importantes quanto o pr\u00f3rio texto sendo redigido.</p> <p>Para trabalhar com c\u00f3digo, usamos Editores de Textos. A diferen\u00e7a \u00e9 que, em c\u00f3digo, somente o conte\u00fado do texto importa. O arquivo mantido no sistema n\u00e3o possui informa\u00e7\u00f5es de formata\u00e7\u00e3o. N\u00e3o apenas esta informa\u00e7\u00e3o n\u00e3o \u00e9 relevante, como ainda n\u00e3o \u00e9 suportada pelo c\u00f3digo em si. Pense nos scripts que fizemos na aula passada, usando o comando <code>cat &gt; foo.sh</code>, capturando os comandos que digit\u00e1vamos no terminal e gravando no arquivo. Imagine se tiv\u00e9ssemos \"comprometido\" estes comandos com informa\u00e7\u00f5es como \"qual fonte usar\", \"qual tamanho do papel que ser\u00e1 usado\", etc.</p> <p>Normalmente, quando trabalhamos com c\u00f3digo, trabalhamos com arquivos de textos simples. Para ilustrar o que isso significa olhe para a imagem a seguir.</p> <p></p> <p>Este \u00e9 um Processador de Textos (Google Docs, similar ao Microsoft Word), com um texto  simples (o famoso \"Ol\u00e1 Mundo!\"). Mas se voc\u00ea tentar abrir o conte\u00fado salvo por este arquivo (no formato .doc) em um editor de textos, notar\u00e1 que existem muitas outras informa\u00e7\u00f5es, a maior parte delas ileg\u00edvel para um ser humano.</p> <p></p> <p>Existe uma forma mais amig\u00e1vel de visualizar este arquivo, usando um decodificador Hexadecimal, mas isto n\u00e3o necessariamente o torna t\u00e3o leg\u00edvel quanto um arquivo de texto.</p> <p></p> <p>Editores de texto, por outro lado, n\u00e3o interferem no conte\u00fado salvo pelo arquivo. Voc\u00ea pode escrever c\u00f3digo direto no terminal como fizemos usando o comando <code>cat</code>, mas isto, provavelmente, vai ser pouco produtivo \u00e0 medida que seus scripts come\u00e7am a ficar mais complexos, j\u00e1 que o comando <code>cat</code> te d\u00e1 poucas op\u00e7\u00f5es de edi\u00e7\u00e3o.</p> <p>Existem diversos editores de texto dispon\u00edveis. De fato, se voc\u00ea usa o sistema operacional Windows, voc\u00ea provavelmente possui instalado o Bloco de Notas (<code>notepad.exe</code>). Este \u00e9 um editor de textos bastante rudimentar, que te permite criar arquivos de texto como os que usamos para manter c\u00f3digo. Mas, justamente por que trabalhamos com c\u00f3digo, existem op\u00e7\u00f5es ainda mais produtivas.</p> <p>Existem diversos editores de texto feitos especificamente para trabalhar com c\u00f3digo. Voc\u00ea vai encontrar profissionais que gostam de usar <code>Sublime Text</code>, ou o <code>Notepad ++</code> (que tem a proposta de ser um substituto para o Bloco de Notas do Windows com capacidades de produtividade com c\u00f3digo), outros que v\u00e3o preferir op\u00e7\u00f5es de editores de texto que rodam no terminal, como o <code>vim</code>, ou o <code>emacs</code>. E existem ainda ferramentas mais robustas, chamadas de IDE's (Integrated Development Environment, ou, em portugu\u00eas, Ambiente de Desenvolvimento Integrado), como o Visual Studio da Microsoft, ou o IntelliJ da JetBrains. Contudo, um editor espec\u00edfico mant\u00e9m uma relev\u00e2ncia significativa no mercado e, por que precisamos falar de alguma ferramenta, eu achei que a relev\u00e2ncia do vscode n\u00e3o poderia ser ignorada.</p> <p>De acordo com a pesquisa Stackoverflow Developer Survey de 2024, de um total de mais de 58 mil entrevistados, 73,6% responderam que usam vscode como o editor de c\u00f3digo no dia-a-dia. Destes, mais de 44 mil usam profissionalmente, e mais de 6 mil o usam enquanto est\u00e3o aprendendo a programar. Em ambos os casos, ele destaca sua ado\u00e7\u00e3o por mais do que o dobro do segundo colocado.</p> <p>O vscode \u00e9 mantido pela Microsoft, mas \u00e9 um projeto de c\u00f3digo aberto, mantido sob a licen\u00e7a MIT, e que recebe contribui\u00e7\u00e3o da comunidade.</p> <p>Important</p> <p>\u00c9 importante dizer que, na ind\u00fastria, existe uma discuss\u00e3o acalorada sobre op\u00e7\u00f5es de editores de c\u00f3digo, e v\u00e1rios grupos (principalmente entre as pessoas de programa\u00e7\u00e3o) s\u00e3o muito opinativos a respeito da escolha por editores. A famosa discuss\u00e3o entre os usu\u00e1rios de emacs e vim, tentando estabelecer um como superior ao outro, \u00e9 um bom exemplo de como as pessoas defendem sua op\u00e7\u00e3o na ind\u00fastria.</p> <p>Este curso n\u00e3o pretende estabeler o vscode como uma op\u00e7\u00e3o superior aos demais editores dispon\u00edveis. Apesar de ter capacidades de edi\u00e7\u00e3o de c\u00f3digo que n\u00e3o deixam a desejar (e em muitos casos, chega a ter uma excelente experi\u00eancia de uso), a escolha pelo vscode se d\u00e1 somente pela sua ado\u00e7\u00e3o e a presen\u00e7a que ele tem no mercado atualmente.</p> <p>Editores como Vim ou Emacs, al\u00e9m de n\u00e3o terem a mesma presen\u00e7a que o vscode tem na ind\u00fastria, apesar de terem uma comunidade forte de usu\u00e1rios e mantenedores, tamb\u00e9m possuem uma curva de aprendizado (devido \u00e0 natureza de como funcionam) que, na minha opini\u00e3o, ainda que possuam suas vantagens, torna sua ado\u00e7\u00e3o uma op\u00e7\u00e3o indivudual de quem pretende explor\u00e1-los e, eventualmente, adot\u00e1-los como prefer\u00eancia.</p>"},{"location":"aulas/03-text-editors/#30-instalando-o-vscode","title":"3.0 - Instalando o vscode","text":"<p>Para instalar o vscode, que roda na maioria das plataformas dispon\u00edveis, basta visitar o site oficial, se dirigir \u00e0 p\u00e1gina de downloads e clicar no link adequado de acordo com o seu sistema.</p> <p></p> <p>A partir da\u00ed, basta seguir as instru\u00e7\u00f5es.</p> <p>Important</p> <p>Para instala\u00e7\u00f5es no Windows, \u00e9 importante lembrar-se de manter marcado a op\u00e7\u00e3o \"Add to PATH\" (Adicionar para o PATH). Isso torna o vscode f\u00e1cil de iniciar a partir do shell, inclusive para quem usa o WSL, como recomendado neste curso.</p> <p></p>"},{"location":"aulas/03-text-editors/#31-explorando-a-interface","title":"3.1 - Explorando a interface","text":"<p>Para abrir o vscode, voc\u00ea pode inici\u00e1-lo a partir da interface gr\u00e1fica do seu sistema operacional (Menu Iniciar no Windows), ou, se voc\u00ea tiver adicionado o vscode ao PATH durante a instala\u00e7\u00e3o, basta digitar <code>code</code> a partir do shell.</p> <p>Ao abrir o vscode, a p\u00e1gina de boas-vindas (Welcome) \u00e9 exibida como uma aba aberta na janela do editor, muito semelhante a que voc\u00ea pode enxergar abaixo, com algumas diferen\u00e7as de acordo com o seu uso (na minha, \u00e9 poss\u00edvel ver alguns dos meus projetos recentes listados, prontos para serem abertos).</p> <p></p> <p>A partir desta p\u00e1gina, algumas tarefas comuns j\u00e1 est\u00e3o acess\u00edveis, como criar um novo arquivo, abrir um arquivo existente, abrir um diret\u00f3rio, e at\u00e9 mesmo clonar um reposit\u00f3rio git. \u00c9 poss\u00edvel, tamb\u00e9m, se conectar a outros ambientes, como o WSL, ou remotamente via SSH e outras op\u00e7\u00f5es.</p> <p>Do lado direito, voc\u00ea pode ver alguns guias (Walkthroughs), que podem te ajudar a se familiarizar com a interface e o uso do vscode.</p> <p>No topo da interface, como j\u00e1 \u00e9 t\u00edpico de aplica\u00e7\u00f5es que rodam em interface gr\u00e1fica, temos uma barra de menus, com alguns dos menus mais conhecidos, como File, Edit e Help. Como esperado, o menu File exibe mais op\u00e7\u00f5es relacionadas a manipula\u00e7\u00e3o de arquivos, Edit tem op\u00e7\u00f5es \u00faties como Copiar, Colar, al\u00e9m de outras conveni\u00eancias de edi\u00e7\u00e3o, e o menu Help, sem nenhuma surpresa, tr\u00e1s informa\u00e7\u00f5es \u00fateis para quem precisa de algum suporte.</p> <p>\u00c0 esquerda, temos a Barra Lateral, com algumas funcionalidades dispostas de forma conveniente, como Explorador de Arquivos, Busca, Controle de C\u00f3digo, o Depurador e o painel de Extens\u00f5es.</p> <p>Mais abaixo, ainda na Barra Lateral, existem os bot\u00f5es de Contas (Accounts) e Gerenciamento (Management). O bot\u00e3o de Contas permite voc\u00ea usar algum servi\u00e7o de contas (Microsoft ou Github) para se autenticar e ter a possibilidade, por exemplo, de guardar as configura\u00e7\u00f5es do vscode em um reposit\u00f3rio da internet, tornando poss\u00edvel resgatar estas configura\u00e7\u00f5es em outro dispositivo, por exemplo, e sincroniz\u00e1-lo com as suas prefer\u00eancias configuradas previamente.</p> <p>J\u00e1 no menu de Gerenciamento, voc\u00ea consegue acessar a Paleta de Comandos (tamb\u00e9m usando Ctrl+Shift+P), alternar entre diferentes Perfis (Profiles), personalizar as configura\u00e7\u00f5es do vscode, definir associa\u00e7\u00f5es de teclas de atalho (Keyboard Shortcuts), templates de trechos de c\u00f3digo (snippets), definir Tarefas (Tasks), escolher um tema de cores ou de \u00edcones de arquivos, sincronizar suas configura\u00e7\u00f5es e atualizar a instala\u00e7\u00e3o do vscode no seu dispositivo.</p> <p>A Paleta de Comandos \u00e9 um dos recursos mais ricos do vscode, pois ela lista in\u00fameros comandos dispon\u00edveis no editor, alguns deles acess\u00edveis somente atrav\u00e9s dela. J\u00e1 a escolha por diferentes Perfis permite que voc\u00ea mantenha configura\u00e7\u00f5es diferentes do vscode agrupadas, como um perfil para uso quando trabalhando em projetos de uma organiza\u00e7\u00e3o, e outro para projetos open source ou de uso pessoal, por exemplo.</p> <p>A janela de configura\u00e7\u00f5es do vscode mostra outras formas de agrupar as configura\u00e7\u00f5es: - configura\u00e7\u00f5es globais no sistema onde ele est\u00e1 rodando - configura\u00e7\u00f5es no escopo do usu\u00e1rio que est\u00e1 usando o editor (sobrep\u00f5em as configura\u00e7\u00f5es globais) - configura\u00e7\u00f5es do Espa\u00e7o de Trabalho (Workspace) aberto (sobrep\u00f5em as configura\u00e7\u00f5es do usu\u00e1rio)</p> <p>Falaremos sobre Espa\u00e7os de Trabalho mais adiante.</p> <p></p> <p>Em qualquer um dos tr\u00eas escopos, h\u00e1 uma extensa lista para configurar o editor, as extens\u00f5es instaladas e diversos outros aspectos de uso. Voc\u00ea pode navegar por elas atrav\u00e9s dos menus colaps\u00e1veis \u00e0 esquerda, ou buscando as configura\u00e7\u00f5es desejadas no campo de busca.</p> <p>Para escolher entre temas, o vscode oferece alguns temas de cores e \u00edcones de arquivos pr\u00e9-instalados, mas outros podem ser inseridos a partir de extens\u00f5es. Por exemplo, voc\u00ea pode baixar a extens\u00e3o Ayu, que instala temas de cores e \u00edcones minimalistas para trabalhar com vscode.</p> <p>Por \u00faltimo, a op\u00e7\u00e3o de Teclas de Atalho abre a janela Keyboard Shortcuts, que lista todos os mapeamentos de teclas de atalho para comandos do vscode. \u00c9 poss\u00edvel pesquisar pelos atalhos dispon\u00edveis, editar as configura\u00e7\u00f5es e reassociar teclas de acordo com a sua prefer\u00eancia.</p> <p></p> <p>Falaremos sobre Tarefas (Tasks) e Trechos de C\u00f3digo (Snippets) mais adiante.</p> <p>Na barra de status, que fica no rodap\u00e9 da janela, \u00e9 poss\u00edvel ver alguns outros atalhos, como o indicador de em que ambiente esta inst\u00e2ncia est\u00e1 conectada (\u00e0 esquerda no rodap\u00e9) no qual voc\u00ea pode clicar para se conectar (no WSL ou em um computador remoto via SSH ou Tunnel), e do outro lado, \u00e0 direita, existe o indicador de notifica\u00e7\u00f5es (um \u00edcone no formato de sino), que tamb\u00e9m pode ser clicado para visualizar as notifica\u00e7\u00f5es pendentes (como novas atualiza\u00e7\u00f5es dispon\u00edveis, sugest\u00f5es de extens\u00e3o, etc.).</p> <p>Ao lado do indicador de notifica\u00e7\u00f5es temos o seletor de Modo de Linguagem (que veremos a seguir), temos tr\u00eas outros seletores, sendo eles, da direita para a esquerda: - Seletor do tipo de quebra de linha - Seletor do tipo de Encoding - Seletor do tipo de Indenta\u00e7\u00e3o (recuo da margem no c\u00f3digo)</p> <p></p> <p>Important</p> <p>O Seletor do Tipo de Linha diz respeito a uma caracter\u00edstia espec\u00edfica na diferen\u00e7a entre os sistemas operacionais baseados em UNIX (Linux, FreeBSD, MacOS, etc) e os sistemas operacionais da Microsoft (Windows 11, Windows 10, etc.)</p> <p>Em sistemas legados, para manter a compatibilidade, a quebra de linha deveria ser CRLF (Carriage Return and Line Feed). Mas hoje em dia, onde a portabilidade acaba sendo prioridade, usar somente LF \u00e9, via de regra, considerado uma boa pr\u00e1tica.</p> <p>Se voc\u00ea quiser saber mais sobre este assunto, o v\u00eddeo a seguir, do Scott Hanselman, da s\u00e9rie Computer Stuff They Didn't Teach You (Coisas de Computador que n\u00e3o te ensinaram\"), fala um pouco mais sobre isto num contexto hist\u00f3rico (em ingl\u00eas).</p> <p></p> <p>Para o tipo de encoding, o UTF8 atualmente \u00e9 usado como padr\u00e3o internacional. Iremos abordar Encoding em algum momento do curso, mas n\u00e3o vamos detalhar isto agora. Por padr\u00e3o, a menos que voc\u00ea esteja lidando com alguma tarefa que exija um tipo de encoding espec\u00edfico, mantenha sempre UTF8 selecionado.</p> <p>No caso da indenta\u00e7\u00e3o, isto orienta o vscode a quantos espa\u00e7os ele precisa exibir sempre que a tecla TAB for pressionada. O seletor tamb\u00e9m permite usar Espa\u00e7os no lugar de Tabs, o que \u00e9 configurado como padr\u00e3o. Ou seja, sempre que voc\u00ea usar a tecla TAB para adicionar um espa\u00e7o, ela ser\u00e1 substitu\u00edda pelo n\u00famero de espa\u00e7os usados no seletor de indenta\u00e7\u00e3o (4 por padr\u00e3o). Voc\u00ea pode mudar isto a qualquer momento, ajustando o seletor para usar TAB em vez de espa\u00e7os.</p>"},{"location":"aulas/03-text-editors/#32-o-editor","title":"3.2 - O Editor","text":"<p>Agora vamos explorar o uso do vscode para o que ele se prop\u00f5e: Editar arquivos.</p> <p>Vamos come\u00e7ar criando um novo arquivo. Isto pode ser feito de diversas formas: - Clicando em New File... na p\u00e1gina de Welcome - Clicando no Menu File, e escolhendo a op\u00e7\u00e3o New Text File - Usando as teclas de atalho Ctrl+N</p> <p>Um novo arquivo, sem t\u00edtulo, ser\u00e1 aberto em uma nova Aba dentro da janela do editor. Um texto \u00e9 exibido como conte\u00fado deste arquivo, dizendo que voc\u00ea pode \"Selecionar uma Linguagem\" (Select a language), \"Preencher um Template\" (fill with template) ou \"Abrir um Editor Diferente\" (open a different editor). Logo abaixo, o texto tamb\u00e9m explica que, se voc\u00ea come\u00e7ar a digitar algum conte\u00fado, esta mensagem ir\u00e1 desaparecer, e voc\u00ea pode tamb\u00e9m optar por n\u00e3o exib\u00ed-la novamente nas pr\u00f3ximas vezes em que criar um novo arquivo (don't show this again).</p> <p></p> <p>Selecionar uma linguagem, significa mudar o modo de linguagem do arquivo no qual estamos trabalhando. \u00c9 poss\u00edvel fazer isto clicando no link do texto, ou tamb\u00e9m no seletor do modo de linguagem, que fica na barra de status (na borda inferior da janela do vscode), \u00e0 direita. Ela come\u00e7a com a op\u00e7\u00e3o \"Plain Text\" selecionada, mas \u00e9 poss\u00edvel mud\u00e1-la clicando sobre ela, e um menu suspenso ser\u00e1 exibido nos permitindo selecionar a linguagem que pretendemos usar. Vamos selecionar \"Shell Script\", que \u00e9 o tipo de arquivo com o qual estamos trabalhando atualmente.</p> <p></p> <p>Note que o \u00edcone exibido ao lado do nome do arquivo, no t\u00edtulo da Aba, mudou, representando que estamos agora editando um arquivo de Shell Script. Voc\u00ea tamb\u00e9m vai notar que, \u00e0 medida que voc\u00ea digita o script no conte\u00fado do arquivo, o vscode, que agora est\u00e1 informado de que estamos editando um arquivo no modo Shell Script, vai formatar o conte\u00fado de acordo com a sintaxe.</p> <p>Podemos, tamb\u00e9m, abrir um dos scripts que j\u00e1 escrevemos na aula anterior. Para fazer isto, temos algumas op\u00e7\u00f5es: - Voltar \u00e0 aba com a p\u00e1gina Welcome e clicar no link \"Open File...\" - Clicar no menu File e selecionar a op\u00e7\u00e3o \"Open File...\" - Usar as teclas de atalho Ctrl+O</p> <p>Em qualquer uma destas formas, uma caixa de di\u00e1logo ser\u00e1 exibida para que voc\u00ea possa selecionar o arquivo que deseja abrir. Selecione o arquivo <code>fancy.sh</code> (que criamos no final da \u00faltima aula) para abr\u00ed-lo.</p> <p>Note que o vscode j\u00e1 identificou o modo de linguagem do arquivo e selecionou \"Shell Script\". Normalmente o vscode tenta fazer isto automaticamente quando abrimos um arquivo, baseado na extens\u00e3o do arquivo aberto. Ou quando salvamos o arquivo em disco (no caso de um arquivo novo), e finalmente atribu\u00edmos uma extens\u00e3o quando lhe damos um nome. Normalmente, ele consegue determinar o modo de linguagem com sucesso. Eventualmente ele pode inferir o modo de linguagem para uma linguagem que ainda n\u00e3o \u00e9 suportada, e pode sugerir que voc\u00ea procure uma extens\u00e3o adequada para instalar o modo de linguagem apropriado.</p> <p>Note</p> <p>Por padr\u00e3o, o vscode suporta JavaScript, TypeScript, HTML, CSS, SCSS e JSON, mas, como veremos adiante, \u00e9 poss\u00edvel instalar suporte \u00e0 in\u00fameras outras linguagens.</p>"},{"location":"aulas/03-text-editors/#321-trabalhando-com-arquivos","title":"3.2.1 - Trabalhando com arquivos","text":"<p>Ao come\u00e7armos a editar o conte\u00fado de um arquivo, \u00e0 medida que alteramos este conte\u00fado, o vscode nos indica que existem altera\u00e7\u00f5es pendentes atrav\u00e9s de um sinal de bullet (um pequeno c\u00edrculo) ao lado do nome do arquivo, no t\u00edtulo da aba.</p> <p></p> <ul> <li> <p>Mover texto</p> <p>\u00c9 muito comum, enquanto estamos codificando, tomarmos decis\u00f5es que envolvem mover c\u00f3digo para reordenar as instru\u00e7\u00f5es que estamos programando. No vscode, uma forma mais f\u00e1cil de fazer este tipo de movimenta\u00e7\u00e3o \u00e9, com o cursor posicionado na linha que gostar\u00edamos de mover, usando Alt mais as setas para cima ou para baixo, de acordo com a dire\u00e7\u00e3o em que queremos mover o texto.</p> <p>Funciona tamb\u00e9m com m\u00faltiplas linhas do texto, contanto que voc\u00ea as selecione antes de mov\u00ea-las.</p> </li> <li> <p>Copiar texto</p> <p>Da mesma forma que o vscode facilita que possamos mover o texto pelas linhas, para cima ou para baixo, podemos tamb\u00e9m copiar o conte\u00fado da linha onde o cursor est\u00e1 posicionado usando as teclas Shift+Alt e a dire\u00e7\u00e3o para onde queremos que a duplica\u00e7\u00e3o seja feita, para cima ou para baixo.</p> </li> <li> <p>Cursores</p> <p>N\u00e3o \u00e9 raro que, enquanto estamos trabalhando com c\u00f3digo, nos deparamos com algumas situa\u00e7\u00f5es em que precisamos aplicar altera\u00e7\u00f5es semelhantes em diversas linhas ou diversos lugares do c\u00f3digo. O vscode suporta m\u00faltiplos cursores, o que significa que podemos posicionar diversos cursores de edi\u00e7\u00e3o em lugares distintos do c\u00f3digo, e edit\u00e1-los simultaneamente.</p> <p>\u00c9 poss\u00edvel espalhar cursores diferentes pressionando a tecla Alt e posicionando-os com o mouse, clicando em cada um dos lugares em que queremos um novo cursor.</p> <p></p> <p>Podemos fazer isto tamb\u00e9m, usando as teclas Ctrl+Alt e usando as setas para cima ou para baixo para criar novos cursores na mesma posi\u00e7\u00e3o nas linhas de cima ou de baixo, de acordo com a dire\u00e7\u00e3o selecionada.</p> <p></p> <p>Uma vez posicionados, os cursores ir\u00e3o receber tudo o que voc\u00ea digitar, como se estivesse editando um por um, mas far\u00e3o isto simultaneamente, o que torna isto uma forma mais produtiva de fazer este tipo de edi\u00e7\u00e3o.</p> </li> <li> <p>Sele\u00e7\u00e3o de coluna</p> <p>Quando trabalhamos com dados tabulados em colunas, ou simplesmente quando precisamos selecionar uma \u00e1rea do texto considerando um alinhamento vertical no texto, sem selecionarmos o restante do conte\u00fado pelas linhas em que queremos trabalhar, usamos a combina\u00e7\u00e3o Shift+Ctrl+Alt para fazer a sele\u00e7\u00e3o de colunas.</p> <p></p> <p>Isto facilita a edi\u00e7\u00e3o, n\u00e3o apenas para excluir colunas indesejadas, como tamb\u00e9m para edit\u00e1-las de uma \u00fanica vez (usando a funcionalidade dos m\u00faltiplos cursores).</p> </li> <li> <p>Busca/Substitui\u00e7\u00e3o</p> <p>Com certa frequ\u00eancia, precisamos encontrar uma ou diversas ocurr\u00eancias de certos termos no texto, seja para fazer refer\u00eancias a estes pontos espec\u00edficos ou para fazer ajustes tardios.</p> <p>Para fazer uma busca por termos no conte\u00fado do arquivo aberto no editor atual, podemos acionar o Menu Edit e clicar em Find, ou usar o atalho Ctrl+F.</p> <p></p> <p>Entre as op\u00e7\u00f5es de busca podemos ajustar: - <code>Match Case</code>: Combina\u00e7\u00e3o de Mai\u00fasculas e min\u00fasculas, indica se o texto procurado precisa corresponder ou n\u00e3o \u00e0 caixa do texto. - <code>Match Whole Word</code>: Combina\u00e7\u00e3o de palavras inteiras, encontra correspond\u00eancias apenas em palavras completas - <code>Use Regular Expression</code>: Combina\u00e7\u00e3o de Express\u00f5es Regulares, \u00e9 um mecanismo de busca mais avan\u00e7ado usando RegEx, algo que veremos mais pra frente neste curso.</p> <p>Para fazer substitui\u00e7\u00f5es, podemos acionar o Menu Edit e clicar em Replace, ou usar o atalho Ctrl+H.</p> <p></p> <p>As op\u00e7\u00f5es s\u00e3o bastante semelhantes \u00e0s op\u00e7\u00f5es dispon\u00edveis na busca, mas apresenta uma segunda caixa de texto para entrar com o novo texto que ser\u00e1 usado para substituir o termo buscado, e duas novas op\u00e7\u00f5es s\u00e3o apresentadas:</p> <ul> <li><code>Replace</code>: Aplica a substitui\u00e7\u00e3o na ocorr\u00eancia selecionada (e automaticamente move para a pr\u00f3xima ocorr\u00eancia)</li> <li><code>Replace All</code>: Aplica a substitui\u00e7\u00e3o em todas as ocorr\u00eancias</li> </ul> <p>Outra forma r\u00e1pida para buscar e editar m\u00faltiplas ocorr\u00eancias de texto \u00e9 selecionando o texto desejado e pressionando Ctrl+D. Ele vai selecionar a pr\u00f3xima ocorr\u00eancia do termo selecionado e manter o cursor em ambas. Pressionar Ctrl+D novamente vai fazer o mesmo para a pr\u00f3xima ocorr\u00eancia, e assim sucessivamente, para todas as ocorr\u00eancias que voc\u00ea desejar editar.</p> </li> <li> <p>Salvamento e Restaura\u00e7\u00e3o de Arquivos</p> <p>O vscode precisa de uma a\u00e7\u00e3o deliberada do usu\u00e1rio para salvar os arquivos: - Atrav\u00e9s do menu File, na op\u00e7\u00e3o Save (ou Ctrl+S) para salvar o arquivo que est\u00e1 sendo editado na aba selecionada - Atrav\u00e9s do menu File, na op\u00e7\u00e3o Save All (ou Ctrl+K S) para salvar todos os arquivos abertos</p> <p>Mas existe uma funcionalidade de Salvamento Autom\u00e1tico dispon\u00edvel, que fica desligada como padr\u00e3o. Para ajust\u00e1-la, caso seja do seu interesse, basta entrar em Settings e buscar por <code>Auto Save</code>. Ela suporta os seguintes valores: - <code>off</code>: desligado (valor padr\u00e3o) - <code>afterDelay</code>: Salva o arquivo depois que se passa um tempo (1000 milissegundos por padr\u00e3o), para ajustar este valor, existe outra configura\u00e7\u00e3o chamada Files: Auto Save Delay - <code>onFocusChange</code>: Salva o arquivo sempre que voc\u00ea mover para outro editor (outra Aba) - <code>onWindowsChange</code>: Salva o arquivo sempre que voc\u00ea mover para outra janela para fora da inst\u00e2ncia atual do vscode</p> <p>Independente disto, quando fechado, o vscode guarda as altera\u00e7\u00f5es pendentes nos arquivos abertos de forma que, quando voc\u00ea abre novamente o editor, ele recupera as altera\u00e7\u00f5es n\u00e3o salvas do arquivo, permitindo que voc\u00ea decida se quer mant\u00ea-las ou descart\u00e1-las mesmo depois de t\u00ea-lo fechado.</p> </li> </ul> <p></p> <ul> <li> <p>Prevenindo Escritas \"Sujas\" (Dirty Writes)</p> <p>O vscode \u00e9 capaz de detectar se, durante a edi\u00e7\u00e3o do arquivo, seu conte\u00fado tiver alterado no disco, e vai te avisar disto exibindo uma mensagem de erro quando voc\u00ea tentar salvar o arquivo por cima da vers\u00e3o alterada.</p> <p></p> <p>Se voc\u00ea quiser ignorar as altera\u00e7\u00f5es que foram feitas fora do editor, e simplesmente salvar as suas altera\u00e7\u00f5es, voc\u00ea consegue fazer isto clicando no bot\u00e3o Overwrite. Se quiser, no entanto, tomar o cuidado de conferir as altera\u00e7\u00f5es, voc\u00ea pode clicar em Compare. Isto ir\u00e1 abrir o editor de diff do vscode, que mostra as diferen\u00e7as entre os arquivos e te permite navegar por elas para decidir o que pretende fazer.</p> <p></p> <p></p> <p>Uma vez resolvidos conflitos gerados por causa das diferen\u00e7as, o arquivo \u00e9 salvo e o editor diff \u00e9 fechado.</p> </li> <li> <p>Rolagem</p> <p>No vscode, voc\u00ea pode exibir um minimapa do c\u00f3digo no lugar da barra de rolagem. Para algumas pessoas, esta pode ser uma forma conveniente de ter uma visualiza\u00e7\u00e3o do arquivo de texto em miniatura, e ter uma ideia geral de como ele est\u00e1 ficando. Para isto, basta entrar em Settings, na barra de busca digitiar <code>minimap</code> e marcar a caixa de sele\u00e7\u00e3o com o texto <code>Editor: Minimap &gt; Enabled</code>. Al\u00e9m disso, existem diversas op\u00e7\u00f5es quer personalizam a forma como o minimapa \u00e9 exibido.</p> <p></p> <p>Independente de voc\u00ea usar o Minimapa ou a barra de rolagem convencional, voc\u00ea tamb\u00e9m pode rolar pelo texto usando o bot\u00e3o do meio do mouse (Scroll) pressionando a tecla Alt, ele aumentar\u00e1 drasticamente a velocidade da navega\u00e7\u00e3o.</p> </li> </ul>"},{"location":"aulas/03-text-editors/#322-abas","title":"3.2.2 - Abas","text":"<p>Assim com funciona nos browsers modernos, o vscode suporta abrir diversos arquivos em Abas diferentes (sim, o tio \u00e9 velho o suficiente pra saber que, antigamente, os browsers n\u00e3o tinham Abas e era comum ter que lidar com dezenas de janelas abertas em vez de dezenas de abas). A capacidade de manter diversos buffers abertos para manipular um n\u00famero de arquivos simultaneamente n\u00e3o \u00e9, obviamente, uma exclusividade do vscode. Diversos outros editores, como o Atom e o Sublime possuem a mesma funcionalidade, enquanto que editores de terminal, como o Emacs e o Vim, oferecem a mesma capacidade atrav\u00e9s de outros meios.</p> <p></p> <p>No vscode, as Abas mostram o nome do arquivo, um \u00edcone representando em que modo de linguagem ele est\u00e1 sendo usado, e um bot\u00e3o que te permite fechar aquela Aba facilmente, tamb\u00e9m poss\u00edvel atrav\u00e9s do atalho Ctrl+F4.</p> <p>Ao clicar com o bot\u00e3o direito do mouse em uma determinada Aba, diversas op\u00e7\u00f5es se tornam dispon\u00edveis. Vamos tentar destacar as principais: - Fechamento de Abas     - Close others: Fecha todas as outras Abas exceto a Aba que recebeu o clique     - Close to the Right: Fecha todas as Abas \u00e0 direita dela     - Close Saved: Fecha todas as Abas que est\u00e3o salvas - Pin: Fixa a Aba selecionada, n\u00e3o aplicando sobre ela os comandos que fecham as outras abas. - Op\u00e7\u00f5es de divis\u00e3o de pain\u00e9is do editor (Split)     - Split Up: Divide o editor atual em um novo painel acima     - Split Down: Divide o editor atual em um novo painel abaixo     - Split Left: Divide o editor em um novo painel \u00e0 esquerda     - Split Right: Divide o editor em um novo painel \u00e0 direita</p> <p>A seguir, vamos discutir melhor o que s\u00e3o os pain\u00e9is do editor.</p>"},{"location":"aulas/03-text-editors/#323-paineis-do-editor","title":"3.2.3 - Pain\u00e9is do Editor","text":"<p>Um editor (entenda isto como uma Aba editando um arquivo) pode ser dividido em pain\u00e9is, como destacamos nas op\u00e7\u00f5es do menu suspenso quando clicamos com o bot\u00e3o direito no t\u00edtulo da Aba. Pain\u00e9is do Editor nos permitem criar formas de navegar pelo conte\u00fado do arquivo que estamos editando, ao mesmo tempo que mantemos o cursor na posi\u00e7\u00e3o em que queremos fazer uma edi\u00e7\u00e3o, sem deixar de visualizar o que estamos digitando.</p> <p></p> <p>O tipo mais comum de pain\u00e9is de editor \u00e9 criar um painel \u00e0 direita (como na imagem acima). Isto pode ser feito no menu suspenso da Aba, ou atrav\u00e9s do atalho Ctrl+K e, logo em seguida, Ctrl+Shift+] (este atalho cria um painel \u00e0 direita em grupo, ou seja, na mesma aba). Mas os outros tipos de pain\u00e9is tamb\u00e9m est\u00e3o dispon\u00edveis, como vimos nas op\u00e7\u00f5es do menu.</p>"},{"location":"aulas/03-text-editors/#324-navegacao","title":"3.2.4 - Navega\u00e7\u00e3o","text":"<p>O vscode suporta diversas funcionalidades de navega\u00e7\u00e3o que podem ser convenientes. Vamos falar agora de algumas delas dispon\u00edveis no Menu Go.</p> <ul> <li><code>Back</code>: Posiciona o cursor de volta onde estava posicionado anteriormente de acordo com o hist\u00f3rico de posi\u00e7\u00f5es (Ctrl+Seta Esquerda)</li> <li><code>Forward</code>: Semelhantemente ao anterior, faz o cursor ser posicionado avan\u00e7ando no hist\u00f3rico de posi\u00e7\u00f5es (Ctrl+Seta Direita)</li> <li><code>Switch Editor &gt; Next Editor</code>: Avan\u00e7a para o editor que est\u00e1 na Aba \u00e0 direita (Ctrl+Page Down)</li> <li><code>Switch Editor &gt; Previous Editor</code>: Avan\u00e7a para o editor que est\u00e1 na Aba \u00e0 esquerda (Ctrl+Page Up)</li> <li><code>Go to Line/Column...</code>: Posiciona o cursor em uma linha/coluna espec\u00edficas (Ctrl+G). A nota\u00e7\u00e3o \u00e9 <code>:&lt;n\u00famero-da-linha&gt;[:&lt;n\u00famero-da-coluna&gt;]</code> (os colchetes <code>[</code> e <code>]</code> indica que o n\u00famero da coluna \u00e9 opcional)</li> <li><code>Go to Bracket</code>: Posiciona o cursor no fechamento do grupo atual (colchetes, par\u00eanteses, chaves, markups, etc). O atalho para este comando \u00e9 Ctrl+Shift+].</li> </ul>"},{"location":"aulas/03-text-editors/#325-formatacao","title":"3.2.5 - Formata\u00e7\u00e3o","text":"<p>Diversas linguagens possuem padr\u00f5es pr\u00f3prios de formata\u00e7\u00e3o. A forma como as linhas de c\u00f3digo s\u00e3o organizadas, e certos estilos est\u00e9ticos que s\u00e3o definidos pela comunidade que as mant\u00e9m.</p> <p>O vscode possui um comando para formatar o c\u00f3digo do editor, dispon\u00edvel na Paleta de Comandos pelo atalho Ctrl+Shift+P, e buscando pelo comando Format Document, ou pelo atalho Shift+Alt+F.</p> <p>Para formatar um documento qualquer, o vscode precisa ter informa\u00e7\u00f5es de qual o formatador capaz de fazer a tarefa. Para isto, uma extens\u00e3o contendo o devido formatador pode ser necess\u00e1ria. Para o caso de Python, eu usei a extens\u00e3o Black Formatter.</p> <p>Sem um formatador dispon\u00edvel, o vscode n\u00e3o \u00e9 capaz de realizar a formata\u00e7\u00e3o.</p> <p>Observe os efeitos da formata\u00e7\u00e3o no arquivo <code>newton.py</code> quando usamos o Black Formatter.</p>"},{"location":"aulas/03-text-editors/#33-extensoes","title":"3.3 - Extens\u00f5es","text":"<p>O vscode tem suporte \u00e0 extens\u00f5es, e possui um reposit\u00f3rio com in\u00fameras extens\u00f5es \u00fateis para serem instaladas. Elas podem simplificar bastante o nosso trabalho de diversas formas, criando novas teclas de atalho, auxiliando na legibilidade do c\u00f3digo atrav\u00e9s do uso de cores e padr\u00f5es de formata\u00e7\u00e3o, e at\u00e9 mesmo trazendo para dentro da ferramenta funcionalidades completamente novas.</p> <p>Por exemplo, se fizermos uma busca por <code>bash</code>, veremos quantas extens\u00f5es dispon\u00edveis podem ser usadas para, de alguma forma, facilitar a vida de quem trabalha Shell Scripts em Bash.</p> <p></p> <p>Ao longo deste curso, iremos recomendar extens\u00f5es que podem ser usadas para facilitar certos aspectos do uso do vscode. Por ora, fique \u00e0 vontade para navegar pelas extens\u00f5es e, se achar alguma \u00fatil, tente experiment\u00e1-la.</p>"},{"location":"aulas/03-text-editors/#34-trabalhando-com-codigo","title":"3.4 - Trabalhando com C\u00f3digo","text":"<p>Vamos agora discutir um pouco sobre o uso do vscode com c\u00f3digo, no dia-a-dia de pessoas que trabalham com programa\u00e7\u00e3o de software ou scripts de automa\u00e7\u00e3o. Para isto iremos usar um programa de exemplo em Python que usa o m\u00e9todo de Newton para calcular a raiz quadrada de um n\u00famero.</p> <p>Warning</p> <p>Se voc\u00ea n\u00e3o conhece Python, ou n\u00e3o entende sobre programa\u00e7\u00e3o, tenha em mente que os exemplos usados aqui tem um car\u00e1ter meramente ilustrativo para facilitar a compreens\u00e3o do uso do vscode.</p> <p>Contudo, se voc\u00ea quiser acompanhar os exemplos em seu dispositivo, voc\u00ea vai precisar ter instalado um interpretador de Python.</p> <p>Acesse este link para instru\u00e7\u00f5es de como instalar o Interpretador Python no Windows, ou este link para instalar no linux. Para usu\u00e1rios do MacOs, este link fornece as instru\u00e7\u00f5es necess\u00e1rias.</p> <p>Note</p> <p>O exemplo a seguir foi extra\u00eddo do livro Structure and Interpretation of Computer Programs, de Hal Abelson, Jerry Sussman e Julie Sussman, pela MIT Press.</p> <p>No livro, os autores implementam o c\u00f3digo usando a linguagem LISP. Aqui, usaremos Python.</p>"},{"location":"aulas/03-text-editors/#341-instalando-suporte-a-linguagem","title":"3.4.1 - Instalando suporte \u00e0 linguagem","text":"<p>A primeira coisa que iremos fazer para trabalhar com uma linguagem no vscode, \u00e9 procurar uma extens\u00e3o que instale o suporte a esta linguagem no editor.</p> <p>Para isto, vamos abrir o Painel de Extens\u00f5es do vscode atrav\u00e9s do atalho Ctrl+Shift+X, e digitar <code>Python</code> no campo de busca.</p> <p></p> <p>Note como existem in\u00fameras extens\u00f5es que auxiliam o uso de Python no resultado da busca. Para os fins deste curso, irei instalar o suporte oficial da Microsoft, que \u00e9 a extens\u00e3o mais baixada. Ela tamb\u00e9m instala duas outras extens\u00f5es como parte de suas depend\u00eancias: - <code>Pylance</code> (para suporte do IntelliSense) - <code>Python Debugger</code>(para suporte ao Depurador)</p> <p>A extens\u00e3o Python da Microsoft, instala alguns comandos \u00fateis, como, por exemplo, Iniciar um Terminal REPL de Python: 1. Entre na Paleta de Comandos com Ctrl+Shift+P 2. Digite <code>Python</code> para listar todos os comandos que a extens\u00e3o adicionou 3. Procure o comando <code>Python: Start Terminal REPL</code> 4. Clique no comando para ver o Terminal REPL ser iniciado</p> <p>Note</p> <p>Um Terminal REPL \u00e9 uma ferramenta dispon\u00edvel em Python (e em algumas outras linguagens) que criam uma experi\u00eancia de Shell para usar a linguagem no terminal.</p> <p>REPL \u00e9 a sigla para Read-Eval-Print Loop, que significa uma repeti\u00e7\u00e3o do processo de Ler-&gt;Interpretar-&gt;Imprimir do interpretador de uma linguagem.</p> <p>Por exemplo, se voc\u00ea digitar no REPL a express\u00e3o <code>1 + 1</code> e pressionar Enter, o terminal executar\u00e1 a leitura do texto digitado, far\u00e1 a interpreta\u00e7\u00e3o de acordo com a linguagem Python, e imprimir\u00e1 o resultado. Depois disto, ele habilitar\u00e1 o terminal para que uma nova express\u00e3o seja digitada, e executar\u00e1 tudo novamente.</p> <p>Para sair do REPL, basta digitar <code>quit()</code> e pressionar Enter</p>"},{"location":"aulas/03-text-editors/#342-codificando-no-vscode","title":"3.4.2 - Codificando no vscode","text":"<p>Para criar um pequeno programa em Python, vamos criar um novo arquivo e salv\u00e1-lo como <code>newton.py</code>. Ao criar o arquivo e ter ele aberto no seu editor, olhe barra de status e observe o Modo de Linguagem selecionado (Python). Isto se deve ao fato de termos associado a extens\u00e3o <code>.py</code> ao nome do arquivo, fazendo o vscode atribuir automaticamente o modo de linguagem correspondente. Logo ao lado do seletor do Modo de Linguagem, h\u00e1 tamb\u00e9m o seletor do interpretador da linguagem e o seletor de configura\u00e7\u00f5es de An\u00e1lise da linguagem, instalado pela extens\u00e3o Pylance.</p> <p></p> <p>Podemos come\u00e7ar a digitar c\u00f3digo no nosso arquivo. O primeiro passo, seguindo o exemplo do livro, \u00e9 criar uma fun\u00e7\u00e3o  chamada <code>sqrt-iter</code>.</p> <pre><code>def sqrt-iter(guess, x):\n    if good_enough(guess, x):\n        return guess\n    else:\n        return sqrt_iter(improve(guess, x), x)\n</code></pre> <p>Note como, \u00e0 medida que digitamos o c\u00f3digo, os termos que digitamos recebem diferentes cores, que s\u00e3o usadas de acordo com o uso da sintaxe da linguagem. Esta funcionalidade \u00e9 chamada de Syntax Highlight, basicamente se baseia em usar as regras de sintaxe da linguagem para associar um c\u00f3digo de cores baseado nelas.</p> <p></p> <p>Observe como o c\u00f3digo que digitamos possui diversas marca\u00e7\u00f5es em vermelho e amarelo. S\u00e3o problemas que o suporte \u00e0 linguagem Python identificou no c\u00f3digo que digitamos. Podemos compreender melhor os problemas de diversas formas:</p> <ul> <li>Posicionando o mouse sobre uma das \u00e1reas marcadas, e uma caixa flutuante ser\u00e1 exibida descrevendo o problema</li> <li>Abrindo o painel Problems, atrav\u00e9s do atalho Ctrl+Shift+M</li> <li>Navegando pelos problemas usando o atalho F8 para ir para o pr\u00f3ximo problema, e Shift+F8 para voltar para o problema anterior.</li> </ul> <p>As marca\u00e7\u00f5es em vermelho representam Errors (erros), enquanto que as marca\u00e7\u00f5es em amarelo representam Warnings (avisos). \u00c9 poss\u00edvel ter um relat\u00f3rio de erros e avisos na barra de status do vscode, no grupo \u00e0 esquerda. O n\u00famero de erros \u00e9 representado por um \u00edcone com a letra <code>x</code>, enquanto que o n\u00famero de avisos \u00e9 representado por um \u00edcone com o ponto-de-exclama\u00e7\u00e3o.</p> <p></p> <p>Ao clicar neste relat\u00f3rio, o Painel Problems ser\u00e1 aberto. Ele tamb\u00e9m pode ser aberto atrav\u00e9s do atalho Ctrl+Shift+M. Este painel exibe todos os problemas encontrados no c\u00f3digo: erros e avisos, usando o mesmo c\u00f3digo de cores: vermelho para erros e amarelos para avisos. Ao clicar em qualquer um dos problemas, ele posiciona o cursor do editor no c\u00f3digo onde o problema est\u00e1 sendo reportado.</p> <p>O primeiro problema encontra-se no nome da fun\u00e7\u00e3o. Existe um erro aqui, e a extens\u00e3o Pylance diz que era esperado <code>(</code> (uma abertura de par\u00eanteses) no lugar onde est\u00e1 o caractere <code>-</code> (tra\u00e7o). Isso ocorre por que, em Python, quando definimos um nome para uma fun\u00e7\u00e3o, ele aceita apenas letras, n\u00fameros e o caractere <code>_</code>. O tra\u00e7o n\u00e3o \u00e9 um caractere v\u00e1lido. Ent\u00e3o vamos substitu\u00ed-lo pelo <code>_</code>.</p> <p>Note como, s\u00f3 por fazer esta corre\u00e7\u00e3o, diversos outros problemas foram corrigidos, sobrando apenas agora 2 avisos relacionados \u00e0s chamadas para as fun\u00e7\u00f5es <code>good_enough</code> e <code>improve</code>. O problema \u00e9 que elas ainda n\u00e3o existem, ent\u00e3o precisamos implement\u00e1-las.</p> <pre><code>def good_enough(guess, x):\n    return abs((guess * guess) - x) &lt; 0.001\n\n\ndef improve(guess, x):\n    return average(guess, x / guess)\n</code></pre> <p>Note agora que, ambos os avisos n\u00e3o existem mais, mas um novo aviso passou a existir nos apontando a chamada da fun\u00e7\u00e3o <code>average</code>, que ainda n\u00e3o existe. A chamada para a fun\u00e7\u00e3o <code>abs</code> n\u00e3o foi marcada por que ela existe, estamos usando uma fun\u00e7\u00e3o pronta fornecida pelo interpretador da linguagem Python.</p> <p>Seguindo o livro, implementemos a fun\u00e7\u00e3o <code>average</code>:</p> <pre><code>def average(x, y):\n    return (x + y) / 2\n</code></pre> <p>Por fim, para facilitar o uso da fun\u00e7\u00e3o iterativa <code>sqrt_iter</code>, o livro prop\u00f5e a defini\u00e7\u00e3o de uma \u00faltima fun\u00e7\u00e3o chamada <code>sqrt</code>, que abstrai a chamada inicial da fun\u00e7\u00e3o <code>sqrt_iter</code>, passando como primeiro palpite o valor <code>1.0</code>.</p> <pre><code>def sqrt(x):\n    return sqrt_iter(1.0, x)\n</code></pre> <p>Agora, tudo o que precisamos fazer no nosso programa \u00e9 usar as fun\u00e7\u00f5es que criamos, a partir da chamada \u00e0 fun\u00e7\u00e3o <code>sqrt</code> passando como argumento um n\u00famero para o qual queiramos obter a raiz quadrada:</p> <pre><code>print(sqrt(2.0))\n</code></pre> <ul> <li> <p>Coment\u00e1rios</p> <p>Uma das conveni\u00eancias de usar um editor adequado quando estamos trabalhando com c\u00f3digo, \u00e9 que ele suporta algumas tarefas comuns, como por exemplo, transformar uma linha de c\u00f3digo em um coment\u00e1rio no formato adequado para o Modo de Linguagem que estamos usando. No vscode, o comando para comentarmos uma linha do c\u00f3digo (ou remover o coment\u00e1rio dela) \u00e9 atrav\u00e9s do atalho Ctrl+;, ou no menu Edit, na op\u00e7\u00e3o Toggle Line Comment. Tamb\u00e9m existe a op\u00e7\u00e3o de comentar/remover coment\u00e1rio em blocos, para linguagens que suportam blocos de coment\u00e1rio.</p> </li> </ul>"},{"location":"aulas/03-text-editors/#343-execucao-de-codigo","title":"3.4.3 - Execu\u00e7\u00e3o de c\u00f3digo","text":"<p>Para executarmos o c\u00f3digo, podemos usar o Depurador (Debug) do vscode, que pode ser aberto atrav\u00e9s do atalho Ctrl+Shift+D. Nele podemos clicar no bot\u00e3o Run and Debug.</p> <p>Ao clicar pela primeira vez em Run and Debug, um menu suspenso ser\u00e1 aberto perguntando em que contexto voc\u00ea deseja usar o depurador. Isto se d\u00e1 por que podemos usar o vscode em um projeto completo de desenvolvimento (com in\u00fameros arquivos de c\u00f3digo). Para este exerc\u00edcio, basta optarmos por Run Python File.</p> <p></p> <p>O depurador ir\u00e1 abrir um terminal chamado <code>Python Debug Console</code>, onde o programa ser\u00e1 executado e o valor resultante da chamada da fun\u00e7\u00e3o <code>sqrt</code> ser\u00e1 impressa.</p> <p></p> <p>Pode-se iniciar uma execu\u00e7\u00e3o atrav\u00e9s do atalho F5. N\u00f3s iremos explorar melhor as capacidades de depura\u00e7\u00e3o do vscode em uma aula futura dedicada \u00e0 Debugging e Profiling.</p>"},{"location":"aulas/03-text-editors/#344-navegacao-do-codigo","title":"3.4.4 - Navega\u00e7\u00e3o do c\u00f3digo","text":"<p>O vscode possui capacidades de navega\u00e7\u00e3o espec\u00edficas para serem usadas quando estamos trabalhando com c\u00f3digo. Ao clicar com o bot\u00e3o direito do mouse no nome de algum artefato de c\u00f3digo, algumas op\u00e7\u00f5es de navega\u00e7\u00e3o ser\u00e3o exibidas no menu suspenso: - Go to Definition: Navega at\u00e9 o c\u00f3digo em que este artefato foi definido - Go to Declaration: Navega at\u00e9 o c\u00f3digo em que este artefato foi declarado (em Python o efeito \u00e9 o mesmo, mas existem linguagens que distinguem a declara\u00e7\u00e3o da defini\u00e7\u00e3o) - Go to Type Definition: Para linguagens que suportam um sistema de tipos, navega at\u00e9 a defini\u00e7\u00e3o de um tipo - Go to References: Navega pelas refer\u00eancias ao artefato (os lugares no c\u00f3digo onde ele \u00e9 usado)</p> <p>Existem dois atalhos \u00fateis:     - F12: \u00e9 a tecla de atalho para a navega\u00e7\u00e3o Go to Definition     - Shift+F12: s\u00e3o as teclas de atalho para a navega\u00e7\u00e3o Go to References</p> <ul> <li>Peek</li> </ul> <p>\u00c0s vezes, voc\u00ea s\u00f3 quer ter uma ideia de como os artefatos foram definidos ou est\u00e3o sendo usados, sem necessariamente navegar pelo c\u00f3digo. Peek \u00e9 uma forma de espiar os trechos de c\u00f3digo onde tais coisas acontecem, sem navegar at\u00e9 eles, mantendo o cursor na posi\u00e7\u00e3o atual. Para isto, o vscode exibe uma caixa flutuante onde o c\u00f3digo correspondente \u00e9 exibido.</p> <p>Para us\u00e1-lo, em vez de acessar as op\u00e7\u00f5es de navega\u00e7\u00e3o no menu suspenso, escolha o submenu Peek e a op\u00e7\u00e3o desejada: Peek Definition ou Peek References.</p> <p>O atalho Alt+f12 executa o Peek Definition</p> <ul> <li>Outline O Outline \u00e9 uma forma de visualizar as estruturas de c\u00f3digo presentes no arquivo e navegar por elas. O Outline fica na mesma janela do Explorer, abaixo, ou pode ser visto atrav\u00e9s do atalho Ctrl+Shift+O.</li> </ul> <p></p>"},{"location":"aulas/03-text-editors/#345-refatoracao-de-codigo","title":"3.4.5 - Refatora\u00e7\u00e3o de c\u00f3digo","text":"<p>Dentre as capacidades com c\u00f3digo do vscode, existem op\u00e7\u00f5es de refatora\u00e7\u00e3o dispon\u00edveis. Por exemplo, renomear um artefato (atualizando todas as refer\u00eancias a ele com o novo nome), mover um artefato para outro arquivo, transformar uma express\u00e3o em vari\u00e1vel ou extrair um novo m\u00e9todo a partir de um trecho de c\u00f3digo, al\u00e9m de outras capacidades dispon\u00edveis de acordo com a linguagem.</p> <ul> <li>Renomear: para renomear um artefato (vari\u00e1vel, fun\u00e7\u00e3o, etc), basta posicionar o cursor sobre o seu nome e pressionar F2. Uma caixa de texto ser\u00e1 exibida para que voc\u00ea possa entrar com o novo nome e, ao pressionar Enter, ele aplicar\u00e1 o novo nome para todas as refer\u00eancias conhecidas.</li> <li>Extrair Vari\u00e1vel: para transformar uma express\u00e3o em uma vari\u00e1vel, voc\u00ea pode selecionar a express\u00e3o desejada e pressionar Ctrl+Shift+R e, no menu suspenso, escolher Extract Variable. Ao digitar o nome da vari\u00e1vel, o vscode far\u00e1 a refatora\u00e7\u00e3o adequada.</li> <li>Extrair M\u00e9todo: Extrair M\u00e9todo, de forma semelhante \u00e0 Extrair Vari\u00e1vel, baseado em uma express\u00e3o selecionada, a transforma em uma chamada de fun\u00e7\u00e3o, para onde ele a move. Para isto, basta usar o atalho de refatora\u00e7\u00e3o Ctrl+Shift+R e clicar em Extract Method.</li> </ul>"},{"location":"aulas/03-text-editors/#346-intellisense","title":"3.4.6 - Intellisense","text":"<p>O IntelliSense \u00e9 um conjunto de capacidades do vscode que interagem com o usu\u00e1rio ao trabalhar com c\u00f3digo. Estas capacidades s\u00e3o principalmente: - Auto completar: \u00e0 medida que se digita o c\u00f3digo, o IntelliSense d\u00e1 sugest\u00f5es sobre poss\u00edveis formas de completar a express\u00e3o baseadas no que est\u00e1 sendo digitado e nos artefatos que existem dispon\u00edveis no c\u00f3digo. - Informa\u00e7\u00f5es R\u00e1pidas e Detalhes sobre Par\u00e2metros: Quando se digita uma chamada para uma fun\u00e7\u00e3o, o IntelliSense \u00e9 capaz de obter informa\u00e7\u00f5es sobre a fun\u00e7\u00e3o e seus par\u00e2metros e exib\u00ed-las, durante a digita\u00e7\u00e3o, para que o usu\u00e1rio possa entender como preench\u00ea-los. - Lista de Membros: O IntelliSense tamb\u00e9m verifica os membros de classes, structs, etc, e exibe informa\u00e7\u00f5es durante a codifica\u00e7\u00e3o para te ajudar a preench\u00ea-las.</p>"},{"location":"aulas/03-text-editors/#347-snippets","title":"3.4.7 - Snippets","text":"<p>Snippets s\u00e3o templates para pequenos trechos de c\u00f3digo que o vscode mant\u00e9m dispon\u00edveis para facilitar a digita\u00e7\u00e3o de certas estruturas enquanto estamos codificando.</p> <p>Por exemplo, quando queremos usar alguma estrutura de controle, criar uma fun\u00e7\u00e3o, ou uma classe, pode ser que existam snippets dipon\u00edveis para isto, ou podem haver extens\u00f5es que os disponibilizem.</p> <p>Alguns snippets s\u00e3o exibidos pelo IntelliSense, \u00e0 medida que voc\u00ea digita c\u00f3digo. Mas \u00e9 poss\u00edvel, tamb\u00e9m acessar snippets a partir da Paleta de Comandos usando Ctrl+Shift+P e buscando pelo comando <code>Snippets: Insert Snippet</code>.</p> <p>Voc\u00ea tamb\u00e9m pode criar seus pr\u00f3prios Snippets, usando a Paleta de Comandos e buscando pelo comando <code>Snippets: Configure Snippets</code>. A cria\u00e7\u00e3o de snippets est\u00e1 fora do escopo deste curso, mas voc\u00ea pode consultar a documenta\u00e7\u00e3o oficial do vscode para obter instru\u00e7\u00f5es de como faz\u00ea-lo.</p>"},{"location":"aulas/03-text-editors/#35-trabalhando-com-diretorios","title":"3.5 - Trabalhando com Diret\u00f3rios","text":"<p>Um dos maiores benef\u00edcios de usar um editor de c\u00f3digo \u00e9 que ele suporta abrir espa\u00e7os de trabalho baseados em uma hierarquia de diret\u00f3rios. E o vscode suporta esta funcionalidade. Voc\u00ea pode abrir um diret\u00f3rio a partir do Menu File, na op\u00e7\u00e3o <code>Open Folder...</code>, ou usando o atalho Ctrl+K e, logo em seguida Ctrl+O. Mas, o mais comum para quem trabalha a partir do shell, \u00e9 usar o CLI do vscode para abrir o editor e trabalhar no diret\u00f3rio. Para isto, basta usar o nome do ditet\u00f3rio como argumento:</p> <pre><code>code foo # abre o vscode com o diret\u00f3rio `foo`\n</code></pre> <p>O mais comum \u00e9 chamar o code j\u00e1 a partir do diret\u00f3rio em que se est\u00e1 trabalhando:</p> <pre><code>code .\n</code></pre> <p>A partir do momento em que se trabalha num ambiente de diret\u00f3rio, todos os arquivos com os quais trabalhamos s\u00e3o tratados usando o diret\u00f3rio aberto como refer\u00eancia. Podemos criar diret\u00f3rios e posicionar arquivos em qualquer lugar da hierarquia.</p> <p>A primeira funcionalidade \u00fatil que podemos verificar usando o modo de trabalho em diret\u00f3rio \u00e9 o Explorer, uma visualiza\u00e7\u00e3o da hierarquia de diret\u00f3rios a partir do diret\u00f3rio aberto, normalmente situado na Barra Lateral, \u00e0 esquerda. Se o Explorer n\u00e3o estiver vis\u00edvel pra voc\u00ea neste momento, voc\u00ea pode abr\u00ed-lo usando o atalho Ctrl+Shift+E, ou acessando o menu View e clicando na op\u00e7\u00e3o Explorer.</p> <p></p> <p>Voc\u00ea pode abrir novos arquivos atrav\u00e9s do explorer, ou atrav\u00e9s do atalho Ctrl+P, que abrir\u00e1 um menu suspenso onde voc\u00ea pode selecionar entre os arquivos listados ou digitar o nome do arquivo que voc\u00ea pretende abrir.</p> <p>Outra vantagem de usar o modo de trabalho em diret\u00f3rios, \u00e9 o Search (Busca), tamb\u00e9m dispon\u00edvel na barra lateral, ou pelo atalho Ctrl+Shift+F, ou ainda pelo menu View na op\u00e7\u00e3o Search.</p> <p>Nesta barra, voc\u00ea pode digitar o que pretende buscar na caixa de textos, e o vscode ir\u00e1 pesquisar em todos os arquivos do diret\u00f3rio pelas ocorr\u00eancias do texto que voc\u00ea pesquisou, listando os arquivos encontrados com as posi\u00e7\u00f5es onde as ocorr\u00eancias podem ser vistas.</p> <p></p> <p>Al\u00e9m disso, esta barra permite fazer substitui\u00e7\u00f5es, da mesma forma como \u00e9 poss\u00edvel fazer usando a fun\u00e7\u00e3o Search/Replace no editor individual de um arquivo.</p>"},{"location":"aulas/03-text-editors/#36-workspaces","title":"3.6 - Workspaces","text":"<p>Quando trabalhamos com diret\u00f3rios, podemos fazer uso de um recurso chamado Workspace (Espa\u00e7o de Trabalho). O vscode oferece esta funcionalidade para organizarmos configura\u00e7\u00f5es que s\u00e3o aplicadas e compartilhadas por todos os arquivos que pertencem a um espa\u00e7o.</p> <p>Ao trabalhar em um Workspace, o vscode memoriza o layout da janela (quais arquivos est\u00e3o abertos, o estado dos pain\u00e9is e barras laterais, etc), configura\u00e7\u00f5es espec\u00edficas daquele Workspace (para o editor, extens\u00f5es, etc), defini\u00e7\u00f5es de Tarefas (tasks) e Configura\u00e7\u00f5es de Depura\u00e7\u00e3o.</p> <p>As configura\u00e7\u00f5es do Workspace, quando estamos trabalhando com um diret\u00f3rio, ficam armazenadas em um arquivo json situado em <code>.vscode/settings.json</code>, a partir do endere\u00e7o do diret\u00f3rio aberto.</p>"},{"location":"aulas/03-text-editors/#371-workspaces-com-multiplos-diretorios-raizes","title":"3.7.1 - Workspaces com M\u00faltiplos Diret\u00f3rios Ra\u00edzes","text":"<p>\u00c9 poss\u00edvel, tamb\u00e9m, organizar um Workspace composto por mais de um diret\u00f3rio raiz. A qualquer momento voc\u00ea pode adicionar novos diret\u00f3rios ao Workspace atual atrav\u00e9s do menu <code>File</code>, clicando na op\u00e7\u00e3o <code>Add Folder to Workspace...</code>. Quando tiver o Workspace aberto, voc\u00ea pode salvar as configura\u00e7\u00f5es clicando no menu <code>File</code>, e escolhendo a op\u00e7\u00e3o <code>Save Workspace As...</code>. Isto ir\u00e1 criar um arquivo com a estens\u00e3o <code>.code-workspace</code>, que \u00e9 o arquivo que voc\u00ea ir\u00e1 usar quando quiser abrir o workspace novamente, al\u00e9m de ser onde ser\u00e3o mantidas as configura\u00e7\u00f5es correspondentes a este workspace.</p> <p></p>"},{"location":"aulas/03-text-editors/#37-terminal","title":"3.7 - Terminal","text":"<p>O vscode tamb\u00e9m possui um terminal interno que pode ser usado de forma conveniente, sem que seja necess\u00e1rio sair do editor para executar tarefas no shell. \u00c9 poss\u00edvel acessar o terminal acionando o menu View e clicando em Terminal, ou pelo atalho Ctrl+'. O vscode suporta diversos shells em seu terminal, mas ir\u00e1 abrir inicialmente o shell padr\u00e3o do ambiente em que est\u00e1 rodando.</p> <p></p> <p>\u00c9 poss\u00edvel abrir m\u00faltiplos terminais no painel Terminal, para isto basta clicar no bot\u00e3o <code>+</code> para iniciar uma nova inst\u00e2ncia com o shell padr\u00e3o, ou clicar no menu suspenso para criar uma nova inst\u00e2ncia de um terminal usando outro shell. Uma barra lateral \u00e0 direita do painel ir\u00e1 listar todos os terminais abertos, permitindo alternar entre eles, clicando naquele que se pretende usar, ou fech\u00e1-los atrav\u00e9s do \u00edcone da lixeira.</p> <p>\u00c9 poss\u00edvel tamb\u00e9m dividir o painel do terminal para visualizar m\u00faltiplos terminais simultaneamente.</p> <p>Por \u00faltimo, o bot\u00e3o <code>^</code> expande o painel do terminal para ocupar o espa\u00e7o do editor de arquivos, dando mais espa\u00e7o para trabalhar no shell.</p>"},{"location":"aulas/03-text-editors/#38-conclusao","title":"3.8 - Conclus\u00e3o","text":"<p>Esta n\u00e3o \u00e9 uma aula exaustiva sobre vscode. Ele possui ainda outras capacidades que n\u00e3o foram explordas aqui (como o ambiente remoto, integra\u00e7\u00e3o com um sistema de versionamento de c\u00f3digo e outras funcionalidades de depura\u00e7\u00e3o). Mas com o que vimos at\u00e9 aqui, pudemos fazer uma explora\u00e7\u00e3o muito rica do editor como uma ferramenta de produtividade para as atividades que desempenhamos quando estamos trabalhando com c\u00f3digo.</p> <p>A seguir, poderemos explorar capacidades avan\u00e7adas de Shell Scripts em Bash, agora usando o vscode como ferramenta.</p>"},{"location":"aulas/04-source-control/","title":"Aula 04 - Sistema de Controle de Versionamento de C\u00f3digo - Git","text":""},{"location":"aulas/04-source-control/#aula-04-sistema-de-controle-de-versionamento-de-codigo-git","title":"Aula 04 - Sistema de Controle de Versionamento de C\u00f3digo - Git","text":"<p>Trabalhar com c\u00f3digo requer organiza\u00e7\u00e3o, e muito do que aprendemos sobre como organizamos o nosso c\u00f3digo se d\u00e1 com um trabalho iterativo e incremental, ou seja, o c\u00f3digo est\u00e1 em constante mudan\u00e7a. Parte da nossa rotina no trabalho com c\u00f3digo \u00e9 de fazer, desfazer e refazer partes dele ao longo do desenvolvimento de uma tarefa, \u00e0 medida que testamos e percebemos oportunidades de melhoria, ou at\u00e9 mesmo, problemas que n\u00e3o foram antecipados e que requerem mudan\u00e7as na forma como hav\u00edamos elaborado a solu\u00e7\u00e3o anteriormente.</p> <p>Para ter algum controle sobre como estas altera\u00e7\u00f5es acontecem, e que possamos visualiz\u00e1-las em um contexto hist\u00f3rico que torne essa organiza\u00e7\u00e3o poss\u00edvel, usamos um sistema de controle de versionamento de c\u00f3digo. Existem diversas ferramentas para este fim dispon\u00edveis no mercado, mas uma delas se tornou um padr\u00e3o de uso entre profissionais de TI nas \u00faltimas d\u00e9cadas: o Git.</p> <p>O Git \u00e9 um Sistema de Controle de Versionamento de C\u00f3digo (SVC), criado pelo Linus Torvalds enquanto ele desenvolvia o Kernel do Linux, dispon\u00edvel como software livre de c\u00f3digo aberto sob a licen\u00e7a GPL, compat\u00edvel com v\u00e1rias plataformas (Linux, MacOS e Windows). Ele \u00e9 utilizado pela vasta maioria dos profissionais de tecnologia atualmente, tanto para projetos de C\u00f3digo Aberto quanto em organiza\u00e7\u00f5es privadas.</p> <p>Ele funciona atrav\u00e9s da cria\u00e7\u00e3o de um reposit\u00f3rio de c\u00f3digo em um diret\u00f3rio no sistema de arquivos para acompanhar as mudan\u00e7as que este c\u00f3digo sofre ao longo do tempo. Neste reposit\u00f3rio voc\u00ea \u00e9 capaz de criar marca\u00e7\u00f5es do estado dos arquivos, e a partir destas marca\u00e7\u00f5es voc\u00ea tem a possibilidade de visualizar e navegar pelo hist\u00f3rico de como estes arquivos foram alterados, restaurar o estado em que eles se encontravam em um determinado momento no passado e reescrever a hist\u00f3ria deles a partir de uma marca\u00e7\u00e3o espec\u00edfica, al\u00e9m de diversas capacidades que veremos a seguir.</p> <p>Nesta aula vamos explorar o uso de Git, tanto para organiza\u00e7\u00e3o pessoal, quanto para contribui\u00e7\u00e3o em projetos colaborativos.</p>"},{"location":"aulas/04-source-control/#41-instalando-o-git","title":"4.1 - Instalando o Git","text":"<p>Para instalar o Git, basta acessar o site oficial, fazer o download para a plataforma do seu dispositivo e seguir as instru\u00e7\u00f5es de instala\u00e7\u00e3o.</p> <ul> <li>git config</li> </ul>"},{"location":"aulas/04-source-control/#42-iniciando-um-repositorio","title":"4.2 - Iniciando um Reposit\u00f3rio","text":"<ul> <li>git init</li> <li>git status</li> <li>git add </li> <li>git commit</li> <li>git restore</li> <li>git reset</li> </ul>"},{"location":"aulas/04-source-control/#43-navegando-pelo-historico-de-alteracoes","title":"4.3 - Navegando pelo hist\u00f3rico de altera\u00e7\u00f5es","text":"<ul> <li>git log</li> <li>git show</li> <li>git diff</li> <li>git checkout</li> <li>git reset</li> <li>git tag</li> </ul>"},{"location":"aulas/04-source-control/#44-trabalhando-com-branches","title":"4.4 - Trabalhando com Branches","text":"<ul> <li>git branch</li> <li>git switch</li> <li>git checkout</li> </ul>"},{"location":"aulas/04-source-control/#45-merge","title":"4.5 - Merge","text":"<ul> <li>git merge</li> <li>Conflitos</li> </ul>"},{"location":"aulas/04-source-control/#46-repositorios-remotos","title":"4.6 - Reposit\u00f3rios Remotos","text":"<ul> <li>clone</li> <li>fetch</li> <li>pull</li> <li>push</li> </ul>"},{"location":"aulas/04-source-control/#47-servicos-de-colaboracao-codeberg","title":"4.7 - Servi\u00e7os de Colabora\u00e7\u00e3o - CodeBerg","text":"<ul> <li>fork</li> <li>Pull request</li> </ul>"},{"location":"aulas/04-source-control/#48-rebase","title":"4.8 - Rebase","text":"<ul> <li>git rebase</li> </ul>"}]}