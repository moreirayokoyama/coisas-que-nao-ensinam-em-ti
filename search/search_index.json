{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Coisas Que N\u00e3o Ensinam em TI [!IMPORTANT] Este curso \u00e9 uma adapta\u00e7\u00e3o para Portugu\u00eas(Brasil) do curso The Missing Semester in Your CS Formation do MIT. Parte deste conte\u00fado \u00e9 deliberadamente extra\u00eddo e traduzido do material do curso original, apesar de haver algumas adapt\u00e7\u00f5es e adequa\u00e7\u00f5es para esta vers\u00e3o, olhando para o contexto do mercado nacional e de algumas considera\u00e7\u00f5es feitas a partir de um contexto fora do ambiente acad\u00eamico (como no caso do MIT). Apresenta\u00e7\u00e3o do Curso Conte\u00fado do Curso Aula 1 - O Shell Aula 2 - Criando Scripts com Bash Atribui\u00e7\u00f5es Este curso est\u00e1 sob a licen\u00e7a CC BY-NC-SA (de acordo com o curso original). O curso original no qual este \u00e9 baseado foi elaborado por - Anish Athalye - Jon Gjengset - Jose Javier Gonzalez Ortiz Mais informa\u00e7\u00f5es sobre o curso original podem ser conferidas no Site Oficial .","title":"Coisas Que N\u00e3o Ensinam em TI"},{"location":"#coisas-que-nao-ensinam-em-ti","text":"[!IMPORTANT] Este curso \u00e9 uma adapta\u00e7\u00e3o para Portugu\u00eas(Brasil) do curso The Missing Semester in Your CS Formation do MIT. Parte deste conte\u00fado \u00e9 deliberadamente extra\u00eddo e traduzido do material do curso original, apesar de haver algumas adapt\u00e7\u00f5es e adequa\u00e7\u00f5es para esta vers\u00e3o, olhando para o contexto do mercado nacional e de algumas considera\u00e7\u00f5es feitas a partir de um contexto fora do ambiente acad\u00eamico (como no caso do MIT).","title":"Coisas Que N\u00e3o Ensinam em TI"},{"location":"#apresentacao-do-curso","text":"","title":"Apresenta\u00e7\u00e3o do Curso"},{"location":"#conteudo-do-curso","text":"Aula 1 - O Shell Aula 2 - Criando Scripts com Bash","title":"Conte\u00fado do Curso"},{"location":"#atribuicoes","text":"Este curso est\u00e1 sob a licen\u00e7a CC BY-NC-SA (de acordo com o curso original). O curso original no qual este \u00e9 baseado foi elaborado por - Anish Athalye - Jon Gjengset - Jose Javier Gonzalez Ortiz Mais informa\u00e7\u00f5es sobre o curso original podem ser conferidas no Site Oficial .","title":"Atribui\u00e7\u00f5es"},{"location":"aulas/01-shell/","text":"Aula 1 - O Shell Nesta primeira aula do nosso curso, apresentaremos o Shell como uma ferramenta prim\u00e1ria de produtividade das pessoas que trabalham em diversas \u00e1reas de TI. Quando navegamos pela internet atrav\u00e9s do uso de um Web Browser , ou usamos algum app ou qualquer aplicativo com uma interface gr\u00e1fica, estamos limitados ao que esta interface suporta. Se existe um bot\u00e3o dispon\u00edvel para uma determinada funcionalidade, a visibilidade deste bot\u00e3o \u00e9 o que determina se podemos nos beneficiar desta dela ou n\u00e3o. Se o bot\u00e3o n\u00e3o est\u00e1 vis\u00edvel, n\u00e3o podemos clicar nele. Uma interface de linha de comando ( CLI ), como a que temos quando usamos um Shell , torna mais flex\u00edvel o acesso que temos \u00e0s funcionalidades dispon\u00edveis. Saber usar o Shell e navegar por ele potencialmente torna o trabalho cotidiano mais produtivo e, por isto, estamos dando o devido foco em apresent\u00e1-lo neste curso. 1. O que \u00e9 o Shell Quase todas as plataformas com as quais voc\u00ea pode trabalhar atualmente oferecem um Shell , e muitas oferecem diferentes op\u00e7\u00f5es de Shell para voc\u00ea escolher. Apesar de que eles possam variar em seus detalhes, em sua ess\u00eancia s\u00e3o basicamente iguais: eles te permitem executar programas, manipular sua entrada ( input ) e inspecionar sua sa\u00edda ( output ) de uma forma semi-estruturada. 1.1 Shell vs Terminal Para ter acesso a um Shell, voc\u00ea precisa de um Terminal . Um terminal \u00e9 um programa capaz de receber um comando, encaminhar para o Shell , e exibir seu resultado. O sistema que voc\u00ea usa em seu computador provavelmente possui um terminal dispon\u00edvel. Para os usu\u00e1rios de Windows (a partir do Windows 11), t\u00eam instalado em seu sistema o Windows Terminal . Para usu\u00e1rios de vers\u00f5es anteriores, o Windows Terminal est\u00e1 dispon\u00edvel para download gratuito na Microsoft Store. Outras op\u00e7\u00f5es de terminal para os usu\u00e1rios Windows s\u00e3o o ConEmu e o Cmder . J\u00e1 para os usu\u00e1rios de Linux/MacOS, existem diversas op\u00e7\u00f5es de terminal. Um dos terminais mais famosos para os usu\u00e1rios MacOS \u00e9 o iTerm2 . No Linux, entre os terminais mais usados est\u00e3o o Terminator e o Guake . Escolher entre as diferentes op\u00e7\u00f5es de terminais normalmente depende das funcionalidades e conveni\u00eancias que cada op\u00e7\u00e3o oferece. Pain\u00e9is ( tiles ), Guias( tabs ), Teclas de Atalho, Esquemas de Cores, e outras facilidades podem diferenciar as op\u00e7\u00f5es de terminais, mas de uma forma ou de outra, a maioria dos terminais dispon\u00edveis oferecem estas e outras funcionalides com algumas diferen\u00e7as sutis de como elas funcionam. 1.2 Diferentes Shells Al\u00e9m dos diferentes sabores de terminais, existem tamb\u00e9m diferentes op\u00e7\u00f5es de Shells. Cada Shell pode apresentar uma sintaxe diferente de comandos e da forma como voc\u00ea interage atrav\u00e9s do terminal, apesar de haver muitas semelhan\u00e7as entre as principais op\u00e7\u00f5es. Para os usu\u00e1rios Windows, as duas principais op\u00e7\u00f5es de Shell dispon\u00edveis s\u00e3o: cmd O cmd \u00e9 o shell nativo do Windows, baseado no Prompt de Comando do antigo MS-DOS (sistema operacional da Microsoft anterior ao Windows). Ele suporta basicamente os comandos b\u00e1sicos do MS-DOS para navegar e manipular o sistema de arquivos. Windows PowerShell O PowerShell \u00e9 um Shell moderno criado pela Microsoft, como uma alternativa mais poderosa que o cmd para os usu\u00e1rios Windows. No mundo Linux e MacOS, existem op\u00e7\u00f5es similares de Shell, dentre elas as mais comuns s\u00e3o: Bash O Bash ( Bourne Again Shell ) \u00e9 uma op\u00e7\u00e3o de Shell dispon\u00edvel para Linux e MacOS baseado no Bourne Shell , que \u00e9 um Shell popular para o sistema Unix . Zsh O Zsh (z-shell) \u00e9 uma alternativa ao Bash que apresenta funcionalidades comuns, e acrescenta outras funcionalidades baseadas em outras famosas op\u00e7\u00f5es de Shell do sistema Unix (como o ksh e o tcsh ), al\u00e9m de trazer funcionalidades \u00fanicas. 2. Bash (Bourne Again SHell) Bash \u00e9 o shell mais popular atualmente, sendo a op\u00e7\u00e3o pr\u00e9-instalada no Ubuntu, que \u00e9 a distribui\u00e7\u00e3o do Linux mais baixada, al\u00e9m \u00e9 claro de fazer parte de outras distribui\u00e7\u00f5es tamb\u00e9m. Por causa da sua relev\u00e2ncia, toda a discuss\u00e3o relacioana a Shells ao longo deste curso, quando n\u00e3o abordada de uma forma generalista, usar\u00e1 como premissa o uso do bash . Para acompanhar o conte\u00fado deste curso, certifique-se de ter instalado o bash como uma das op\u00e7\u00f5es de Shell dispon\u00edveis no seus sistema. Usu\u00e1rios Linux e MacOS provavelmente j\u00e1 possuir\u00e3o o bash instalado, caso contr\u00e1rio, provavelmente encontrar\u00e3o uma f\u00e1cil instala\u00e7\u00e3o a partir de algum dos gerenciadores de pacote que seus sistemas disponibilizam. 2.1 Bash para Usu\u00e1rios Windows Para aqueles que acompanham este curso e s\u00e3o usu\u00e1rios do Microsoft Windows, existem op\u00e7\u00f5es de instala\u00e7\u00e3o do Bash. Vamos apresentar 3 delas para que voc\u00ea escolher a que melhor lhe for mais conveniente. MinGW64 / Cygwin Das op\u00e7\u00f5es dispon\u00edveis para se instalar o Bash no Windows, o MinGW64 e o Cygwin se diferenciam por n\u00e3o precisar virtualizar um outro sistema (como Linux). Ambos os projetos podem ser instalados em qualquer vers\u00e3o do Windows e fornecem um conjunto de ferramentas para criar um ambiente compat\u00edvel com um sistema semelhante ao Unix para pessoas que preferem trabalhar usando o Windows. O Bash disponibilizado por estas ferramentas, n\u00e3o \u00e9 totalmente compat\u00edvel com o Bash que voc\u00ea usaria ao criar uma instala\u00e7\u00e3o do Ubuntu, por exemplo, mas pode ser o suficiente para quem prefere n\u00e3o virtualizar (ou n\u00e3o pode). Para instalar o MinGW64, acesse o site: https://www.mingw-w64.org/downloads/ [!TIP] Se voc\u00ea instalar o Git para Windows (haver\u00e3o aulas neste curso que usar\u00e3o o Git), ele inclui o MinGW64 para disponibilizar um shell chamado Git Bash. Se voc\u00ea preferir instalar o Cygwin, o endere\u00e7o no site para baixar o instalador \u00e9: https://cygwin.com/install.html Criar um Memory Stick Inicializ\u00e1vel com uma distribui\u00e7\u00e3o do Linux \u00c9 poss\u00edvel ter uma distribui\u00e7\u00e3o do Linux dispon\u00edvel para uso sem precisar instal\u00e1-la no seu sistema, usando um Memory Stick (vulgo: Pen Drive) inicializ\u00e1vel. Existem diversos tutoriais na dispon\u00edveis na internet explicando com realizar o processo. Mas, resumidamente, voc\u00ea precisa baixar a imagem do sistema operacional (por exemplo, Ubuntu), e um programa capaz de configurar um Memory Stick com a imagem de forma inicializ\u00e1vel. [!WARNING] Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows. Dual Boot com Linux Voc\u00ea pode criar uma instala\u00e7\u00e3o do Linux lado a lado com a instala\u00e7\u00e3o do Windows e ter a op\u00e7\u00e3o no seu dispositivo de qual dos sistemas voc\u00ea pretende usar no momento da inicializa\u00e7\u00e3o. [!WARNING] Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows. [!WARNING] Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) se tornem exclusivos para o novo sistema, tornando-os indispon\u00edveis para o Windows. Isto requer algum planejamento sobre como estes recursos ser\u00e3o distribu\u00eddos. Virtualiza\u00e7\u00e3o de Linux Criar uma M\u00e1quina Virtual ( VM ) com uma instala\u00e7\u00e3o do Linux \u00e9 uma op\u00e7\u00e3o acess\u00edvel e, certamente, mais conveniente que a op\u00e7\u00e3o com Dual Boot. Uma VM \u00e9, basicamente, um computador virtual, com as mesmas funcionalidades que um dispositivo oferece, por\u00e9m, emulado a partir de um Sistema Hospedeiro (no caso, o Windows). Voc\u00ea pode criar VMs usando softwares gratuitos como o HyperV do Windows ou VirtualBox da Oracle , e baixar uma imagem da distribui\u00e7\u00e3o Linux desejada (por exemplo, Ubuntu), para criar uma VM. Independente de qual plataforma voc\u00ea pretende usar, voc\u00ea vai precisar ativar o Hypervisor do Windows (que \u00e9 parte integrante da instala\u00e7\u00e3o do HyperV). Para isto, no menu iniciar (pressionando a tecla Windows no teclado), digite \"Ativar ou Desativar Recursos do Windows\", e ao abrir a janela dos Recursos do Windows, procure na lista o \u00edtem \"Hyper-V\" e certifique-se de que ele esteja selecionado. Ativar este recurso, ir\u00e1 exigir que voc\u00ea reinicialize seu computador . [!WARNING] Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) sejam compartilhados com a VM, podendo ter um impacto na performance do sistema hospedeiro. Windows Subsystem for Linux (WSL) Para usu\u00e1rios de vers\u00f5es mais recentes do Windows (a partir do Windows 10), \u00e9 poss\u00edvel virtualizar uma distribui\u00e7\u00e3o Linux usando um Kernel dispon\u00edvel pelo pr\u00f3prios Windows. Este \u00e9, inclusive, o m\u00e9todo que eu estou usando. \u00c9 um m\u00e9todo melhor do que criar uma VM, pois o WSL suporta uma integra\u00e7\u00e3o transparente entre os sistemas (compartilhando portas e programas). Este m\u00e9todo tamb\u00e9m exige que voc\u00ea ative o HyperV , al\u00e9m de ativar tamb\u00e9m o \"Subsistema do Windows para Linux\", e instalar a distribui\u00e7\u00e3o escolhida (por exemplo, Ubuntu), a partir das op\u00e7\u00f5es dispon\u00edveis na Microsoft Store. 2.2 Apresentando o ambiente de Shell com Bash Ao abrir o terminal de sua escolha para acessar um Shell, invariavelmente voc\u00ea ir\u00e1 encontrar algo muito parecido com a imagem a seguir. Uma janela vazia (normalmente com fundo escuro), mostrando no topo um texto com algumas informa\u00e7\u00f5es \u00faties e um cursor piscando, esperando que voc\u00ea digite algo. As informa\u00e7\u00f5es exibidas podem variar de um computador para o outro j\u00e1 que elas se baseiam nas configura\u00e7\u00f5es do usu\u00e1rio. No caso do meu shell, exibido acima, as informa\u00e7\u00f5es exibidas s\u00e3o: [!IMPORTANT] dmyoko@CodandoComOTio:~/projects/coisas-que-nao-ensinam-em-ti$ - Nome do usu\u00e1rio logado na sess\u00e3o - O @ (arroba) separa o nome do usu\u00e1rio do nome do servidor da sess\u00e3o - O nome do servidor da sess\u00e3o - Os dois pontos ( : ) separam os dados da sess\u00e3o do caminho do diret\u00f3rio atual onde >o shell ir\u00e1 aplicar os comandos - No Bash, o caractere que separa os segmentos do caminho \u00e9 / , diferente do >Windows que usa \\ (barra invertida) - O cifr\u00e3o ( $ ) no final, indica que o shell n\u00e3o est\u00e1 no modo super user. O nome desta linha, contendo estas ou quaisquer outras informa\u00e7\u00f5es de acordo com a configura\u00e7\u00e3o do shell, e o cursor esperando a entrada de um comando, \u00e9 Prompt . A partir daqui, qualquer texto digitado ser\u00e1 interpretado como um comando dado ao shell. Este comando pode servir para executar programas, rodar scripts ou executar comandos nativos do pr\u00f3prio shell. A partir do momento em que algo \u00e9 digitado e enviado para o shell (normalmente atrav\u00e9s do pressionamento da tecla Enter ou Return), o shell executa a linha digitada e o terminal imprime qualquer que seja o resultado (output) da execu\u00e7\u00e3o. Por exmeplo, uma instru\u00e7\u00e3o simples como pwd (que imprime o diret\u00f3rio atual do shell), pode demonstrar este fluxo. Ao inserir esta instru\u00e7\u00e3o e pressionar Enter (ou Return), o diret\u00f3rio \u00e9 exibido na linha abaixo da linha onde o comando foi dado, e na linha seguinte, um novo prompt \u00e9 exibido. O modo como trabalhamos no ambiente de Shell \u00e9 um ciclo: - Um prompt \u00e9 exibido indicando que o shell est\u00e1 pronto para receber comandos atrav\u00e9s do terminal - Um comando \u00e9 digitado no terminal e enviado ao shell - O shell interpreta o comando enviado e o executa - Qualquer resultado direcionado para a sa\u00edda ( output ) do shell \u00e9 exibido pelo terminal Com isto, podemos agora explorar um pouco alguns comandos que o Bash nos fornece. 2.3 Navegando com o Shell Vamos come\u00e7ar a explorar os comandos do Bash, aprendendo primeiro a navegar pelo sistema de arquivos. Exibindo o diret\u00f3rio atual: pwd Como vimos agora h\u00e1 poudo, o comando pwd ( Print Working Directory ), imprime no terminal o caminho do diret\u00f3rio atual onde o Shell ir\u00e1 executar o pr\u00f3ximo comando. Saber qual \u00e9 o diret\u00f3rio atual \u00e9 importante, por que isto pode afetar diretamente o resultado do pr\u00f3ximo comando. Por exemplo, se o pr\u00f3ximo comando resultar na cria\u00e7\u00e3o de um arquivo, o arquivo ser\u00e1 criado no diret\u00f3rio atual, exceto se algum par\u00e2metro espec\u00edfico seja usado para mudar este comportamento (salvo, \u00e9 claro, se o programa executado tiver instru\u00e7\u00f5es espec\u00edficas do caminho do arquivo). Mudando o diret\u00f3rio atual: cd Para mudar o diret\u00f3rio atual da sess\u00e3o do Shell, o comando usado \u00e9 o cd ( Change Directory ). Se voc\u00ea digitar apenas cd e pressionar Enter, ele vai mudar o diret\u00f3rio atual para ~ (falaremos logo a seguir sobre que diret\u00f3rio \u00e9 este). Ele n\u00e3o imprime nenhuma sa\u00edda, e imediatamente um novo prompt \u00e9 apresentado. Para informar o comando cd para que ele mude para um diret\u00f3rio diferente, um argumento precisa ser usado. [!NOTE] Argumentos : s\u00e3o complementos que damos aos comandos, normalmente digitando-os a seguir do comando propriamente dito. Por exemplo, no comando cd teste , teste \u00e9 o argumento passado para o comando cd . Neste caso, o comando cd vai mudar mudar o diret\u00f3rio atual para o diret\u00f3rio teste . cd teste No meu caso, uma mensagem de erro \u00e9 exibida: bash: cd: teste: No such file or directory Ela diz que n\u00e3o existe um arquivo ou diret\u00f3rio chamado teste . Note, executando o comando pwd novamente, que o diret\u00f3rio atual permanece o mesmo. Para mudar o diret\u00f3rio atual, precisamos passar como argumento, o endere\u00e7o de um diret\u00f3rio existente. Por exemplo, um diret\u00f3rio que com certeza existe no sistema de arquivos \u00e9 o diret\u00f3rio raiz, que fica no endere\u00e7o / . cd / No meu caso, como voc\u00ea pode ver, o meu prompt mudou, agora dizendo que o diret\u00f3rio atual \u00e9 / (o diret\u00f3rio raiz). Se o seu prompt n\u00e3o exibe esta informa\u00e7\u00e3o como o meu, voc\u00ea pode confirmar usando o comando pwd . Outro diret\u00f3rio comum para quem usa o Bash, \u00e9 o diret\u00f3rio Home , representado pelo caractere ~ . Voc\u00ea pode testar o comando: cd ~ Como pode ver, no meu prompt, agora ele exibe ~ como diret\u00f3rio atual, e n\u00e3o mais o diret\u00f3rio raiz ( / ). Ao contr\u00e1rio do diret\u00f3rio raiz, se voc\u00ea usar o comando pwd agora voc\u00ea vai notar que o diret\u00f3rio Home ( ~ ), na verdade, aponta para um diret\u00f3rio espec\u00edfico a partir da raiz. No meu caso, /home/dmyoko (no seu caso, vai apontar para um diret\u00f3rio com o nome do seu usu\u00e1rio dentro do diret\u00f3rio /home ). Voc\u00ea pode navegar manualmente por estes diret\u00f3rios, usando o caminho que os leva at\u00e9 eles. Por exemplo: cd / cd home cd dmyoko Uma vez no diret\u00f3rio / (raiz), voc\u00ea tem acesso ao diret\u00f3rio home , e uma vez que voc\u00ea entra no diret\u00f3rio home , voc\u00ea tem acesso ao diret\u00f3rio do seu usu\u00e1rio, no meu caso dmyoko . Voc\u00ea tamb\u00e9m pode navegar direto para o diret\u00f3rio espec\u00edfico, usando o caminho completo absoluto que leva at\u00e9 ele, come\u00e7ando pelo diret\u00f3rio raiz. cd / cd /home/dmyoko [!NOTE] Caminho absoluto \u00e9 o caminho completo que leva at\u00e9 um diret\u00f3rio ou arquivo no sistema de arquivos. Ele sempre come\u00e7a pelo diret\u00f3rio / (raiz), e segue toda a hierarquia de segmentos necess\u00e1rios at\u00e9 chegar no diret\u00f3rio ou arquivo desejado. Listar informa\u00e7\u00f5es sobre o conte\u00fado de um diret\u00f3rio: ls O comando ls \u00e9 \u00fatil quando voc\u00ea deseja entender o conte\u00fado de um determinado diret\u00f3rio. Se voc\u00ea digitar somente ls , o Bash imprimir\u00e1 no terminal o conte\u00fado do diret\u00f3rio atual. Se voc\u00ea quiser listar o conte\u00fado de outro diret\u00f3rio sem necessariamente sair do diret\u00f3rio atual, basta usar como argumento o caminho para o diret\u00f3rio do qual voc\u00ea pretende listar o conte\u00fado desejado. ls / O comando acima, lista o conte\u00fado do diret\u00f3rio / (raiz). Voc\u00ea pode tamb\u00e9m listar o conte\u00fado de um dos subdiret\u00f3rios do diret\u00f3rio raiz, informando o endere\u00e7o dele. Por exemplo: ls /bin ls /lib ls /sys/devices/cpu O comando ls tamb\u00e9m suporta op\u00e7\u00f5es, que podem influenciar no resultado do comando. Por exemplo, a op\u00e7\u00e3o -l exibe o resultado do comando ls no formato de lista, trazendo informa\u00e7\u00f5es adicionais a respeito do conte\u00fado do diret\u00f3rio, que antes n\u00e3o estavam sendo exibidas, como as permiss\u00f5es de acesso ao diret\u00f3rio/arquivo listado, informa\u00e7\u00f5es de quem \u00e9 o usu\u00e1rio dono deste diret\u00f3rio/arquivo e a que grupo ele pertence (usu\u00e1rio dmyoko do grupo dmyoko , por exemplo), o tamanho do arquivo/diret\u00f3rio em bytes, e a data da \u00faltima vez que o arquivo/diret\u00f3rio foi modificado. ls -l Outra op\u00e7\u00f5a \u00fatil \u00e9 o -h , que faz com que os tamanhos dos arquivos exibidos sejam impressos num formato humanamente leg\u00edvel (human readable). ls -h # sem efeito, pois os tamanhos n\u00e3o s\u00e3o exibidos ls -l -h # agora \u00e9 poss\u00edvel ver o efeito. ls -lh # \u00e9 poss\u00edvel unir todas as op\u00e7\u00f5es em uma \u00fanica cl\u00e1usula Existem outras diversas op\u00e7\u00f5es dispon\u00edveis para o comando ls . Para ter acesso a uma lista completa delas, voc\u00ea pode digitar ls --help . [!TIP] --help \u00e9 uma op\u00e7\u00e3o dispon\u00edvel na vasta maioria dos comandos que voc\u00ea pode executar no shell. E, invariavelmente, imprime informa\u00e7\u00f5es sobre o que o comando faz e como utiliz\u00e1-lo, inclusive, mostrando poss\u00edveis op\u00e7\u00f5es que afetam a forma como este comando se comporta. 2.4 Permiss\u00f5es de arquivos e diret\u00f3rios Eu mencionei que a primeira coluna exibida como resultado do ls -l s\u00e3o as permiss\u00f5es dos arquivos ou diret\u00f3rios listados. Estas permiss\u00f5es indicam quem pode fazer o que com estes artefatos. Para dar uma breve explica\u00e7\u00e3o, vamos entender como estas informa\u00e7\u00f5es s\u00e3o exibidas: Cada caractere exibido nesta coluna representa um atributo do artefato ao qual ele est\u00e1 ligado. O primeiro caractere, por exemplo, indica que tipo de artefato \u00e9 o item da lista. Um simples - indica que ele \u00e9 apenas um arquivo, e um d indica que ele \u00e9 um diret\u00f3rio. Existem outros tipos, que podemos discutir no futuro. Os demais caracteres s\u00e3o agrupamentos de 3 caracteres, cada caractere simbolizando uma permiss\u00e3o espec\u00edfica: rwx . - r : representa a permiss\u00e3o para leitura - w : representa a permiss\u00e3o para escrita - x : representa a permiss\u00e3o para execu\u00e7\u00e3o Os 3 caracteres est\u00e3o sempre nesta ordem, e podem ser substitu\u00eddos por um - , indicando que a devida opera\u00e7\u00e3o n\u00e3o \u00e9 permitida. Por exemplo: rwx : Todas as opera\u00e7\u00f5es s\u00e3o permitidas rw- : \u00c9 permitido ler e alterar o arquivo, mas n\u00e3o \u00e9 permitido execut\u00e1-lo r-- : S\u00f3 se tem acesso para ler o conte\u00fado do arquivo, mas n\u00e3o \u00e9 permitido alter\u00e1-lo. Estas permiss\u00f5es s\u00e3o exibidas na seguinte ordem: - Permiss\u00f5es para o dono do arquivo - Permiss\u00f5es para os demais usu\u00e1rios do grupo dono do arquivo - Permiss\u00f5es para todos os demais usu\u00e1rios Por exemplo (retirado do screenshot acima): drwxr-xr-x 2 root root 4096 Mar 25 2022 X11 Esta linha diz que X11 \u00e9 um diret\u00f3rio ( d ), o dono (que \u00e9 o usu\u00e1rio root ) possui permiss\u00e3o de leitura, escrita e execu\u00e7\u00e3o, enquanto que os outros membros do grupo root podem apenas ler o conte\u00fado e execut\u00e1-lo, bem como todos os outros usu\u00e1rios. [!IMPORTANT] Em um diret\u00f3rio , a permiss\u00e3o de execu\u00e7\u00e3o significa que o usu\u00e1rio \u00e9 capaz de navegar por ele (atrav\u00e9s do comando cd ). A permiss\u00e3o de leitura significa que o usu\u00e1rio \u00e9 capaz de listar o conte\u00fado (atrav\u00e9s do comando ls ) ou procurar por arquivos, etc. E a permiss\u00e3o de escrita significa que o usu\u00e1rio \u00e9 capaz de criar novos artefatos (arquivos, diret\u00f3rios, etc) dentro do diret\u00f3rio. 2.5 Manipula\u00e7\u00e3o do sistema de arquivos Agora que sabemos como navegar e obter informa\u00e7\u00f5es sobre o conte\u00fado do sistema de arquivos, vamos aprender como manipular o conte\u00fado dos diret\u00f3rios, criando, modificando e excluindo arquivos e diret\u00f3rios usando comandos do Shell. Criando diret\u00f3rios: mkdir Para criar novos diret\u00f3rios, usamos o comando mkdir passando como argumento o nome do diret\u00f3rio que queremos criar. cd ~ #Certifique-se de estar no seu diret\u00f3rio `home` mkdir teste O diret\u00f3rio teste ser\u00e1 criado no diret\u00f3rio atual, no caso, o diret\u00f3rio home . Voc\u00ea tamb\u00e9m pode criar um diret\u00f3rio em um lugar diferente do diret\u00f3rio atual, usando o endere\u00e7o completo desejado. mkdir /home/dmyoko/teste/tmp [!WANING] Espa\u00e7os importam! Tome cuidado com o uso de espa\u00e7os quando estiver executando opera\u00e7\u00f5es no shell. Por exemplo, se voc\u00ea digitar o comando mkdir minhas fotos , ao inv\u00e9s de criar um diret\u00f3rio chamado minhas fotos , ele ir\u00e1 criar dois diret\u00f3rios, um chamado minhas e um segundo chamado fotos . Para usar espa\u00e7os voc\u00ea pode usar caracteres de escape. Para usar caracteres de escape, voc\u00ea usa a \\ (barra invertida). Por exemplo: mkdir Minhas\\ Fotos # Cria um diret\u00f3rio chamado `Minhas Fotos` Voc\u00ea pode, tamb\u00e9m, delimitar o nome usando aspas ( \" ) ou ap\u00f3strofos ( ' ), como uma forma de indicar o nome sem usar caracteres de escape. O comando mkdir possui uma op\u00e7\u00e3o -p que permite que voc\u00ea crie um caminho completo de diret\u00f3rios: mkdir -p /home/dmyoko/teste/a/b/c Note que ele sabe lidar com o fato de que parte do caminho j\u00e1 existe (o diret\u00f3rio /home/dmyoko/teste/ ), e cria apenas os segmentos que n\u00e3o existem. Uma outra conveni\u00eancia desta op\u00e7\u00e3o \u00e9 que ela n\u00e3o resulta em erro, caso voc\u00ea tente criar um diret\u00f3rio que j\u00e1 existe, mesmo que seja o caminho completo. Isto \u00e9 \u00fatil, principalmente para automa\u00e7\u00f5es. mkdir /home/dmyoko/teste/a/b/c #Resulta em erro mkdir -p /home/dmyoko/teste/a/b/c Manipulando hora de acesso e modifica\u00e7\u00e3o de arquivos: touch O comando touch for\u00e7a uma altera\u00e7\u00e3o na data de modifica\u00e7\u00e3o de arquivos. Para entender o que isto significa, vamos rever o resultado do comando ls no screenshot anterior: Observe a coluna imediatamente \u00e0 esquerda do nome do arquivo nesta lista, \u00e9 uma informa\u00e7\u00e3o de Data/Hora. Esta coluna indica a data/hora da \u00faltima modifica\u00e7\u00e3o que este arquivo teve. Ao usar o comando touch , voc\u00ea for\u00e7a uma atualiza\u00e7\u00e3o desta informa\u00e7\u00e3o para a data/hora atual do sistema. Apesar disso parecer algo usado para um prop\u00f3sito muito espec\u00edfico, o comando touch \u00e9 \u00fatil por que, ao ser usado para fazer isto em um arquivo inexistente, ele cria o arquivo. Por exemplo: touch teste.txt Se o arquivo teste.txt n\u00e3o existir, ele ser\u00e1 criado. Caso ele exista, somente a data/hora da \u00faltima modifica\u00e7\u00e3o ser\u00e3o afetados. Isto \u00e9 \u00fatil quando trabalhamos com scripts de automa\u00e7\u00e3o, pois garante a exist\u00eancia do arquivo sem incorrer num erro ao tentar cri\u00e1-lo novamente ou substitu\u00ed-lo acidentalmente. Copiando arquivos com cp O comando cp \u00e9 usado para copiar arquivos. Ele funciona com dois argumentos: - O primeiro argumento \u00e9 o caminho do arquivo de origem, que se deseja copiar - O segudno argumento \u00e9 o caminho do arquivo de destino, para onde se deseja copiar o arquivo de origem Por exemplo: cp teste.txt teste2.txt cp /home/dmyoko/teste /home/dmyoko/teste2 #Funciona com diret\u00f3rios Movendo arquivos com mv Por outro lado, se a inten\u00e7\u00e3o \u00e9 apenas mover arquivos entre caminhos, em vez criar uma c\u00f3pia (fazendo com que o arquivo deixe de existir no caminho de origem), o comando mv pode ser usado de forma semelhante ao cp , passando os mesmos argumentos. mv teste2.txt teste3.txt #Funciona como se o arquivo fosse renomeado mv teste3.txt /home/dmyoko/teste2 mv /home/dmyoko/teste2 /home/dmyoko/teste3 Removendo arquivos com rm Para remover arquivos, usamos o comando rm . Ao contr\u00e1rio dos comandos anteriores cp e mv , o comando rm n\u00e3o afeta diret\u00f3rios por padr\u00e3o. Sendo usado especificamente para arquivos. Por exemplo: rm /home/dmyoko/teste/teste3.txt Para remover diret\u00f3rios, existe o usando o comando rmdir , mas ele funciona apenas com diret\u00f3rios vazios. Se houve qualquer arquivo dentro do diret\u00f3rio, ele se recusa a exclu\u00ed-lo. Por exemplo: rmdir /home/dmyoko/teste Gera esta mensagem de erro: rmdir: failed to remove 'teste': Directory not empty Para remover um diret\u00f3rio n\u00e3o vazio (excluindo seu conte\u00fado em consequ\u00eancia), o comando rm disponibiliza op\u00e7\u00f5es que permitem fazer isto. O motivo de exigir o uso destas op\u00e7\u00f5es \u00e9 evitar que se exclua arquivos por acidente, for\u00e7ando o usu\u00e1rio a fazer o uso deliberado delas para se certificar do que est\u00e1 fazendo. rm -r /home/dmyoko/teste 2.6 Caminho Absoluto, Caminho Relativo e Caracteres Coringa At\u00e9 aqui, temos usado o que chamamos de Caminho Absoluto (Absolute Path) para endere\u00e7ar os arquivos e diret\u00f3rios que usamos. Mas existem atalhos especiais que nos ajudam a facilitar a descri\u00e7\u00e3o de caminhos baseados no diret\u00f3rio atual em que nos localizamos. Uma das op\u00e7\u00f5es dispon\u00edveis no comando ls \u00e9 a op\u00e7\u00e3o -a ou --all , que deixam de ignorar certos arquivos que normalmente n\u00e3o s\u00e3o exibidos. Por padr\u00e3o, os arquivos que come\u00e7am com . (ponto), ficam ocultos normalmente no comando ls . Vamos ver quais arquivos visualizamos ao usar esta op\u00e7\u00e3o: ls -lha Dentre os novos arquivos que antes n\u00e3o eram exibidos, existem dois diret\u00f3rios especiais: . e .. . Estes diret\u00f3rios s\u00e3o usados para nos referirmos a Caminhos Relativos (Relative Paths). O diret\u00f3rio . , aponta para o diret\u00f3rio atual, onde a sess\u00e3o do bash est\u00e1 localizada (o diret\u00f3rio onde voc\u00ea se encontra e que ser\u00e1 exibido com o comando pwd ). J\u00e1 o diret\u00f3rio .. , aponta para o diret\u00f3rio pai do diret\u00f3rio atual, imediatamente superior na hierarquia de diret\u00f3rios, o diret\u00f3rio que antecede o diret\u00f3rio atual na sa\u00edda do comando pwd . Ambos estes diret\u00f3rios podem ser usados como atalho para execu\u00e7\u00e3o de comandos, como os comandos que usamos at\u00e9 aqui: # Criando alguns elementos para demonstrar caminhos relativos cd ~ mkdir -p teste/a/b/c cd teste/a/b touch c/teste.txt cp c/teste.txt .. # copia o arquivo dentro do diret\u00f3rio c para ~/teste/a mv c/teste.txt . # move o arquivo dentro do diret\u00f3rio c para ~/teste/a/b rm ../teste.txt # exclui o arquivo teste.txt do diret\u00f3rio ~/teste/a cp teste.txt ../.. #copia o arquivo teste.txt do diret\u00f3rio atual para ~/teste ls -lha ../.. # lista os arquivos do diret\u00f3rio ~/teste Outro atalho \u00fatil para comandos usando o bash (e outros shells tamb\u00e9m costumam suportar), s\u00e3o Caracteres Coringa (Wild Cards), usados para selecionar arquivos que correspondem com a alguns padr\u00f5es em seus nomes. Para demonstrar isto, vamos antes criar alguns arquivos: cd ~/teste touch foo foo1 foo2 foo10 bar Existem dois caracteres coringas: ? e * . - o ? serve como uma forma de se referir a qualquer caractere que esteja em uma determinada posi\u00e7\u00e3o no nome do arquivo. Por exemplo: ls foo? # Lista todos os arquivos cujo nome come\u00e7am com `foo` e que possuem qualquer outro caractere \u00fanico em seguida Note que, como resultado deste comando, os arquivos foo1 e foo2 foram os \u00fanicos exibidos. Os demais arquivos foram ignorados por n\u00e3o combinarem com o padr\u00e3o, pois foo n\u00e3o possui nenhum caractere na posi\u00e7\u00e3o onde o ? se encontra, e foo10 possui ainda um caractere a mais (j\u00e1 o arquivo bar n\u00e3o corresponde em absolutamente nada com o padr\u00e3o usado). o * serve como uma forma de se referir a quaisquer combina\u00e7\u00e3o de zero ou mais caracteres que possam estar em uma determinada posi\u00e7\u00e3o no nome dos arquivos. Por exemplo: ls foo* Desta vez, s\u00e3o listados todos os arquivos que come\u00e7am com foo , independente de quantos caracteres a mais eles possuem ou n\u00e3o. O arquivo bar , como antes, \u00e9 ignorado por n\u00e3o corresponder ao padr\u00e3o. Voc\u00ea pode usar os caracteres coringa para designar arquivos e diret\u00f3rios como argumentos para qualquer comando do Bash . Por exemplo: rm f?? # apaga somente o arquivo foo cp foo* ./a # copia os arquivos foo1, foo2 e foo10 para ./a mv foo? ./a/b # move somente os arquivos foo1 e foo2 para ./a/b touch * # Atualiza a data/hora de modifica\u00e7\u00e3o de todos os arquivos para a hora atual do sistema 2.7 Conectando Programas Uma das capacidades mais incr\u00edveis do Bash \u00e9 a forma como \u00e9 poss\u00edvel manipular a entrada e sa\u00edda dos programas e conect\u00e1-las de diversas formas para redefinir o comportamento padr\u00e3o dos comandos. Me permita explicar melhor antes, como o Shell lida com a entrada e sa\u00edda dos comandos. 2.7.1 Streams de Entrada e Sa\u00edda (Input/Output Streams) No Shell, programas possuem dois streams prim\u00e1rios associados a eles: o stream de entrada (input), e o stream de sa\u00edda (output). Quando o programa tenta ler a entrada, ele l\u00ea do stream de entrada, e quando ele imprime algo, ele imprime no stream de sa\u00edda. Normalmente, os streams de entrada e sa\u00edda de um programa s\u00e3o o seu terminal (quando rodando a partir do shell). Ou seja, seu teclado (\u00e0 medida que voc\u00ea digita no shell) e a janela do terminal na sua tela. Contudo, n\u00f3s podemos tamb\u00e9m religar estes streams de outras formas. [!IMPORTANT] Streams em computa\u00e7\u00e3o, \u00e9 um termo comum usado para designar um fluxo de dados que n\u00e3o acontece de uma \u00fanica vez, mas que \u00e9 feito de forma cont\u00ednua, ao longo do tempo, em pequenos lotes. Aqui estamos falando de Streams sendo usados para o fluxo cont\u00ednuo de dados de entrada e de sa\u00edda de um comando ou programa executado no shell. Mas o conceito \u00e9 muito comum em diversas outras \u00e1reas da computa\u00e7\u00e3o, como na leitura/escrita de arquivos no disco, ou obtendo/enviando dados atrav\u00e9s da rede/internet. O termo ficou ainda mais popular com a transmiss\u00e3o de conte\u00fado online como chamadas de v\u00eddeo ou transmiss\u00f5es audiovisuais em lives na internet. 2.7.2 Religamento de Streams A forma mais simples de religar streams no Bash \u00e9 atrav\u00e9s dos operadores > (para religar o stream de sa\u00edda do programa) e < (para religar o stream de entrada do programa). Vamos ver alguns exemplos: ls ~ -lha > ~/teste/ls.txt # Religa o stream de sa\u00edda do comando ls para o arquivo ~/teste/ls.txt Note que o comando ls acima n\u00e3o imprimiu a sa\u00edda no terminal como de costume. Por outro lado, voc\u00ea pode conferir um novo arquivo criado no diret\u00f3rio ~/teste chamando ls.txt . Voc\u00ea pode usar o comando cat (que imprime o conte\u00fado de um arquivo no terminal) e voc\u00ea ir\u00e1 notar que o seu conte\u00fado \u00e9 a sa\u00edda do comando ls que teria sido impressa no terminal se n\u00e3o a tiv\u00e9ssemos religado. Uma forma de conferir o conte\u00fado do arquivo ~/teste/ls.txt , \u00e9 o utilizando como stream de entrada do comando cat , que imprime o stream de entrada no stream de sa\u00edda. Ao religar o stream de entrada do comando cat usando o arquivo ~/teste/ls.txt sem religar o stream de sa\u00edda, ele ir\u00e1 imprimir o conte\u00fado no terminal. cat < ~/teste/ls.txt O comando cat , quando n\u00e3o especificado nenhum argumento, usa o terminal como stream de entrada (capturando tudo o que o usu\u00e1rio digitar) e as imprime no stream de sa\u00edda (que tamb\u00e9m \u00e9 o pr\u00f3prio terminal, imprimindo exatamente o que \u00e9 digitado), \u00e0 medida que os dados s\u00e3o enviados (normalmente, sempre que uma linha \u00e9 finalizada). O resultado padr\u00e3o do comando cat , \u00e9 ter suas linhas repetidas, uma vindo pela entrada, e logo em seguida sendo impressa na sa\u00edda. cat # demonstrando os dados digitados no stream de entrada, e impressos na sa\u00edda imediatamente depois Por exemplo, \u00e9 poss\u00edvel usar o cat como um editor de um novo arquivo, que ser\u00e1 criado usando a religa\u00e7\u00e3o do stream de sa\u00edda, digitando o conte\u00fado a partir do stream de entrada. cat > ~/teste/arquivo.txt # Ao digitar conte\u00fado na entrada, ele ser\u00e1 direcionado para o arquivo.txt [!NOTE] Para encerrar a leitura da entrada, n\u00f3s usamos o comando Ctrl+Z. Isto envia um sinal para o processo que est\u00e1 executando o comando cat , orientando-o a parar. Existem outras formas de enviar sinais aos processos quando estamos executando programas no bash, mas veremos isto no futuro. Um outro operador \u00fatil \u00e9 o operador >> . Ele tem, basicamente o mesmo efeito do operador > , que religa o stream de sa\u00edda, com exce\u00e7\u00e3o de que, se a sa\u00edda \u00e9 redirecionada a um arquivo que j\u00e1 existe, ele concatena a sa\u00edda do programa atual ao conte\u00fado original do arquivo, uma opera\u00e7\u00e3o popularmente conhecida na computa\u00e7\u00e3o como append . Ou seja, o conte\u00fado original do arquivo \u00e9 mantido, e o novo conte\u00fado \u00e9 enviado ao final dele. ls -lha ~ >> ~/teste/arquivo.txt Note que o conte\u00fado original do arquivo.txt foi mantido, e o resultado do comando ls foi inserido depois da \u00faltima linha original. Existe um operador que conecta a sa\u00edda de um comando do bash \u00e0 entrada de outro comando, criando uma cadeia de comandos, ou \"esteira\" ( pipeline ), de etapas pelas quais os dados resultantes de um programa s\u00e3o aplicados ao outro, sendo transformados at\u00e9 produzirem uma sa\u00edda desejada. Este operador \u00e9 o | ( pipe ). ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt Aqui temos uma pipeline que faz a seguinte sequ\u00eancia: - ls -lha ~ - lista todos os arquivos da pasta home , em formato de lista, com tamanhos humanamente leg\u00edveis, e inclindo os arquivos ocultos (que come\u00e7am com . ) - grep Jul - o comando grep filtra as linhas vindas da entrada de acordo com algum padr\u00e3o (no caso, Jul ). Basicamente ele pega o resultado do ls e separa somente os arquivos modificados em Julho - head -5 - O comando head toma somente as primeiras linhas da entrada. Por padr\u00e3o, ele toma somente as primeiras 10, mas a op\u00e7\u00e3o -5 faz com que ele pegue somente as primeiras 5 e ignore as demais linhas. - tee /<caminho> - O comando tee \u00e9 um comando similar ao comando cat , com a diferen\u00e7a que, al\u00e9m de imprimir no stream de sa\u00edda, ele tamb\u00e9m escreve o arquivo. No caso acima, ele escreve no terminal e no arquivo /home/dmyoko/teste/pipeline.txt . - Por exemplo, \u00e9 poss\u00edvel criar dois arquivos a partir do comando tee : ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt > /home/dmyoko/teste/pipeline2.txt A linha acima instrui instrui o tee a escrever a entrada no arquivo /home/dmyoko/teste/pipeline.txt e religa o stream de sa\u00edda para o arquivo /home/dmyoko/teste/pipeline2.txt usando o operador > . Imagine talvez, usar o operador >> nesta linha, e qual ser\u00e1 o resultado. Como isso iria diferir ambos os arquivos. N\u00f3s iremos usar muito o operador de pipe ( | ) na aula em que iremos tratar de Manipula\u00e7\u00e3o de Dados no Shell. 2.8 Comandos \u00dateis man O comando man exibe um manual de diversos comandos do bash . Usa-se passando como argumento o nome do comando que se deseja consultar: man mkdir find O comando find ajuda a localizar arquivos, procurando n\u00e3o somente no diret\u00f3rio usado como argumento, mas automaticamente buscando em todos os seus subdiret\u00f3rios. Se um diret\u00f3rio n\u00e3o for passado como argumento, o comando find usa o diret\u00f3rio atual por padr\u00e3o. Ele aceita diversas op\u00e7\u00f5es para ajudar a encontrar arquivos de acordo com crit\u00e9rios espec\u00edficos, como o nome do arquivo (op\u00e7\u00e3o -name seguido do nome que se busca, para usar coringas \u00e9 necess\u00e1rio delimitar com ap\u00f3strofos), e muitas outras op\u00e7\u00f5es \u00fateis. Consulte o manual ( man find ) para ler sobre todas as op\u00e7\u00f5es dispon\u00edveis. date Imprime a data/hora atual do sistema. Existem diversas op\u00e7\u00f5es de formata\u00e7\u00e3o em que a Data/Hora ser\u00e3o impressas, para saber mais consulte as p\u00e1ginas do Manual ( man date ) diff Imprime as diferen\u00e7as entre o conte\u00fado de dois caminhos, que precisam ser especificados via argumentos. Podendo ser ambos diret\u00f3rios ou arquivos, mas n\u00e3o compara se forem de tipos diferentes. history Imprime no terminal o hist\u00f3rico de comandos usados nesta sess\u00e3o do Bash . tail O comando tail \u00e9 parecido com o comando head , com a diferen\u00e7a de que, em vez de tomar somente as primeiras x linhas da entrada e ignorar as demais, ele toma somente as \u00faltimas x linhas e ignora as primeiras. less O comando less \u00e9 \u00f3timo para ser usado com comandos que resultam em um n\u00famero elevado de linhas. Ele exibe o resultado de forma paginada e interativa, te permitindo controlar a navega\u00e7\u00e3o pelos dados. 3. Conclus\u00e3o Nesta aula tivemos um contato bastante profundo com o Bash e a abordagem de trabalhar a partir de um Shell . Ainda temos muito o que explorar pra explorarmos o shell e conseguir fazer dele um lugar onde possamos nos sentir mais confort\u00e1veis e produtivos o suficiente para fazer dele nosso lugar de trabalho. Mas nas pr\u00f3ximas aulas, ficaremos cada vez mais pr\u00f3ximos disto. Com esta introdu\u00e7\u00e3o, podemos explorar outras ferramentas, como a constru\u00e7\u00e3o de scripts, manipular dados e aprender as conven\u00e7\u00f5es de como \u00e9 a vida na interface de linha de comando ( Command Line Interface ou, simplesmente, CLI ). Bem-vindo a esta jornada, e espero que este primeiro passeio tenha despertado o interesse em prosseguir com as pr\u00f3ximas aulas. Pr\u00f3xima Aula: Aula 2 - Criando Scripts com Bash","title":"Aula 1 - O Shell"},{"location":"aulas/01-shell/#aula-1-o-shell","text":"Nesta primeira aula do nosso curso, apresentaremos o Shell como uma ferramenta prim\u00e1ria de produtividade das pessoas que trabalham em diversas \u00e1reas de TI. Quando navegamos pela internet atrav\u00e9s do uso de um Web Browser , ou usamos algum app ou qualquer aplicativo com uma interface gr\u00e1fica, estamos limitados ao que esta interface suporta. Se existe um bot\u00e3o dispon\u00edvel para uma determinada funcionalidade, a visibilidade deste bot\u00e3o \u00e9 o que determina se podemos nos beneficiar desta dela ou n\u00e3o. Se o bot\u00e3o n\u00e3o est\u00e1 vis\u00edvel, n\u00e3o podemos clicar nele. Uma interface de linha de comando ( CLI ), como a que temos quando usamos um Shell , torna mais flex\u00edvel o acesso que temos \u00e0s funcionalidades dispon\u00edveis. Saber usar o Shell e navegar por ele potencialmente torna o trabalho cotidiano mais produtivo e, por isto, estamos dando o devido foco em apresent\u00e1-lo neste curso.","title":"Aula 1 - O Shell"},{"location":"aulas/01-shell/#1-o-que-e-o-shell","text":"Quase todas as plataformas com as quais voc\u00ea pode trabalhar atualmente oferecem um Shell , e muitas oferecem diferentes op\u00e7\u00f5es de Shell para voc\u00ea escolher. Apesar de que eles possam variar em seus detalhes, em sua ess\u00eancia s\u00e3o basicamente iguais: eles te permitem executar programas, manipular sua entrada ( input ) e inspecionar sua sa\u00edda ( output ) de uma forma semi-estruturada.","title":"1. O que \u00e9 o Shell"},{"location":"aulas/01-shell/#11-shell-vs-terminal","text":"Para ter acesso a um Shell, voc\u00ea precisa de um Terminal . Um terminal \u00e9 um programa capaz de receber um comando, encaminhar para o Shell , e exibir seu resultado. O sistema que voc\u00ea usa em seu computador provavelmente possui um terminal dispon\u00edvel. Para os usu\u00e1rios de Windows (a partir do Windows 11), t\u00eam instalado em seu sistema o Windows Terminal . Para usu\u00e1rios de vers\u00f5es anteriores, o Windows Terminal est\u00e1 dispon\u00edvel para download gratuito na Microsoft Store. Outras op\u00e7\u00f5es de terminal para os usu\u00e1rios Windows s\u00e3o o ConEmu e o Cmder . J\u00e1 para os usu\u00e1rios de Linux/MacOS, existem diversas op\u00e7\u00f5es de terminal. Um dos terminais mais famosos para os usu\u00e1rios MacOS \u00e9 o iTerm2 . No Linux, entre os terminais mais usados est\u00e3o o Terminator e o Guake . Escolher entre as diferentes op\u00e7\u00f5es de terminais normalmente depende das funcionalidades e conveni\u00eancias que cada op\u00e7\u00e3o oferece. Pain\u00e9is ( tiles ), Guias( tabs ), Teclas de Atalho, Esquemas de Cores, e outras facilidades podem diferenciar as op\u00e7\u00f5es de terminais, mas de uma forma ou de outra, a maioria dos terminais dispon\u00edveis oferecem estas e outras funcionalides com algumas diferen\u00e7as sutis de como elas funcionam.","title":"1.1 Shell vs Terminal"},{"location":"aulas/01-shell/#12-diferentes-shells","text":"Al\u00e9m dos diferentes sabores de terminais, existem tamb\u00e9m diferentes op\u00e7\u00f5es de Shells. Cada Shell pode apresentar uma sintaxe diferente de comandos e da forma como voc\u00ea interage atrav\u00e9s do terminal, apesar de haver muitas semelhan\u00e7as entre as principais op\u00e7\u00f5es. Para os usu\u00e1rios Windows, as duas principais op\u00e7\u00f5es de Shell dispon\u00edveis s\u00e3o: cmd O cmd \u00e9 o shell nativo do Windows, baseado no Prompt de Comando do antigo MS-DOS (sistema operacional da Microsoft anterior ao Windows). Ele suporta basicamente os comandos b\u00e1sicos do MS-DOS para navegar e manipular o sistema de arquivos. Windows PowerShell O PowerShell \u00e9 um Shell moderno criado pela Microsoft, como uma alternativa mais poderosa que o cmd para os usu\u00e1rios Windows. No mundo Linux e MacOS, existem op\u00e7\u00f5es similares de Shell, dentre elas as mais comuns s\u00e3o: Bash O Bash ( Bourne Again Shell ) \u00e9 uma op\u00e7\u00e3o de Shell dispon\u00edvel para Linux e MacOS baseado no Bourne Shell , que \u00e9 um Shell popular para o sistema Unix . Zsh O Zsh (z-shell) \u00e9 uma alternativa ao Bash que apresenta funcionalidades comuns, e acrescenta outras funcionalidades baseadas em outras famosas op\u00e7\u00f5es de Shell do sistema Unix (como o ksh e o tcsh ), al\u00e9m de trazer funcionalidades \u00fanicas.","title":"1.2 Diferentes Shells"},{"location":"aulas/01-shell/#2-bash-bourne-again-shell","text":"Bash \u00e9 o shell mais popular atualmente, sendo a op\u00e7\u00e3o pr\u00e9-instalada no Ubuntu, que \u00e9 a distribui\u00e7\u00e3o do Linux mais baixada, al\u00e9m \u00e9 claro de fazer parte de outras distribui\u00e7\u00f5es tamb\u00e9m. Por causa da sua relev\u00e2ncia, toda a discuss\u00e3o relacioana a Shells ao longo deste curso, quando n\u00e3o abordada de uma forma generalista, usar\u00e1 como premissa o uso do bash . Para acompanhar o conte\u00fado deste curso, certifique-se de ter instalado o bash como uma das op\u00e7\u00f5es de Shell dispon\u00edveis no seus sistema. Usu\u00e1rios Linux e MacOS provavelmente j\u00e1 possuir\u00e3o o bash instalado, caso contr\u00e1rio, provavelmente encontrar\u00e3o uma f\u00e1cil instala\u00e7\u00e3o a partir de algum dos gerenciadores de pacote que seus sistemas disponibilizam.","title":"2. Bash (Bourne Again SHell)"},{"location":"aulas/01-shell/#21-bash-para-usuarios-windows","text":"Para aqueles que acompanham este curso e s\u00e3o usu\u00e1rios do Microsoft Windows, existem op\u00e7\u00f5es de instala\u00e7\u00e3o do Bash. Vamos apresentar 3 delas para que voc\u00ea escolher a que melhor lhe for mais conveniente. MinGW64 / Cygwin Das op\u00e7\u00f5es dispon\u00edveis para se instalar o Bash no Windows, o MinGW64 e o Cygwin se diferenciam por n\u00e3o precisar virtualizar um outro sistema (como Linux). Ambos os projetos podem ser instalados em qualquer vers\u00e3o do Windows e fornecem um conjunto de ferramentas para criar um ambiente compat\u00edvel com um sistema semelhante ao Unix para pessoas que preferem trabalhar usando o Windows. O Bash disponibilizado por estas ferramentas, n\u00e3o \u00e9 totalmente compat\u00edvel com o Bash que voc\u00ea usaria ao criar uma instala\u00e7\u00e3o do Ubuntu, por exemplo, mas pode ser o suficiente para quem prefere n\u00e3o virtualizar (ou n\u00e3o pode). Para instalar o MinGW64, acesse o site: https://www.mingw-w64.org/downloads/ [!TIP] Se voc\u00ea instalar o Git para Windows (haver\u00e3o aulas neste curso que usar\u00e3o o Git), ele inclui o MinGW64 para disponibilizar um shell chamado Git Bash. Se voc\u00ea preferir instalar o Cygwin, o endere\u00e7o no site para baixar o instalador \u00e9: https://cygwin.com/install.html Criar um Memory Stick Inicializ\u00e1vel com uma distribui\u00e7\u00e3o do Linux \u00c9 poss\u00edvel ter uma distribui\u00e7\u00e3o do Linux dispon\u00edvel para uso sem precisar instal\u00e1-la no seu sistema, usando um Memory Stick (vulgo: Pen Drive) inicializ\u00e1vel. Existem diversos tutoriais na dispon\u00edveis na internet explicando com realizar o processo. Mas, resumidamente, voc\u00ea precisa baixar a imagem do sistema operacional (por exemplo, Ubuntu), e um programa capaz de configurar um Memory Stick com a imagem de forma inicializ\u00e1vel. [!WARNING] Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows. Dual Boot com Linux Voc\u00ea pode criar uma instala\u00e7\u00e3o do Linux lado a lado com a instala\u00e7\u00e3o do Windows e ter a op\u00e7\u00e3o no seu dispositivo de qual dos sistemas voc\u00ea pretende usar no momento da inicializa\u00e7\u00e3o. [!WARNING] Esta op\u00e7\u00e3o torna necess\u00e1rio que voc\u00ea reincie o seu computador, e durante o uso do sistema escolhido, voc\u00ea n\u00e3o ter\u00e1 acesso aos recursos do Windows. [!WARNING] Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) se tornem exclusivos para o novo sistema, tornando-os indispon\u00edveis para o Windows. Isto requer algum planejamento sobre como estes recursos ser\u00e3o distribu\u00eddos. Virtualiza\u00e7\u00e3o de Linux Criar uma M\u00e1quina Virtual ( VM ) com uma instala\u00e7\u00e3o do Linux \u00e9 uma op\u00e7\u00e3o acess\u00edvel e, certamente, mais conveniente que a op\u00e7\u00e3o com Dual Boot. Uma VM \u00e9, basicamente, um computador virtual, com as mesmas funcionalidades que um dispositivo oferece, por\u00e9m, emulado a partir de um Sistema Hospedeiro (no caso, o Windows). Voc\u00ea pode criar VMs usando softwares gratuitos como o HyperV do Windows ou VirtualBox da Oracle , e baixar uma imagem da distribui\u00e7\u00e3o Linux desejada (por exemplo, Ubuntu), para criar uma VM. Independente de qual plataforma voc\u00ea pretende usar, voc\u00ea vai precisar ativar o Hypervisor do Windows (que \u00e9 parte integrante da instala\u00e7\u00e3o do HyperV). Para isto, no menu iniciar (pressionando a tecla Windows no teclado), digite \"Ativar ou Desativar Recursos do Windows\", e ao abrir a janela dos Recursos do Windows, procure na lista o \u00edtem \"Hyper-V\" e certifique-se de que ele esteja selecionado. Ativar este recurso, ir\u00e1 exigir que voc\u00ea reinicialize seu computador . [!WARNING] Este m\u00e9todo exige que alguns recursos (por exemplo, espa\u00e7o em disco) sejam compartilhados com a VM, podendo ter um impacto na performance do sistema hospedeiro. Windows Subsystem for Linux (WSL) Para usu\u00e1rios de vers\u00f5es mais recentes do Windows (a partir do Windows 10), \u00e9 poss\u00edvel virtualizar uma distribui\u00e7\u00e3o Linux usando um Kernel dispon\u00edvel pelo pr\u00f3prios Windows. Este \u00e9, inclusive, o m\u00e9todo que eu estou usando. \u00c9 um m\u00e9todo melhor do que criar uma VM, pois o WSL suporta uma integra\u00e7\u00e3o transparente entre os sistemas (compartilhando portas e programas). Este m\u00e9todo tamb\u00e9m exige que voc\u00ea ative o HyperV , al\u00e9m de ativar tamb\u00e9m o \"Subsistema do Windows para Linux\", e instalar a distribui\u00e7\u00e3o escolhida (por exemplo, Ubuntu), a partir das op\u00e7\u00f5es dispon\u00edveis na Microsoft Store.","title":"2.1 Bash para Usu\u00e1rios Windows"},{"location":"aulas/01-shell/#22-apresentando-o-ambiente-de-shell-com-bash","text":"Ao abrir o terminal de sua escolha para acessar um Shell, invariavelmente voc\u00ea ir\u00e1 encontrar algo muito parecido com a imagem a seguir. Uma janela vazia (normalmente com fundo escuro), mostrando no topo um texto com algumas informa\u00e7\u00f5es \u00faties e um cursor piscando, esperando que voc\u00ea digite algo. As informa\u00e7\u00f5es exibidas podem variar de um computador para o outro j\u00e1 que elas se baseiam nas configura\u00e7\u00f5es do usu\u00e1rio. No caso do meu shell, exibido acima, as informa\u00e7\u00f5es exibidas s\u00e3o: [!IMPORTANT] dmyoko@CodandoComOTio:~/projects/coisas-que-nao-ensinam-em-ti$ - Nome do usu\u00e1rio logado na sess\u00e3o - O @ (arroba) separa o nome do usu\u00e1rio do nome do servidor da sess\u00e3o - O nome do servidor da sess\u00e3o - Os dois pontos ( : ) separam os dados da sess\u00e3o do caminho do diret\u00f3rio atual onde >o shell ir\u00e1 aplicar os comandos - No Bash, o caractere que separa os segmentos do caminho \u00e9 / , diferente do >Windows que usa \\ (barra invertida) - O cifr\u00e3o ( $ ) no final, indica que o shell n\u00e3o est\u00e1 no modo super user. O nome desta linha, contendo estas ou quaisquer outras informa\u00e7\u00f5es de acordo com a configura\u00e7\u00e3o do shell, e o cursor esperando a entrada de um comando, \u00e9 Prompt . A partir daqui, qualquer texto digitado ser\u00e1 interpretado como um comando dado ao shell. Este comando pode servir para executar programas, rodar scripts ou executar comandos nativos do pr\u00f3prio shell. A partir do momento em que algo \u00e9 digitado e enviado para o shell (normalmente atrav\u00e9s do pressionamento da tecla Enter ou Return), o shell executa a linha digitada e o terminal imprime qualquer que seja o resultado (output) da execu\u00e7\u00e3o. Por exmeplo, uma instru\u00e7\u00e3o simples como pwd (que imprime o diret\u00f3rio atual do shell), pode demonstrar este fluxo. Ao inserir esta instru\u00e7\u00e3o e pressionar Enter (ou Return), o diret\u00f3rio \u00e9 exibido na linha abaixo da linha onde o comando foi dado, e na linha seguinte, um novo prompt \u00e9 exibido. O modo como trabalhamos no ambiente de Shell \u00e9 um ciclo: - Um prompt \u00e9 exibido indicando que o shell est\u00e1 pronto para receber comandos atrav\u00e9s do terminal - Um comando \u00e9 digitado no terminal e enviado ao shell - O shell interpreta o comando enviado e o executa - Qualquer resultado direcionado para a sa\u00edda ( output ) do shell \u00e9 exibido pelo terminal Com isto, podemos agora explorar um pouco alguns comandos que o Bash nos fornece.","title":"2.2 Apresentando o ambiente de Shell com Bash"},{"location":"aulas/01-shell/#23-navegando-com-o-shell","text":"Vamos come\u00e7ar a explorar os comandos do Bash, aprendendo primeiro a navegar pelo sistema de arquivos. Exibindo o diret\u00f3rio atual: pwd Como vimos agora h\u00e1 poudo, o comando pwd ( Print Working Directory ), imprime no terminal o caminho do diret\u00f3rio atual onde o Shell ir\u00e1 executar o pr\u00f3ximo comando. Saber qual \u00e9 o diret\u00f3rio atual \u00e9 importante, por que isto pode afetar diretamente o resultado do pr\u00f3ximo comando. Por exemplo, se o pr\u00f3ximo comando resultar na cria\u00e7\u00e3o de um arquivo, o arquivo ser\u00e1 criado no diret\u00f3rio atual, exceto se algum par\u00e2metro espec\u00edfico seja usado para mudar este comportamento (salvo, \u00e9 claro, se o programa executado tiver instru\u00e7\u00f5es espec\u00edficas do caminho do arquivo). Mudando o diret\u00f3rio atual: cd Para mudar o diret\u00f3rio atual da sess\u00e3o do Shell, o comando usado \u00e9 o cd ( Change Directory ). Se voc\u00ea digitar apenas cd e pressionar Enter, ele vai mudar o diret\u00f3rio atual para ~ (falaremos logo a seguir sobre que diret\u00f3rio \u00e9 este). Ele n\u00e3o imprime nenhuma sa\u00edda, e imediatamente um novo prompt \u00e9 apresentado. Para informar o comando cd para que ele mude para um diret\u00f3rio diferente, um argumento precisa ser usado. [!NOTE] Argumentos : s\u00e3o complementos que damos aos comandos, normalmente digitando-os a seguir do comando propriamente dito. Por exemplo, no comando cd teste , teste \u00e9 o argumento passado para o comando cd . Neste caso, o comando cd vai mudar mudar o diret\u00f3rio atual para o diret\u00f3rio teste . cd teste No meu caso, uma mensagem de erro \u00e9 exibida: bash: cd: teste: No such file or directory Ela diz que n\u00e3o existe um arquivo ou diret\u00f3rio chamado teste . Note, executando o comando pwd novamente, que o diret\u00f3rio atual permanece o mesmo. Para mudar o diret\u00f3rio atual, precisamos passar como argumento, o endere\u00e7o de um diret\u00f3rio existente. Por exemplo, um diret\u00f3rio que com certeza existe no sistema de arquivos \u00e9 o diret\u00f3rio raiz, que fica no endere\u00e7o / . cd / No meu caso, como voc\u00ea pode ver, o meu prompt mudou, agora dizendo que o diret\u00f3rio atual \u00e9 / (o diret\u00f3rio raiz). Se o seu prompt n\u00e3o exibe esta informa\u00e7\u00e3o como o meu, voc\u00ea pode confirmar usando o comando pwd . Outro diret\u00f3rio comum para quem usa o Bash, \u00e9 o diret\u00f3rio Home , representado pelo caractere ~ . Voc\u00ea pode testar o comando: cd ~ Como pode ver, no meu prompt, agora ele exibe ~ como diret\u00f3rio atual, e n\u00e3o mais o diret\u00f3rio raiz ( / ). Ao contr\u00e1rio do diret\u00f3rio raiz, se voc\u00ea usar o comando pwd agora voc\u00ea vai notar que o diret\u00f3rio Home ( ~ ), na verdade, aponta para um diret\u00f3rio espec\u00edfico a partir da raiz. No meu caso, /home/dmyoko (no seu caso, vai apontar para um diret\u00f3rio com o nome do seu usu\u00e1rio dentro do diret\u00f3rio /home ). Voc\u00ea pode navegar manualmente por estes diret\u00f3rios, usando o caminho que os leva at\u00e9 eles. Por exemplo: cd / cd home cd dmyoko Uma vez no diret\u00f3rio / (raiz), voc\u00ea tem acesso ao diret\u00f3rio home , e uma vez que voc\u00ea entra no diret\u00f3rio home , voc\u00ea tem acesso ao diret\u00f3rio do seu usu\u00e1rio, no meu caso dmyoko . Voc\u00ea tamb\u00e9m pode navegar direto para o diret\u00f3rio espec\u00edfico, usando o caminho completo absoluto que leva at\u00e9 ele, come\u00e7ando pelo diret\u00f3rio raiz. cd / cd /home/dmyoko [!NOTE] Caminho absoluto \u00e9 o caminho completo que leva at\u00e9 um diret\u00f3rio ou arquivo no sistema de arquivos. Ele sempre come\u00e7a pelo diret\u00f3rio / (raiz), e segue toda a hierarquia de segmentos necess\u00e1rios at\u00e9 chegar no diret\u00f3rio ou arquivo desejado. Listar informa\u00e7\u00f5es sobre o conte\u00fado de um diret\u00f3rio: ls O comando ls \u00e9 \u00fatil quando voc\u00ea deseja entender o conte\u00fado de um determinado diret\u00f3rio. Se voc\u00ea digitar somente ls , o Bash imprimir\u00e1 no terminal o conte\u00fado do diret\u00f3rio atual. Se voc\u00ea quiser listar o conte\u00fado de outro diret\u00f3rio sem necessariamente sair do diret\u00f3rio atual, basta usar como argumento o caminho para o diret\u00f3rio do qual voc\u00ea pretende listar o conte\u00fado desejado. ls / O comando acima, lista o conte\u00fado do diret\u00f3rio / (raiz). Voc\u00ea pode tamb\u00e9m listar o conte\u00fado de um dos subdiret\u00f3rios do diret\u00f3rio raiz, informando o endere\u00e7o dele. Por exemplo: ls /bin ls /lib ls /sys/devices/cpu O comando ls tamb\u00e9m suporta op\u00e7\u00f5es, que podem influenciar no resultado do comando. Por exemplo, a op\u00e7\u00e3o -l exibe o resultado do comando ls no formato de lista, trazendo informa\u00e7\u00f5es adicionais a respeito do conte\u00fado do diret\u00f3rio, que antes n\u00e3o estavam sendo exibidas, como as permiss\u00f5es de acesso ao diret\u00f3rio/arquivo listado, informa\u00e7\u00f5es de quem \u00e9 o usu\u00e1rio dono deste diret\u00f3rio/arquivo e a que grupo ele pertence (usu\u00e1rio dmyoko do grupo dmyoko , por exemplo), o tamanho do arquivo/diret\u00f3rio em bytes, e a data da \u00faltima vez que o arquivo/diret\u00f3rio foi modificado. ls -l Outra op\u00e7\u00f5a \u00fatil \u00e9 o -h , que faz com que os tamanhos dos arquivos exibidos sejam impressos num formato humanamente leg\u00edvel (human readable). ls -h # sem efeito, pois os tamanhos n\u00e3o s\u00e3o exibidos ls -l -h # agora \u00e9 poss\u00edvel ver o efeito. ls -lh # \u00e9 poss\u00edvel unir todas as op\u00e7\u00f5es em uma \u00fanica cl\u00e1usula Existem outras diversas op\u00e7\u00f5es dispon\u00edveis para o comando ls . Para ter acesso a uma lista completa delas, voc\u00ea pode digitar ls --help . [!TIP] --help \u00e9 uma op\u00e7\u00e3o dispon\u00edvel na vasta maioria dos comandos que voc\u00ea pode executar no shell. E, invariavelmente, imprime informa\u00e7\u00f5es sobre o que o comando faz e como utiliz\u00e1-lo, inclusive, mostrando poss\u00edveis op\u00e7\u00f5es que afetam a forma como este comando se comporta.","title":"2.3 Navegando com o Shell"},{"location":"aulas/01-shell/#24-permissoes-de-arquivos-e-diretorios","text":"Eu mencionei que a primeira coluna exibida como resultado do ls -l s\u00e3o as permiss\u00f5es dos arquivos ou diret\u00f3rios listados. Estas permiss\u00f5es indicam quem pode fazer o que com estes artefatos. Para dar uma breve explica\u00e7\u00e3o, vamos entender como estas informa\u00e7\u00f5es s\u00e3o exibidas: Cada caractere exibido nesta coluna representa um atributo do artefato ao qual ele est\u00e1 ligado. O primeiro caractere, por exemplo, indica que tipo de artefato \u00e9 o item da lista. Um simples - indica que ele \u00e9 apenas um arquivo, e um d indica que ele \u00e9 um diret\u00f3rio. Existem outros tipos, que podemos discutir no futuro. Os demais caracteres s\u00e3o agrupamentos de 3 caracteres, cada caractere simbolizando uma permiss\u00e3o espec\u00edfica: rwx . - r : representa a permiss\u00e3o para leitura - w : representa a permiss\u00e3o para escrita - x : representa a permiss\u00e3o para execu\u00e7\u00e3o Os 3 caracteres est\u00e3o sempre nesta ordem, e podem ser substitu\u00eddos por um - , indicando que a devida opera\u00e7\u00e3o n\u00e3o \u00e9 permitida. Por exemplo: rwx : Todas as opera\u00e7\u00f5es s\u00e3o permitidas rw- : \u00c9 permitido ler e alterar o arquivo, mas n\u00e3o \u00e9 permitido execut\u00e1-lo r-- : S\u00f3 se tem acesso para ler o conte\u00fado do arquivo, mas n\u00e3o \u00e9 permitido alter\u00e1-lo. Estas permiss\u00f5es s\u00e3o exibidas na seguinte ordem: - Permiss\u00f5es para o dono do arquivo - Permiss\u00f5es para os demais usu\u00e1rios do grupo dono do arquivo - Permiss\u00f5es para todos os demais usu\u00e1rios Por exemplo (retirado do screenshot acima): drwxr-xr-x 2 root root 4096 Mar 25 2022 X11 Esta linha diz que X11 \u00e9 um diret\u00f3rio ( d ), o dono (que \u00e9 o usu\u00e1rio root ) possui permiss\u00e3o de leitura, escrita e execu\u00e7\u00e3o, enquanto que os outros membros do grupo root podem apenas ler o conte\u00fado e execut\u00e1-lo, bem como todos os outros usu\u00e1rios. [!IMPORTANT] Em um diret\u00f3rio , a permiss\u00e3o de execu\u00e7\u00e3o significa que o usu\u00e1rio \u00e9 capaz de navegar por ele (atrav\u00e9s do comando cd ). A permiss\u00e3o de leitura significa que o usu\u00e1rio \u00e9 capaz de listar o conte\u00fado (atrav\u00e9s do comando ls ) ou procurar por arquivos, etc. E a permiss\u00e3o de escrita significa que o usu\u00e1rio \u00e9 capaz de criar novos artefatos (arquivos, diret\u00f3rios, etc) dentro do diret\u00f3rio.","title":"2.4 Permiss\u00f5es de arquivos e diret\u00f3rios"},{"location":"aulas/01-shell/#25-manipulacao-do-sistema-de-arquivos","text":"Agora que sabemos como navegar e obter informa\u00e7\u00f5es sobre o conte\u00fado do sistema de arquivos, vamos aprender como manipular o conte\u00fado dos diret\u00f3rios, criando, modificando e excluindo arquivos e diret\u00f3rios usando comandos do Shell. Criando diret\u00f3rios: mkdir Para criar novos diret\u00f3rios, usamos o comando mkdir passando como argumento o nome do diret\u00f3rio que queremos criar. cd ~ #Certifique-se de estar no seu diret\u00f3rio `home` mkdir teste O diret\u00f3rio teste ser\u00e1 criado no diret\u00f3rio atual, no caso, o diret\u00f3rio home . Voc\u00ea tamb\u00e9m pode criar um diret\u00f3rio em um lugar diferente do diret\u00f3rio atual, usando o endere\u00e7o completo desejado. mkdir /home/dmyoko/teste/tmp [!WANING] Espa\u00e7os importam! Tome cuidado com o uso de espa\u00e7os quando estiver executando opera\u00e7\u00f5es no shell. Por exemplo, se voc\u00ea digitar o comando mkdir minhas fotos , ao inv\u00e9s de criar um diret\u00f3rio chamado minhas fotos , ele ir\u00e1 criar dois diret\u00f3rios, um chamado minhas e um segundo chamado fotos . Para usar espa\u00e7os voc\u00ea pode usar caracteres de escape. Para usar caracteres de escape, voc\u00ea usa a \\ (barra invertida). Por exemplo: mkdir Minhas\\ Fotos # Cria um diret\u00f3rio chamado `Minhas Fotos` Voc\u00ea pode, tamb\u00e9m, delimitar o nome usando aspas ( \" ) ou ap\u00f3strofos ( ' ), como uma forma de indicar o nome sem usar caracteres de escape. O comando mkdir possui uma op\u00e7\u00e3o -p que permite que voc\u00ea crie um caminho completo de diret\u00f3rios: mkdir -p /home/dmyoko/teste/a/b/c Note que ele sabe lidar com o fato de que parte do caminho j\u00e1 existe (o diret\u00f3rio /home/dmyoko/teste/ ), e cria apenas os segmentos que n\u00e3o existem. Uma outra conveni\u00eancia desta op\u00e7\u00e3o \u00e9 que ela n\u00e3o resulta em erro, caso voc\u00ea tente criar um diret\u00f3rio que j\u00e1 existe, mesmo que seja o caminho completo. Isto \u00e9 \u00fatil, principalmente para automa\u00e7\u00f5es. mkdir /home/dmyoko/teste/a/b/c #Resulta em erro mkdir -p /home/dmyoko/teste/a/b/c Manipulando hora de acesso e modifica\u00e7\u00e3o de arquivos: touch O comando touch for\u00e7a uma altera\u00e7\u00e3o na data de modifica\u00e7\u00e3o de arquivos. Para entender o que isto significa, vamos rever o resultado do comando ls no screenshot anterior: Observe a coluna imediatamente \u00e0 esquerda do nome do arquivo nesta lista, \u00e9 uma informa\u00e7\u00e3o de Data/Hora. Esta coluna indica a data/hora da \u00faltima modifica\u00e7\u00e3o que este arquivo teve. Ao usar o comando touch , voc\u00ea for\u00e7a uma atualiza\u00e7\u00e3o desta informa\u00e7\u00e3o para a data/hora atual do sistema. Apesar disso parecer algo usado para um prop\u00f3sito muito espec\u00edfico, o comando touch \u00e9 \u00fatil por que, ao ser usado para fazer isto em um arquivo inexistente, ele cria o arquivo. Por exemplo: touch teste.txt Se o arquivo teste.txt n\u00e3o existir, ele ser\u00e1 criado. Caso ele exista, somente a data/hora da \u00faltima modifica\u00e7\u00e3o ser\u00e3o afetados. Isto \u00e9 \u00fatil quando trabalhamos com scripts de automa\u00e7\u00e3o, pois garante a exist\u00eancia do arquivo sem incorrer num erro ao tentar cri\u00e1-lo novamente ou substitu\u00ed-lo acidentalmente. Copiando arquivos com cp O comando cp \u00e9 usado para copiar arquivos. Ele funciona com dois argumentos: - O primeiro argumento \u00e9 o caminho do arquivo de origem, que se deseja copiar - O segudno argumento \u00e9 o caminho do arquivo de destino, para onde se deseja copiar o arquivo de origem Por exemplo: cp teste.txt teste2.txt cp /home/dmyoko/teste /home/dmyoko/teste2 #Funciona com diret\u00f3rios Movendo arquivos com mv Por outro lado, se a inten\u00e7\u00e3o \u00e9 apenas mover arquivos entre caminhos, em vez criar uma c\u00f3pia (fazendo com que o arquivo deixe de existir no caminho de origem), o comando mv pode ser usado de forma semelhante ao cp , passando os mesmos argumentos. mv teste2.txt teste3.txt #Funciona como se o arquivo fosse renomeado mv teste3.txt /home/dmyoko/teste2 mv /home/dmyoko/teste2 /home/dmyoko/teste3 Removendo arquivos com rm Para remover arquivos, usamos o comando rm . Ao contr\u00e1rio dos comandos anteriores cp e mv , o comando rm n\u00e3o afeta diret\u00f3rios por padr\u00e3o. Sendo usado especificamente para arquivos. Por exemplo: rm /home/dmyoko/teste/teste3.txt Para remover diret\u00f3rios, existe o usando o comando rmdir , mas ele funciona apenas com diret\u00f3rios vazios. Se houve qualquer arquivo dentro do diret\u00f3rio, ele se recusa a exclu\u00ed-lo. Por exemplo: rmdir /home/dmyoko/teste Gera esta mensagem de erro: rmdir: failed to remove 'teste': Directory not empty Para remover um diret\u00f3rio n\u00e3o vazio (excluindo seu conte\u00fado em consequ\u00eancia), o comando rm disponibiliza op\u00e7\u00f5es que permitem fazer isto. O motivo de exigir o uso destas op\u00e7\u00f5es \u00e9 evitar que se exclua arquivos por acidente, for\u00e7ando o usu\u00e1rio a fazer o uso deliberado delas para se certificar do que est\u00e1 fazendo. rm -r /home/dmyoko/teste","title":"2.5 Manipula\u00e7\u00e3o do sistema de arquivos"},{"location":"aulas/01-shell/#26-caminho-absoluto-caminho-relativo-e-caracteres-coringa","text":"At\u00e9 aqui, temos usado o que chamamos de Caminho Absoluto (Absolute Path) para endere\u00e7ar os arquivos e diret\u00f3rios que usamos. Mas existem atalhos especiais que nos ajudam a facilitar a descri\u00e7\u00e3o de caminhos baseados no diret\u00f3rio atual em que nos localizamos. Uma das op\u00e7\u00f5es dispon\u00edveis no comando ls \u00e9 a op\u00e7\u00e3o -a ou --all , que deixam de ignorar certos arquivos que normalmente n\u00e3o s\u00e3o exibidos. Por padr\u00e3o, os arquivos que come\u00e7am com . (ponto), ficam ocultos normalmente no comando ls . Vamos ver quais arquivos visualizamos ao usar esta op\u00e7\u00e3o: ls -lha Dentre os novos arquivos que antes n\u00e3o eram exibidos, existem dois diret\u00f3rios especiais: . e .. . Estes diret\u00f3rios s\u00e3o usados para nos referirmos a Caminhos Relativos (Relative Paths). O diret\u00f3rio . , aponta para o diret\u00f3rio atual, onde a sess\u00e3o do bash est\u00e1 localizada (o diret\u00f3rio onde voc\u00ea se encontra e que ser\u00e1 exibido com o comando pwd ). J\u00e1 o diret\u00f3rio .. , aponta para o diret\u00f3rio pai do diret\u00f3rio atual, imediatamente superior na hierarquia de diret\u00f3rios, o diret\u00f3rio que antecede o diret\u00f3rio atual na sa\u00edda do comando pwd . Ambos estes diret\u00f3rios podem ser usados como atalho para execu\u00e7\u00e3o de comandos, como os comandos que usamos at\u00e9 aqui: # Criando alguns elementos para demonstrar caminhos relativos cd ~ mkdir -p teste/a/b/c cd teste/a/b touch c/teste.txt cp c/teste.txt .. # copia o arquivo dentro do diret\u00f3rio c para ~/teste/a mv c/teste.txt . # move o arquivo dentro do diret\u00f3rio c para ~/teste/a/b rm ../teste.txt # exclui o arquivo teste.txt do diret\u00f3rio ~/teste/a cp teste.txt ../.. #copia o arquivo teste.txt do diret\u00f3rio atual para ~/teste ls -lha ../.. # lista os arquivos do diret\u00f3rio ~/teste Outro atalho \u00fatil para comandos usando o bash (e outros shells tamb\u00e9m costumam suportar), s\u00e3o Caracteres Coringa (Wild Cards), usados para selecionar arquivos que correspondem com a alguns padr\u00f5es em seus nomes. Para demonstrar isto, vamos antes criar alguns arquivos: cd ~/teste touch foo foo1 foo2 foo10 bar Existem dois caracteres coringas: ? e * . - o ? serve como uma forma de se referir a qualquer caractere que esteja em uma determinada posi\u00e7\u00e3o no nome do arquivo. Por exemplo: ls foo? # Lista todos os arquivos cujo nome come\u00e7am com `foo` e que possuem qualquer outro caractere \u00fanico em seguida Note que, como resultado deste comando, os arquivos foo1 e foo2 foram os \u00fanicos exibidos. Os demais arquivos foram ignorados por n\u00e3o combinarem com o padr\u00e3o, pois foo n\u00e3o possui nenhum caractere na posi\u00e7\u00e3o onde o ? se encontra, e foo10 possui ainda um caractere a mais (j\u00e1 o arquivo bar n\u00e3o corresponde em absolutamente nada com o padr\u00e3o usado). o * serve como uma forma de se referir a quaisquer combina\u00e7\u00e3o de zero ou mais caracteres que possam estar em uma determinada posi\u00e7\u00e3o no nome dos arquivos. Por exemplo: ls foo* Desta vez, s\u00e3o listados todos os arquivos que come\u00e7am com foo , independente de quantos caracteres a mais eles possuem ou n\u00e3o. O arquivo bar , como antes, \u00e9 ignorado por n\u00e3o corresponder ao padr\u00e3o. Voc\u00ea pode usar os caracteres coringa para designar arquivos e diret\u00f3rios como argumentos para qualquer comando do Bash . Por exemplo: rm f?? # apaga somente o arquivo foo cp foo* ./a # copia os arquivos foo1, foo2 e foo10 para ./a mv foo? ./a/b # move somente os arquivos foo1 e foo2 para ./a/b touch * # Atualiza a data/hora de modifica\u00e7\u00e3o de todos os arquivos para a hora atual do sistema","title":"2.6 Caminho Absoluto, Caminho Relativo e Caracteres Coringa"},{"location":"aulas/01-shell/#27-conectando-programas","text":"Uma das capacidades mais incr\u00edveis do Bash \u00e9 a forma como \u00e9 poss\u00edvel manipular a entrada e sa\u00edda dos programas e conect\u00e1-las de diversas formas para redefinir o comportamento padr\u00e3o dos comandos. Me permita explicar melhor antes, como o Shell lida com a entrada e sa\u00edda dos comandos.","title":"2.7 Conectando Programas"},{"location":"aulas/01-shell/#271-streams-de-entrada-e-saida-inputoutput-streams","text":"No Shell, programas possuem dois streams prim\u00e1rios associados a eles: o stream de entrada (input), e o stream de sa\u00edda (output). Quando o programa tenta ler a entrada, ele l\u00ea do stream de entrada, e quando ele imprime algo, ele imprime no stream de sa\u00edda. Normalmente, os streams de entrada e sa\u00edda de um programa s\u00e3o o seu terminal (quando rodando a partir do shell). Ou seja, seu teclado (\u00e0 medida que voc\u00ea digita no shell) e a janela do terminal na sua tela. Contudo, n\u00f3s podemos tamb\u00e9m religar estes streams de outras formas. [!IMPORTANT] Streams em computa\u00e7\u00e3o, \u00e9 um termo comum usado para designar um fluxo de dados que n\u00e3o acontece de uma \u00fanica vez, mas que \u00e9 feito de forma cont\u00ednua, ao longo do tempo, em pequenos lotes. Aqui estamos falando de Streams sendo usados para o fluxo cont\u00ednuo de dados de entrada e de sa\u00edda de um comando ou programa executado no shell. Mas o conceito \u00e9 muito comum em diversas outras \u00e1reas da computa\u00e7\u00e3o, como na leitura/escrita de arquivos no disco, ou obtendo/enviando dados atrav\u00e9s da rede/internet. O termo ficou ainda mais popular com a transmiss\u00e3o de conte\u00fado online como chamadas de v\u00eddeo ou transmiss\u00f5es audiovisuais em lives na internet.","title":"2.7.1 Streams de Entrada e Sa\u00edda (Input/Output Streams)"},{"location":"aulas/01-shell/#272-religamento-de-streams","text":"A forma mais simples de religar streams no Bash \u00e9 atrav\u00e9s dos operadores > (para religar o stream de sa\u00edda do programa) e < (para religar o stream de entrada do programa). Vamos ver alguns exemplos: ls ~ -lha > ~/teste/ls.txt # Religa o stream de sa\u00edda do comando ls para o arquivo ~/teste/ls.txt Note que o comando ls acima n\u00e3o imprimiu a sa\u00edda no terminal como de costume. Por outro lado, voc\u00ea pode conferir um novo arquivo criado no diret\u00f3rio ~/teste chamando ls.txt . Voc\u00ea pode usar o comando cat (que imprime o conte\u00fado de um arquivo no terminal) e voc\u00ea ir\u00e1 notar que o seu conte\u00fado \u00e9 a sa\u00edda do comando ls que teria sido impressa no terminal se n\u00e3o a tiv\u00e9ssemos religado. Uma forma de conferir o conte\u00fado do arquivo ~/teste/ls.txt , \u00e9 o utilizando como stream de entrada do comando cat , que imprime o stream de entrada no stream de sa\u00edda. Ao religar o stream de entrada do comando cat usando o arquivo ~/teste/ls.txt sem religar o stream de sa\u00edda, ele ir\u00e1 imprimir o conte\u00fado no terminal. cat < ~/teste/ls.txt O comando cat , quando n\u00e3o especificado nenhum argumento, usa o terminal como stream de entrada (capturando tudo o que o usu\u00e1rio digitar) e as imprime no stream de sa\u00edda (que tamb\u00e9m \u00e9 o pr\u00f3prio terminal, imprimindo exatamente o que \u00e9 digitado), \u00e0 medida que os dados s\u00e3o enviados (normalmente, sempre que uma linha \u00e9 finalizada). O resultado padr\u00e3o do comando cat , \u00e9 ter suas linhas repetidas, uma vindo pela entrada, e logo em seguida sendo impressa na sa\u00edda. cat # demonstrando os dados digitados no stream de entrada, e impressos na sa\u00edda imediatamente depois Por exemplo, \u00e9 poss\u00edvel usar o cat como um editor de um novo arquivo, que ser\u00e1 criado usando a religa\u00e7\u00e3o do stream de sa\u00edda, digitando o conte\u00fado a partir do stream de entrada. cat > ~/teste/arquivo.txt # Ao digitar conte\u00fado na entrada, ele ser\u00e1 direcionado para o arquivo.txt [!NOTE] Para encerrar a leitura da entrada, n\u00f3s usamos o comando Ctrl+Z. Isto envia um sinal para o processo que est\u00e1 executando o comando cat , orientando-o a parar. Existem outras formas de enviar sinais aos processos quando estamos executando programas no bash, mas veremos isto no futuro. Um outro operador \u00fatil \u00e9 o operador >> . Ele tem, basicamente o mesmo efeito do operador > , que religa o stream de sa\u00edda, com exce\u00e7\u00e3o de que, se a sa\u00edda \u00e9 redirecionada a um arquivo que j\u00e1 existe, ele concatena a sa\u00edda do programa atual ao conte\u00fado original do arquivo, uma opera\u00e7\u00e3o popularmente conhecida na computa\u00e7\u00e3o como append . Ou seja, o conte\u00fado original do arquivo \u00e9 mantido, e o novo conte\u00fado \u00e9 enviado ao final dele. ls -lha ~ >> ~/teste/arquivo.txt Note que o conte\u00fado original do arquivo.txt foi mantido, e o resultado do comando ls foi inserido depois da \u00faltima linha original. Existe um operador que conecta a sa\u00edda de um comando do bash \u00e0 entrada de outro comando, criando uma cadeia de comandos, ou \"esteira\" ( pipeline ), de etapas pelas quais os dados resultantes de um programa s\u00e3o aplicados ao outro, sendo transformados at\u00e9 produzirem uma sa\u00edda desejada. Este operador \u00e9 o | ( pipe ). ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt Aqui temos uma pipeline que faz a seguinte sequ\u00eancia: - ls -lha ~ - lista todos os arquivos da pasta home , em formato de lista, com tamanhos humanamente leg\u00edveis, e inclindo os arquivos ocultos (que come\u00e7am com . ) - grep Jul - o comando grep filtra as linhas vindas da entrada de acordo com algum padr\u00e3o (no caso, Jul ). Basicamente ele pega o resultado do ls e separa somente os arquivos modificados em Julho - head -5 - O comando head toma somente as primeiras linhas da entrada. Por padr\u00e3o, ele toma somente as primeiras 10, mas a op\u00e7\u00e3o -5 faz com que ele pegue somente as primeiras 5 e ignore as demais linhas. - tee /<caminho> - O comando tee \u00e9 um comando similar ao comando cat , com a diferen\u00e7a que, al\u00e9m de imprimir no stream de sa\u00edda, ele tamb\u00e9m escreve o arquivo. No caso acima, ele escreve no terminal e no arquivo /home/dmyoko/teste/pipeline.txt . - Por exemplo, \u00e9 poss\u00edvel criar dois arquivos a partir do comando tee : ls -lha ~ | grep Jul | head -5 | tee /home/dmyoko/teste/pipeline.txt > /home/dmyoko/teste/pipeline2.txt A linha acima instrui instrui o tee a escrever a entrada no arquivo /home/dmyoko/teste/pipeline.txt e religa o stream de sa\u00edda para o arquivo /home/dmyoko/teste/pipeline2.txt usando o operador > . Imagine talvez, usar o operador >> nesta linha, e qual ser\u00e1 o resultado. Como isso iria diferir ambos os arquivos. N\u00f3s iremos usar muito o operador de pipe ( | ) na aula em que iremos tratar de Manipula\u00e7\u00e3o de Dados no Shell.","title":"2.7.2 Religamento de Streams"},{"location":"aulas/01-shell/#28-comandos-uteis","text":"man O comando man exibe um manual de diversos comandos do bash . Usa-se passando como argumento o nome do comando que se deseja consultar: man mkdir find O comando find ajuda a localizar arquivos, procurando n\u00e3o somente no diret\u00f3rio usado como argumento, mas automaticamente buscando em todos os seus subdiret\u00f3rios. Se um diret\u00f3rio n\u00e3o for passado como argumento, o comando find usa o diret\u00f3rio atual por padr\u00e3o. Ele aceita diversas op\u00e7\u00f5es para ajudar a encontrar arquivos de acordo com crit\u00e9rios espec\u00edficos, como o nome do arquivo (op\u00e7\u00e3o -name seguido do nome que se busca, para usar coringas \u00e9 necess\u00e1rio delimitar com ap\u00f3strofos), e muitas outras op\u00e7\u00f5es \u00fateis. Consulte o manual ( man find ) para ler sobre todas as op\u00e7\u00f5es dispon\u00edveis. date Imprime a data/hora atual do sistema. Existem diversas op\u00e7\u00f5es de formata\u00e7\u00e3o em que a Data/Hora ser\u00e3o impressas, para saber mais consulte as p\u00e1ginas do Manual ( man date ) diff Imprime as diferen\u00e7as entre o conte\u00fado de dois caminhos, que precisam ser especificados via argumentos. Podendo ser ambos diret\u00f3rios ou arquivos, mas n\u00e3o compara se forem de tipos diferentes. history Imprime no terminal o hist\u00f3rico de comandos usados nesta sess\u00e3o do Bash . tail O comando tail \u00e9 parecido com o comando head , com a diferen\u00e7a de que, em vez de tomar somente as primeiras x linhas da entrada e ignorar as demais, ele toma somente as \u00faltimas x linhas e ignora as primeiras. less O comando less \u00e9 \u00f3timo para ser usado com comandos que resultam em um n\u00famero elevado de linhas. Ele exibe o resultado de forma paginada e interativa, te permitindo controlar a navega\u00e7\u00e3o pelos dados.","title":"2.8 Comandos \u00dateis"},{"location":"aulas/01-shell/#3-conclusao","text":"Nesta aula tivemos um contato bastante profundo com o Bash e a abordagem de trabalhar a partir de um Shell . Ainda temos muito o que explorar pra explorarmos o shell e conseguir fazer dele um lugar onde possamos nos sentir mais confort\u00e1veis e produtivos o suficiente para fazer dele nosso lugar de trabalho. Mas nas pr\u00f3ximas aulas, ficaremos cada vez mais pr\u00f3ximos disto. Com esta introdu\u00e7\u00e3o, podemos explorar outras ferramentas, como a constru\u00e7\u00e3o de scripts, manipular dados e aprender as conven\u00e7\u00f5es de como \u00e9 a vida na interface de linha de comando ( Command Line Interface ou, simplesmente, CLI ). Bem-vindo a esta jornada, e espero que este primeiro passeio tenha despertado o interesse em prosseguir com as pr\u00f3ximas aulas. Pr\u00f3xima Aula: Aula 2 - Criando Scripts com Bash","title":"3. Conclus\u00e3o"},{"location":"aulas/02-scripting/","text":"Aula 2 - Criando Scripts com Bash Na aula passada fomos apresentados ao ambiente do Shell e come\u00e7amos a nos familiarizar com a vida no terminal usando Bash. Apesar de termos explorado muitas ferramentas que nos permitem interagir com o sistema de arquivos, o uso do Shell n\u00e3o est\u00e1 relegado somente a manipular arquivos e diret\u00f3rios. \u00c9 poss\u00edvel usar o Shell como um ambiente produtivo para lidar com as mais diversas tarefas e, inclusive, automatiz\u00e1-las. Nesta aula iremos explorar as capacidades de automa\u00e7\u00e3o do Bash e criar scripts que expandem a sua utilidade na execu\u00e7\u00e3o de tarefas rotineiras, que o tornam, basicamente, uma linguagem de programa\u00e7\u00e3o n\u00e3o muito diferente das muitas linguagens dispon\u00edveis. 2.1 - Imprimindo Valores (Hello world) A opera\u00e7\u00e3o mais b\u00e1sica que as linguagens de programa\u00e7\u00e3o apresentam \u00e9 a capacidade de imprimir um valor para o usu\u00e1rio. O ritual de inicia\u00e7\u00e3o padr\u00e3o para todos os que estudam uma linguagem de programa\u00e7\u00e3o \u00e9 imprimir a mensagem universal \"Hello, world\" ( Ol\u00e1 mundo ). Usando Bash, o comando que usamos para imprimir mensagens para o usu\u00e1rio \u00e9 o comando echo . echo \"Hello world\" Como vimos na aula passada, as aspas ( \" ) s\u00e3o necess\u00e1rias quando queremos usar espassos nos argumentos dos comandos que usamos no Bash, de outra forma o Bash iria interpretar os espa\u00e7os como separadores de argumentos, possibilitando resultados inesperados. No caso do comando echo , independente de quantos argumentos voc\u00ea usa, o comportamento dele ser\u00e1 o mesmo. echo Hello world Mas, \u00e9 de bom tom seguir a conven\u00e7\u00e3o e usar delimitadores ( \" ou ' ) para garantir a consist\u00eancia dos argumentos. Ao longo desta aula, manter esta consist\u00eancia far\u00e1 mais sentido, \u00e0 medida que veremos como argumentos podem ser transformados ou reutilizados. 2.2 - Express\u00f5es O uso de delimitadores, como o que usamos para definir o argumento \"Hello world\" para o comando echo , \u00e9 um exemplo de uma express\u00e3o . Express\u00f5es s\u00e3o formas de criar valores em uma linguagem de programa\u00e7\u00e3o, e em Bash n\u00e3o \u00e9 diferente. Express\u00f5es de textos s\u00e3o as mais simples que podemos usar, mas existem outros tipos de express\u00f5es, e falaremos um pouco sobre alguns deles. Um tipo de express\u00e3o comum em Bash, \u00e9 o resultado da execu\u00e7\u00e3o de um comando. Para criar express\u00f5es deste tipo, usamos a nota\u00e7\u00e3o $(<comando-bash>) . echo $(ls) A linha acima executa o comando ls e usa a sa\u00edda como resultado de uma express\u00e3o que \u00e9 ent\u00e3o passada para o comando echo . O resultado \u00e9 semelhante \u00e0 execu\u00e7\u00e3o do comando ls no shell (a exibi\u00e7\u00e3o da lista de arquivos). A diferen\u00e7a \u00e9 que podemos usar esta express\u00e3o em outras opera\u00e7\u00f5es, n\u00e3o apenas para exib\u00ed-las (usando o comando echo ), mas tamb\u00e9m, por exemplo, atribuir este valor a vari\u00e1veis e reutiliz\u00e1-la para outros fins, como veremos em breve. \u00c9 poss\u00edvel, tamb\u00e9m, executar express\u00f5es aritm\u00e9ticas e exibir seu resultado. Para criarmos uma express\u00e3o aritm\u00e9tica, usamos a nota\u00e7\u00e3o $(( <express\u00e3o-aritm\u00e9tica> )) . Desta forma, o shell n\u00e3o tentar\u00e1 interpretar a express\u00e3o como se fosse um comando. echo $((7 + 8)) echo $((7 * 8)) echo $(((7 - 3) / (8 % 3))) 2.3 - Definindo vari\u00e1veis Como em qualquer linguagem de programa\u00e7\u00e3o, em Bash n\u00f3s podemos definir vari\u00e1veis para guardar valores que precisam ser reutilizados. Para definir vari\u00e1veis em Bash, tudo o que precisamos fazer \u00e9 uma atribui\u00e7\u00e3o de um valor a um nome, usando o operador = . O \u00fanico cuidado que devemos ao fazermos uma atribui\u00e7\u00e3o \u00e9 redobrar nossa aten\u00e7\u00e3o ao fato de que, em Bash, espa\u00e7os contam. Por exemplo: foo=bar # Atribui\u00e7\u00e3o do valor `bar` a uma nova vari\u00e1vel chamada `foo` foo = bar # Erro. O Bash tenta executar um comando chamado `foo` com 2 argumentos (`-` e `bar`). Para usarmos as vari\u00e1veis que criamos, n\u00f3s nos referimos a elas usando o sinal $ como prefixo. Por exemplo: echo $foo Qualquer resultado de uma express\u00e3o pode ser atribu\u00eddo a uma vari\u00e1vel: soma=$((7 + 8)) 2.3.1 - Interpola\u00e7\u00e3o de Valores Interpola\u00e7\u00e3o de valores \u00e9 a capacidade que o Bash tem de identificar marcadores em valores de texto para substituir por valores computados durante a execu\u00e7\u00e3o do comando. Por exemplo: echo \"o conte\u00fado da vari\u00e1vel foo \u00e9 $foo\" No c\u00f3digo acima, o Bash vai identificar o uso da vari\u00e1vel foo (usada com o $ ), e vai substituir este marcador pelo valor da vari\u00e1vel. A interpola\u00e7\u00e3o de valores s\u00f3 funciona com textos delimitados por \" (aspas). Se o texto for delimitado por ' (ap\u00f3strofos), o bash trata o texto como literal e n\u00e3o faz a interpola\u00e7\u00e3o. Esta distin\u00e7\u00e3o tem suas vantagens, como por exemplo, quando voc\u00ea quer que a interpola\u00e7\u00e3o aconte\u00e7a em um momento diferente do da execu\u00e7\u00e3o do script, delegando a interpola\u00e7\u00e3o para outra etapa da automa\u00e7\u00e3o, ou outro processo que ser\u00e1 executado. Podemos, tamb\u00e9m, interpolar valores resultantes de quaisquer tipos express\u00f5es suportadas pelo Bash. echo \"Interpolando o valor de uma vari\u00e1vel: $foo\" echo \"Interpolando o resultado de um comando: $(ls -lha ~ | grep Jul)\" echo \"Interpolando o resultado de uma express\u00e3o aritm\u00e9tica: $((2 + 3 - 4 * 5 / 6 % 7))\" 2.3.2 - Vari\u00e1veis Especiais pr\u00e9-definidas 2.3.3 - Vari\u00e1veis de ambiente 2.4 - Operadores 2.5 - Substitui\u00e7\u00f5es de Comando 2.6 - Expans\u00f5es do Shell 2.7 - Stream de Erro 2.8 - Shell Script 2.8.1 - Executando Scripts shebang 2.8.2 - Estruturas de controle 2.8.3 - Fun\u00e7\u00f5es 2.9 - Conclus\u00e3o","title":"Aula 2 - Criando Scripts com Bash"},{"location":"aulas/02-scripting/#aula-2-criando-scripts-com-bash","text":"Na aula passada fomos apresentados ao ambiente do Shell e come\u00e7amos a nos familiarizar com a vida no terminal usando Bash. Apesar de termos explorado muitas ferramentas que nos permitem interagir com o sistema de arquivos, o uso do Shell n\u00e3o est\u00e1 relegado somente a manipular arquivos e diret\u00f3rios. \u00c9 poss\u00edvel usar o Shell como um ambiente produtivo para lidar com as mais diversas tarefas e, inclusive, automatiz\u00e1-las. Nesta aula iremos explorar as capacidades de automa\u00e7\u00e3o do Bash e criar scripts que expandem a sua utilidade na execu\u00e7\u00e3o de tarefas rotineiras, que o tornam, basicamente, uma linguagem de programa\u00e7\u00e3o n\u00e3o muito diferente das muitas linguagens dispon\u00edveis.","title":"Aula 2 - Criando Scripts com Bash"},{"location":"aulas/02-scripting/#21-imprimindo-valores-hello-world","text":"A opera\u00e7\u00e3o mais b\u00e1sica que as linguagens de programa\u00e7\u00e3o apresentam \u00e9 a capacidade de imprimir um valor para o usu\u00e1rio. O ritual de inicia\u00e7\u00e3o padr\u00e3o para todos os que estudam uma linguagem de programa\u00e7\u00e3o \u00e9 imprimir a mensagem universal \"Hello, world\" ( Ol\u00e1 mundo ). Usando Bash, o comando que usamos para imprimir mensagens para o usu\u00e1rio \u00e9 o comando echo . echo \"Hello world\" Como vimos na aula passada, as aspas ( \" ) s\u00e3o necess\u00e1rias quando queremos usar espassos nos argumentos dos comandos que usamos no Bash, de outra forma o Bash iria interpretar os espa\u00e7os como separadores de argumentos, possibilitando resultados inesperados. No caso do comando echo , independente de quantos argumentos voc\u00ea usa, o comportamento dele ser\u00e1 o mesmo. echo Hello world Mas, \u00e9 de bom tom seguir a conven\u00e7\u00e3o e usar delimitadores ( \" ou ' ) para garantir a consist\u00eancia dos argumentos. Ao longo desta aula, manter esta consist\u00eancia far\u00e1 mais sentido, \u00e0 medida que veremos como argumentos podem ser transformados ou reutilizados.","title":"2.1 - Imprimindo Valores (Hello world)"},{"location":"aulas/02-scripting/#22-expressoes","text":"O uso de delimitadores, como o que usamos para definir o argumento \"Hello world\" para o comando echo , \u00e9 um exemplo de uma express\u00e3o . Express\u00f5es s\u00e3o formas de criar valores em uma linguagem de programa\u00e7\u00e3o, e em Bash n\u00e3o \u00e9 diferente. Express\u00f5es de textos s\u00e3o as mais simples que podemos usar, mas existem outros tipos de express\u00f5es, e falaremos um pouco sobre alguns deles. Um tipo de express\u00e3o comum em Bash, \u00e9 o resultado da execu\u00e7\u00e3o de um comando. Para criar express\u00f5es deste tipo, usamos a nota\u00e7\u00e3o $(<comando-bash>) . echo $(ls) A linha acima executa o comando ls e usa a sa\u00edda como resultado de uma express\u00e3o que \u00e9 ent\u00e3o passada para o comando echo . O resultado \u00e9 semelhante \u00e0 execu\u00e7\u00e3o do comando ls no shell (a exibi\u00e7\u00e3o da lista de arquivos). A diferen\u00e7a \u00e9 que podemos usar esta express\u00e3o em outras opera\u00e7\u00f5es, n\u00e3o apenas para exib\u00ed-las (usando o comando echo ), mas tamb\u00e9m, por exemplo, atribuir este valor a vari\u00e1veis e reutiliz\u00e1-la para outros fins, como veremos em breve. \u00c9 poss\u00edvel, tamb\u00e9m, executar express\u00f5es aritm\u00e9ticas e exibir seu resultado. Para criarmos uma express\u00e3o aritm\u00e9tica, usamos a nota\u00e7\u00e3o $(( <express\u00e3o-aritm\u00e9tica> )) . Desta forma, o shell n\u00e3o tentar\u00e1 interpretar a express\u00e3o como se fosse um comando. echo $((7 + 8)) echo $((7 * 8)) echo $(((7 - 3) / (8 % 3)))","title":"2.2 - Express\u00f5es"},{"location":"aulas/02-scripting/#23-definindo-variaveis","text":"Como em qualquer linguagem de programa\u00e7\u00e3o, em Bash n\u00f3s podemos definir vari\u00e1veis para guardar valores que precisam ser reutilizados. Para definir vari\u00e1veis em Bash, tudo o que precisamos fazer \u00e9 uma atribui\u00e7\u00e3o de um valor a um nome, usando o operador = . O \u00fanico cuidado que devemos ao fazermos uma atribui\u00e7\u00e3o \u00e9 redobrar nossa aten\u00e7\u00e3o ao fato de que, em Bash, espa\u00e7os contam. Por exemplo: foo=bar # Atribui\u00e7\u00e3o do valor `bar` a uma nova vari\u00e1vel chamada `foo` foo = bar # Erro. O Bash tenta executar um comando chamado `foo` com 2 argumentos (`-` e `bar`). Para usarmos as vari\u00e1veis que criamos, n\u00f3s nos referimos a elas usando o sinal $ como prefixo. Por exemplo: echo $foo Qualquer resultado de uma express\u00e3o pode ser atribu\u00eddo a uma vari\u00e1vel: soma=$((7 + 8))","title":"2.3 - Definindo vari\u00e1veis"},{"location":"aulas/02-scripting/#231-interpolacao-de-valores","text":"Interpola\u00e7\u00e3o de valores \u00e9 a capacidade que o Bash tem de identificar marcadores em valores de texto para substituir por valores computados durante a execu\u00e7\u00e3o do comando. Por exemplo: echo \"o conte\u00fado da vari\u00e1vel foo \u00e9 $foo\" No c\u00f3digo acima, o Bash vai identificar o uso da vari\u00e1vel foo (usada com o $ ), e vai substituir este marcador pelo valor da vari\u00e1vel. A interpola\u00e7\u00e3o de valores s\u00f3 funciona com textos delimitados por \" (aspas). Se o texto for delimitado por ' (ap\u00f3strofos), o bash trata o texto como literal e n\u00e3o faz a interpola\u00e7\u00e3o. Esta distin\u00e7\u00e3o tem suas vantagens, como por exemplo, quando voc\u00ea quer que a interpola\u00e7\u00e3o aconte\u00e7a em um momento diferente do da execu\u00e7\u00e3o do script, delegando a interpola\u00e7\u00e3o para outra etapa da automa\u00e7\u00e3o, ou outro processo que ser\u00e1 executado. Podemos, tamb\u00e9m, interpolar valores resultantes de quaisquer tipos express\u00f5es suportadas pelo Bash. echo \"Interpolando o valor de uma vari\u00e1vel: $foo\" echo \"Interpolando o resultado de um comando: $(ls -lha ~ | grep Jul)\" echo \"Interpolando o resultado de uma express\u00e3o aritm\u00e9tica: $((2 + 3 - 4 * 5 / 6 % 7))\"","title":"2.3.1 - Interpola\u00e7\u00e3o de Valores"},{"location":"aulas/02-scripting/#232-variaveis-especiais-pre-definidas","text":"","title":"2.3.2 - Vari\u00e1veis Especiais pr\u00e9-definidas"},{"location":"aulas/02-scripting/#233-variaveis-de-ambiente","text":"","title":"2.3.3 - Vari\u00e1veis de ambiente"},{"location":"aulas/02-scripting/#24-operadores","text":"","title":"2.4 - Operadores"},{"location":"aulas/02-scripting/#25-substituicoes-de-comando","text":"","title":"2.5 - Substitui\u00e7\u00f5es de Comando"},{"location":"aulas/02-scripting/#26-expansoes-do-shell","text":"","title":"2.6 - Expans\u00f5es do Shell"},{"location":"aulas/02-scripting/#27-stream-de-erro","text":"","title":"2.7 - Stream de Erro"},{"location":"aulas/02-scripting/#28-shell-script","text":"","title":"2.8 - Shell Script"},{"location":"aulas/02-scripting/#281-executando-scripts","text":"shebang","title":"2.8.1 - Executando Scripts"},{"location":"aulas/02-scripting/#282-estruturas-de-controle","text":"","title":"2.8.2 - Estruturas de controle"},{"location":"aulas/02-scripting/#283-funcoes","text":"","title":"2.8.3 - Fun\u00e7\u00f5es"},{"location":"aulas/02-scripting/#29-conclusao","text":"","title":"2.9 - Conclus\u00e3o"}]}